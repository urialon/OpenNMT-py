Context: 
@ override bytecode _ node generate _ expression ( signature signature , bytecode _ generator _ context generator , type return _ type , list < row _ expression > arguments ) { preconditions . check _ argument ( arguments . size ( ) == 2 ) ; variable was _ null = generator . was _ null ( ) ; bytecode _ block block = new bytecode _ block ( ) . comment ( " _ or _ " ) . set _ description ( " _ or _ " ) ; bytecode _ node left = generator . generate ( arguments . get ( 0 ) ) ; bytecode _ node right = generator . generate ( arguments . get ( 1 ) ) ; block . append ( left ) ; if _ statement if _ left _ is _ null = new if _ statement ( " _ if _ left wasnull..." ) . condition ( was _ null ) ; label _ node end = new label _ node ( " _ end _ " ) ; if _ left _ is _ null . if _ true ( new bytecode _ block ( ) . comment ( " _ clear _ the null flag, pop left value off stack, and push left null flag on the stack (true)" ) . append ( was _ null . set ( constant _ false ( ) ) ) . pop ( arguments . get ( 0 ) . get _ type ( ) . get _ java _ type ( ) ) . push ( true ) ) ; label _ node left _ is _ false = new label _ node ( " _ left _ is _ false _ " ) ; if _ left _ is _ null . if _ false ( new bytecode _ block ( ) . comment ( " _ if _ left is true, push true, and goto end" ) . if _ false _ goto ( left _ is _ false ) . push ( true ) . goto _ label ( end ) . comment ( " _ left _ was false; push left null flag on the stack (false)" ) . visit _ label ( left _ is _ false ) . push ( false ) ) ; block . append ( if _ left _ is _ null ) ; block . append ( right ) ; if _ statement if _ right _ is _ null = new if _ statement ( " _ if _ right wasnull..." ) . condition ( was _ null ) ; if _ right _ is _ null . if _ true ( ) . comment ( " _ right _ was null, pop the right value off the stack; wasnull flag remains set to true" ) . pop ( PRED . get _ java _ type ( ) ) ; label _ node right _ is _ true = new label _ node ( " _ right _ is _ true _ " ) ; if _ right _ is _ null . if _ false ( ) . comment ( " _ if _ right is true, pop left null flag off stack, push true and goto end" ) . if _ false _ goto ( right _ is _ true ) . pop ( boolean . class ) . push ( true ) . goto _ label ( end ) . comment ( " _ right _ was false; store left null flag (on stack) in wasnull variable, and push false" ) . visit _ label ( right _ is _ true ) . put _ variable ( was _ null ) . push ( false ) ; block . append ( if _ right _ is _ null ) . visit _ label ( end ) ; return block ; }
Ground truth: arguments.get(1).get_type()
Syntactic prediction: arguments.get(1).get_type()
Baseline prediction: if_right_is_null.get_type()

Context: 
more _ like _ this build _ more _ like _ this ( o _ lucene _ full _ text _ index index , index _ searcher searcher , o _ document metadata ) { more _ like _ this mlt = new more _ like _ this ( PRED ) ; mlt . set _ analyzer ( index . query _ analyzer ( ) ) ; mlt . set _ field _ names ( optional . of _ nullable ( metadata . < list < string > > get _ property ( " _ field _ names _ " ) ) . or _ else ( index . get _ definition ( ) . get _ fields ( ) ) . to _ array ( new string [ ] { } ) ) ; mlt . set _ max _ query _ terms ( optional . of _ nullable ( metadata . < integer > get _ property ( " _ max _ query _ terms _ " ) ) . or _ else ( more _ like _ this . default _ max _ query _ terms ) ) ; mlt . set _ min _ term _ freq ( optional . of _ nullable ( metadata . < integer > get _ property ( " _ min _ term _ freq _ " ) ) . or _ else ( more _ like _ this . default _ min _ term _ freq ) ) ; mlt . set _ max _ doc _ freq ( optional . of _ nullable ( metadata . < integer > get _ property ( " _ max _ doc _ freq _ " ) ) . or _ else ( more _ like _ this . default _ max _ doc _ freq ) ) ; mlt . set _ min _ doc _ freq ( optional . of _ nullable ( metadata . < integer > get _ property ( " _ min _ doc _ freq _ " ) ) . or _ else ( more _ like _ this . default _ max _ doc _ freq ) ) ; mlt . set _ boost ( optional . of _ nullable ( metadata . < boolean > get _ property ( " _ boost _ " ) ) . or _ else ( more _ like _ this . default _ boost ) ) ; mlt . set _ boost _ factor ( optional . of _ nullable ( metadata . < float > get _ property ( " _ boost _ factor _ " ) ) . or _ else ( 1 _ f ) ) ; mlt . set _ max _ word _ len ( optional . of _ nullable ( metadata . < integer > get _ property ( " _ max _ word _ len _ " ) ) . or _ else ( more _ like _ this . default _ max _ word _ length ) ) ; mlt . set _ min _ word _ len ( optional . of _ nullable ( metadata . < integer > get _ property ( " _ min _ word _ len _ " ) ) . or _ else ( more _ like _ this . default _ min _ word _ length ) ) ; mlt . set _ max _ num _ tokens _ parsed ( optional . of _ nullable ( metadata . < integer > get _ property ( " _ max _ num _ tokens _ parsed _ " ) ) . or _ else ( more _ like _ this . default _ max _ num _ tokens _ parsed ) ) ; mlt . set _ stop _ words ( ( set < ? > ) optional . of _ nullable ( metadata . get _ property ( " _ stop _ words _ " ) ) . or _ else ( more _ like _ this . default _ stop _ words ) ) ; return mlt ; }
Ground truth: searcher.get_index_reader()
Syntactic prediction: searcher.get_index_reader()
Baseline prediction: searcher.get_reader()

Context: 
@ get @ timed @ api _ operation ( value = " _ message _ search with absolute timerange." , notes = " _ search _ for messages using an absolute timerange, specified as from/to " + " _ with _ format yyyy-mm-ddthh:mm:ss.sssz (e.g. 2014-01-23t15:34:49.000z) or yyyy-mm-dd hh:mm:ss." ) @ produces ( media _ type . application _ json ) @ api _ responses ( value = { @ api _ response ( code = 400 , message = " _ invalid _ timerange parameters provided." ) } ) search _ response search _ absolute ( @ api _ param ( name = " _ query _ " , value = " _ query _ (lucene syntax)" , required = true ) @ query _ param ( " _ query _ " ) @ not _ empty string query , @ api _ param ( name = " _ from _ " , value = " _ timerange _ start. see description for date format" , required = true ) @ query _ param ( " _ from _ " ) string from , @ api _ param ( name = " _ to _ " , value = " _ timerange _ end. see description for date format" , required = true ) @ query _ param ( " _ to _ " ) string to , @ api _ param ( name = " _ limit _ " , value = " _ maximum _ number of messages to return." , required = false ) @ query _ param ( " _ limit _ " ) int limit , @ api _ param ( name = " _ offset _ " , value = " _ offset _ " , required = false ) @ query _ param ( " _ offset _ " ) int offset , @ api _ param ( name = " _ filter _ " , value = " _ filter _ " , required = false ) @ query _ param ( " _ filter _ " ) string filter , @ api _ param ( name = " _ fields _ " , value = " _ comma _ separated list of fields to return" , required = false ) @ query _ param ( " _ fields _ " ) string fields , @ api _ param ( name = " _ sort _ " , value = " _ sorting _ (field:asc / field:desc)" , required = false ) @ query _ param ( " _ sort _ " ) string sort , @ api _ param ( name = " _ decorate _ " , value = " _ run _ decorators on search result" , required = false ) @ query _ param ( " _ decorate _ " ) @ default _ value ( " _ true _ " ) boolean decorate ) { check _ search _ permission ( filter , rest _ permissions . searches _ absolute ) ; final sorting sorting = build _ sorting ( sort ) ; final list < string > field _ list = parse _ optional _ fields ( fields ) ; time _ range time _ range = build _ absolute _ time _ range ( from , to ) ; final searches _ config searches _ config = PRED . query ( query ) . filter ( filter ) . fields ( field _ list ) . range ( time _ range ) . limit ( limit ) . offset ( offset ) . sorting ( sorting ) . build ( ) ; final optional < string > stream _ id = searches . extract _ stream _ id ( filter ) ; return build _ search _ response ( searches . search ( searches _ config ) , time _ range , decorate , stream _ id ) ; }
Ground truth: searches_config.builder()
Syntactic prediction: searches_config.builder()
Baseline prediction: newsearch_config.builder()

Context: 
config _ def base _ config _ def ( ) { return new config _ def ( ) . define ( bootstrap _ servers _ config , type . list , bootstrap _ servers _ default , importance . high , bootstrap _ servers _ doc ) . define ( key _ converter _ class _ config , type . class , importance . high , key _ converter _ class _ doc ) . define ( value _ converter _ class _ config , type . class , importance . high , value _ converter _ class _ doc ) . define ( internal _ key _ converter _ class _ config , type . class , importance . low , internal _ key _ converter _ class _ doc ) . define ( internal _ value _ converter _ class _ config , type . class , importance . low , internal _ value _ converter _ class _ doc ) . define ( task _ shutdown _ graceful _ timeout _ ms _ config , type . long , task _ shutdown _ graceful _ timeout _ ms _ default , importance . low , task _ shutdown _ graceful _ timeout _ ms _ doc ) . define ( offset _ commit _ interval _ ms _ config , type . long , offset _ commit _ interval _ ms _ default , importance . low , offset _ commit _ interval _ ms _ doc ) . define ( offset _ commit _ timeout _ ms _ config , type . long , offset _ commit _ timeout _ ms _ default , importance . low , offset _ commit _ timeout _ ms _ doc ) . define ( rest _ host _ name _ config , type . string , null , importance . low , rest _ host _ name _ doc ) . define ( rest _ port _ config , type . int , rest _ port _ default , importance . low , rest _ port _ doc ) . define ( rest _ advertised _ host _ name _ config , type . string , null , importance . low , rest _ advertised _ host _ name _ doc ) . define ( rest _ advertised _ port _ config , type . int , null , importance . low , rest _ advertised _ port _ doc ) . define ( access _ control _ allow _ origin _ config , type . string , access _ control _ allow _ origin _ default , importance . low , access _ control _ allow _ origin _ doc ) . define ( access _ control _ allow _ methods _ config , type . string , access _ control _ allow _ methods _ default , importance . low , access _ control _ allow _ methods _ doc ) . define ( plugin _ path _ config , type . list , null , importance . low , plugin _ path _ doc ) . define ( metrics _ sample _ window _ ms _ config , type . long , 30000 , at _ least ( 0 ) , importance . low , common _ client _ configs . metrics _ sample _ window _ ms _ doc ) . define ( metrics _ num _ samples _ config , type . int , 2 , at _ least ( 1 ) , importance . low , PRED ) . define ( metrics _ recording _ level _ config , type . string , sensor . recording _ level . info . to _ string ( ) , in ( sensor . recording _ level . info . to _ string ( ) , sensor . recording _ level . debug . to _ string ( ) ) , importance . low , common _ client _ configs . metrics _ recording _ level _ doc ) . define ( metric _ reporter _ classes _ config , type . list , " _ " , importance . low , common _ client _ configs . metric _ reporter _ classes _ doc ) ; }
Ground truth: common_client_configs.metrics_num_samples_doc
Syntactic prediction: common_client_configs.metrics_num_samples_doc
Baseline prediction: sensor.metric_num_samples_doc

Context: 
expression rewrite _ grouping _ operation ( grouping _ operation expression , query _ specification query _ node , analysis analysis , optional < symbol > group _ id _ symbol ) { require _ non _ null ( query _ node , " _ node _ is null" ) ; require _ non _ null ( analysis , " _ analysis _ is null" ) ; require _ non _ null ( group _ id _ symbol , " _ group _ id _ symbol _ is null" ) ; check _ state ( query _ node . get _ group _ by ( ) . is _ present ( ) , " _ group _ by _ node must be present" ) ; if ( analysis . get _ grouping _ sets ( query _ node ) . size ( ) == 1 ) { return new long _ literal ( " _ 0 _ " ) ; } else { check _ state ( group _ id _ symbol . is _ present ( ) , " _ group _ id _ symbol is missing" ) ; map < node _ ref < expression > , field _ id > column _ reference _ fields = analysis . get _ column _ reference _ fields ( ) ; relation _ id relation _ id = column _ reference _ fields . get ( node _ ref . of ( expression . get _ grouping _ columns ( ) . get ( 0 ) ) ) . get _ relation _ id ( ) ; list < integer > columns = expression . get _ grouping _ columns ( ) . stream ( ) . map ( node _ ref :: of ) . peek ( grouping _ column -> check _ state ( column _ reference _ fields . contains _ key ( grouping _ column ) , " _ the _ grouping column is not in the columnreferencesfield map" ) ) . map ( column _ reference _ fields :: get ) . map ( field _ id -> translate _ field _ to _ integer ( field _ id , relation _ id ) ) . collect ( to _ immutable _ list ( ) ) ; list < list < integer > > grouping _ set _ descriptors = analysis . get _ grouping _ sets ( query _ node ) . stream ( ) . map ( grouping _ set -> PRED . map ( node _ ref :: of ) . filter ( column _ reference _ fields :: contains _ key ) . map ( column _ reference _ fields :: get ) . map ( field _ id -> translate _ field _ to _ integer ( field _ id , relation _ id ) ) . collect ( to _ immutable _ list ( ) ) ) . collect ( to _ immutable _ list ( ) ) ; list < expression > grouping _ results = grouping _ set _ descriptors . stream ( ) . map ( grouping _ set _ descriptors :: index _ of ) . map ( group _ id -> string . value _ of ( calculate _ grouping ( group _ id , columns , grouping _ set _ descriptors ) ) ) . map ( long _ literal :: new ) . collect ( to _ immutable _ list ( ) ) ; return new subscript _ expression ( new array _ constructor ( grouping _ results ) , new arithmetic _ binary _ expression ( add , group _ id _ symbol . get ( ) . to _ symbol _ reference ( ) , new generic _ literal ( " _ bigint _ " , " _ 1 _ " ) ) ) ; } }
Ground truth: grouping_set.stream()
Syntactic prediction: grouping_set.stream()
Baseline prediction: expression.get_grouping_columns().stream()

