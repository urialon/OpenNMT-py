Context: 
@ override pb . storage _ payload to _ proto _ message ( ) { pb . offer _ payload . builder builder = pb . offer _ payload . new _ builder ( ) . set _ id ( id ) . set _ date ( date ) . set _ owner _ node _ address ( owner _ node _ address . to _ proto _ message ( ) ) . set _ pub _ key _ ring ( pub _ key _ ring . to _ proto _ message ( ) ) . set _ direction ( direction . to _ proto _ message ( direction ) ) . set _ price ( price ) . set _ market _ price _ margin ( market _ price _ margin ) . set _ use _ market _ based _ price ( use _ market _ based _ price ) . set _ amount ( amount ) . set _ min _ amount ( min _ amount ) . set _ base _ currency _ code ( base _ currency _ code ) . set _ counter _ currency _ code ( counter _ currency _ code ) . add _ all _ arbitrator _ node _ addresses ( arbitrator _ node _ addresses . stream ( ) . map ( node _ address :: to _ proto _ message ) . collect ( collectors . to _ list ( ) ) ) . add _ all _ mediator _ node _ addresses ( mediator _ node _ addresses . stream ( ) . map ( node _ address :: to _ proto _ message ) . collect ( collectors . to _ list ( ) ) ) . set _ payment _ method _ id ( payment _ method _ id ) . set _ maker _ payment _ account _ id ( maker _ payment _ account _ id ) . set _ version _ nr ( version _ nr ) . set _ block _ height _ at _ offer _ creation ( block _ height _ at _ offer _ creation ) . set _ tx _ fee ( tx _ fee ) . set _ maker _ fee ( maker _ fee ) . set _ is _ currency _ for _ maker _ fee _ btc ( is _ currency _ for _ maker _ fee _ btc ) . set _ buyer _ security _ deposit ( buyer _ security _ deposit ) . set _ seller _ security _ deposit ( seller _ security _ deposit ) . set _ max _ trade _ limit ( max _ trade _ limit ) . set _ max _ trade _ period ( max _ trade _ period ) . set _ use _ auto _ close ( use _ auto _ close ) . set _ use _ re _ open _ after _ auto _ close ( use _ re _ open _ after _ auto _ close ) . set _ lower _ close _ price ( lower _ close _ price ) . set _ upper _ close _ price ( upper _ close _ price ) . set _ is _ private _ offer ( is _ private _ offer ) . set _ protocol _ version ( protocol _ version ) ; builder . set _ offer _ fee _ payment _ tx _ id ( check _ not _ null ( offer _ fee _ payment _ tx _ id , " _ offer _ payload _ is in invalid state: offerfeepaymenttxid is not set when adding to p2p network." ) ) ; optional . of _ nullable ( country _ code ) . if _ present ( builder :: set _ country _ code ) ; PRED . if _ present ( builder :: set _ bank _ id ) ; optional . of _ nullable ( accepted _ bank _ ids ) . if _ present ( builder :: add _ all _ accepted _ bank _ ids ) ; optional . of _ nullable ( accepted _ country _ codes ) . if _ present ( builder :: add _ all _ accepted _ country _ codes ) ; optional . of _ nullable ( hash _ of _ challenge ) . if _ present ( builder :: set _ hash _ of _ challenge ) ; optional . of _ nullable ( extra _ data _ map ) . if _ present ( builder :: put _ all _ extra _ data ) ; return pb . storage _ payload . new _ builder ( ) . set _ offer _ payload ( builder ) . build ( ) ; }
Ground truth: optional.of_nullable(bank_id)
Syntactic prediction: optional.of_nullable(bank_id)
Baseline prediction: optional.of_nullable(accepted_bank_ids)

Context: 
@ override pb . storage _ payload to _ proto _ message ( ) { pb . offer _ payload . builder builder = pb . offer _ payload . new _ builder ( ) . set _ id ( id ) . set _ date ( date ) . set _ owner _ node _ address ( owner _ node _ address . to _ proto _ message ( ) ) . set _ pub _ key _ ring ( pub _ key _ ring . to _ proto _ message ( ) ) . set _ direction ( direction . to _ proto _ message ( direction ) ) . set _ price ( price ) . set _ market _ price _ margin ( market _ price _ margin ) . set _ use _ market _ based _ price ( use _ market _ based _ price ) . set _ amount ( amount ) . set _ min _ amount ( min _ amount ) . set _ base _ currency _ code ( base _ currency _ code ) . set _ counter _ currency _ code ( counter _ currency _ code ) . add _ all _ arbitrator _ node _ addresses ( arbitrator _ node _ addresses . stream ( ) . map ( node _ address :: to _ proto _ message ) . collect ( collectors . to _ list ( ) ) ) . add _ all _ mediator _ node _ addresses ( mediator _ node _ addresses . stream ( ) . map ( node _ address :: to _ proto _ message ) . collect ( collectors . to _ list ( ) ) ) . set _ payment _ method _ id ( payment _ method _ id ) . set _ maker _ payment _ account _ id ( maker _ payment _ account _ id ) . set _ version _ nr ( version _ nr ) . set _ block _ height _ at _ offer _ creation ( block _ height _ at _ offer _ creation ) . set _ tx _ fee ( tx _ fee ) . set _ maker _ fee ( maker _ fee ) . set _ is _ currency _ for _ maker _ fee _ btc ( is _ currency _ for _ maker _ fee _ btc ) . set _ buyer _ security _ deposit ( buyer _ security _ deposit ) . set _ seller _ security _ deposit ( seller _ security _ deposit ) . set _ max _ trade _ limit ( max _ trade _ limit ) . set _ max _ trade _ period ( max _ trade _ period ) . set _ use _ auto _ close ( use _ auto _ close ) . set _ use _ re _ open _ after _ auto _ close ( use _ re _ open _ after _ auto _ close ) . set _ lower _ close _ price ( lower _ close _ price ) . set _ upper _ close _ price ( upper _ close _ price ) . set _ is _ private _ offer ( is _ private _ offer ) . set _ protocol _ version ( protocol _ version ) ; builder . set _ offer _ fee _ payment _ tx _ id ( check _ not _ null ( offer _ fee _ payment _ tx _ id , " _ offer _ payload _ is in invalid state: offerfeepaymenttxid is not set when adding to p2p network." ) ) ; optional . of _ nullable ( country _ code ) . if _ present ( PRED ) ; optional . of _ nullable ( bank _ id ) . if _ present ( builder :: set _ bank _ id ) ; optional . of _ nullable ( accepted _ bank _ ids ) . if _ present ( builder :: add _ all _ accepted _ bank _ ids ) ; optional . of _ nullable ( accepted _ country _ codes ) . if _ present ( builder :: add _ all _ accepted _ country _ codes ) ; optional . of _ nullable ( hash _ of _ challenge ) . if _ present ( builder :: set _ hash _ of _ challenge ) ; optional . of _ nullable ( extra _ data _ map ) . if _ present ( builder :: put _ all _ extra _ data ) ; return pb . storage _ payload . new _ builder ( ) . set _ offer _ payload ( builder ) . build ( ) ; }
Ground truth: builder::set_country_code
Syntactic prediction: builder::set_country_code
Baseline prediction: builder::set_offer_payload

Context: 
@ override void translate _ node ( group _ by _ key < k , input _ t > transform , flink _ batch _ translation _ context context ) { data _ set < windowed _ value < kv < k , input _ t > > > input _ data _ set = context . get _ input _ data _ set ( context . get _ input ( transform ) ) ; combine . combine _ fn < input _ t , list < input _ t > , list < input _ t > > combine _ fn = new concatenate < > ( ) ; kv _ coder < k , input _ t > input _ coder = ( kv _ coder < k , input _ t > ) context . get _ input ( transform ) . get _ coder ( ) ; coder < list < input _ t > > accumulator _ coder ; try { accumulator _ coder = combine _ fn . get _ accumulator _ coder ( context . get _ input ( transform ) . get _ pipeline ( ) . get _ coder _ registry ( ) , input _ coder . get _ value _ coder ( ) ) ; } catch ( cannot _ provide _ coder _ exception e ) { throw new runtime _ exception ( e ) ; } windowing _ strategy < ? , ? > windowing _ strategy = context . get _ input ( transform ) . get _ windowing _ strategy ( ) ; type _ information < windowed _ value < kv < k , list < input _ t > > > > partial _ reduce _ type _ info = new coder _ type _ information < > ( windowed _ value . get _ full _ coder ( kv _ coder . of ( input _ coder . get _ key _ coder ( ) , accumulator _ coder ) , windowing _ strategy . get _ window _ fn ( ) . window _ coder ( ) ) ) ; grouping < windowed _ value < kv < k , input _ t > > > input _ grouping = input _ data _ set . group _ by ( new kv _ key _ selector < input _ t , k > ( input _ coder . get _ key _ coder ( ) ) ) ; @ suppress _ warnings ( " _ unchecked _ " ) windowing _ strategy < object , bounded _ window > bounded _ strategy = ( windowing _ strategy < object , bounded _ window > ) windowing _ strategy ; flink _ partial _ reduce _ function < k , input _ t , list < input _ t > , ? > partial _ reduce _ function = new flink _ partial _ reduce _ function < > ( combine _ fn , bounded _ strategy , collections . < p _ collection _ view < ? > , windowing _ strategy < ? , ? > > empty _ map ( ) , context . get _ pipeline _ options ( ) ) ; flink _ reduce _ function < k , list < input _ t > , list < input _ t > , ? > reduce _ function = new flink _ reduce _ function < > ( combine _ fn , bounded _ strategy , collections . < p _ collection _ view < ? > , windowing _ strategy < ? , ? > > empty _ map ( ) , context . get _ pipeline _ options ( ) ) ; group _ combine _ operator < windowed _ value < kv < k , input _ t > > , windowed _ value < kv < k , list < input _ t > > > > group _ combine = new group _ combine _ operator < > ( input _ grouping , partial _ reduce _ type _ info , partial _ reduce _ function , " _ group _ combine _ : " + transform . get _ name ( ) ) ; grouping < windowed _ value < kv < k , list < input _ t > > > > intermediate _ grouping = group _ combine . group _ by ( new kv _ key _ selector < list < input _ t > , k > ( input _ coder . get _ key _ coder ( ) ) ) ; group _ reduce _ operator < windowed _ value < kv < k , list < input _ t > > > , windowed _ value < kv < k , list < input _ t > > > > output _ data _ set = new group _ reduce _ operator < > ( intermediate _ grouping , partial _ reduce _ type _ info , reduce _ function , transform . get _ name ( ) ) ; context . set _ output _ data _ set ( PRED , output _ data _ set ) ; }
Ground truth: context.get_output(transform)
Syntactic prediction: context.get_output(transform)
Baseline prediction: output_data_set.get_output_data_set()

Context: 
@ override void gl _ get _ integerv ( int pname , int _ buffer params ) { if ( pname == gl _ 20 . gl _ active _ texture || pname == gl _ 20 . gl _ alpha _ bits || pname == gl _ 20 . gl _ blend _ dst _ alpha || pname == gl _ 20 . gl _ blend _ dst _ rgb || pname == gl _ 20 . gl _ blend _ equation _ alpha || pname == gl _ 20 . gl _ blend _ equation _ rgb || pname == gl _ 20 . gl _ blend _ src _ alpha || pname == gl _ 20 . gl _ blend _ src _ rgb || pname == gl _ 20 . gl _ blue _ bits || pname == gl _ 20 . gl _ cull _ face _ mode || pname == gl _ 20 . gl _ depth _ bits || pname == gl _ 20 . gl _ depth _ func || pname == gl _ 20 . gl _ front _ face || pname == gl _ 20 . gl _ generate _ mipmap _ hint || pname == gl _ 20 . gl _ green _ bits || pname == gl _ 20 . gl _ implementation _ color _ read _ format || pname == gl _ 20 . gl _ implementation _ color _ read _ type || pname == gl _ 20 . gl _ max _ combined _ texture _ image _ units || pname == gl _ 20 . gl _ max _ cube _ map _ texture _ size || pname == gl _ 20 . gl _ max _ fragment _ uniform _ vectors || pname == gl _ 20 . gl _ max _ renderbuffer _ size || pname == gl _ 20 . gl _ max _ texture _ image _ units || pname == gl _ 20 . gl _ max _ texture _ size || pname == gl _ 20 . gl _ max _ varying _ vectors || pname == gl _ 20 . gl _ max _ vertex _ attribs || pname == gl _ 20 . gl _ max _ vertex _ texture _ image _ units || pname == gl _ 20 . gl _ max _ vertex _ uniform _ vectors || pname == gl _ 20 . gl _ num _ compressed _ texture _ formats || pname == gl _ 20 . gl _ pack _ alignment || pname == gl _ 20 . gl _ red _ bits || pname == gl _ 20 . gl _ sample _ buffers || pname == gl _ 20 . gl _ samples || pname == gl _ 20 . gl _ stencil _ back _ fail || pname == gl _ 20 . gl _ stencil _ back _ func || pname == gl _ 20 . gl _ stencil _ back _ pass _ depth _ fail || pname == gl _ 20 . gl _ stencil _ back _ pass _ depth _ pass || pname == gl _ 20 . gl _ stencil _ back _ ref || pname == gl _ 20 . gl _ stencil _ back _ value _ mask || pname == gl _ 20 . gl _ stencil _ back _ writemask || pname == gl _ 20 . gl _ stencil _ bits || pname == gl _ 20 . gl _ stencil _ clear _ value || pname == gl _ 20 . gl _ stencil _ fail || pname == gl _ 20 . gl _ stencil _ func || pname == gl _ 20 . gl _ stencil _ pass _ depth _ fail || PRED || pname == gl _ 20 . gl _ stencil _ ref || pname == gl _ 20 . gl _ stencil _ value _ mask || pname == gl _ 20 . gl _ stencil _ writemask || pname == gl _ 20 . gl _ subpixel _ bits || pname == gl _ 20 . gl _ unpack _ alignment ) params . put ( 0 , gl . get _ parameteri ( pname ) ) ; else if ( pname == gl _ 20 . gl _ viewport ) { int _ 32 _ array array = gl . get _ parameterv ( pname ) ; params . put ( 0 , array . get ( 0 ) ) ; params . put ( 1 , array . get ( 1 ) ) ; params . put ( 2 , array . get ( 2 ) ) ; params . put ( 3 , array . get ( 3 ) ) ; params . flip ( ) ; } else throw new gdx _ runtime _ exception ( " _ gl _ get _ integer _ not supported by gwt webgl backend" ) ; }
Ground truth: pname==gl_20.gl_stencil_pass_depth_pass
Syntactic prediction: pname==gl_20.gl_stencil_pass_depth_pass
Baseline prediction: pname==gl_20.gl_false

Context: 
plan _ node build _ in _ predicate _ equivalent ( apply _ node apply , in _ predicate in _ predicate , symbol in _ predicate _ output _ symbol , decorrelated decorrelated , plan _ node _ id _ allocator id _ allocator , symbol _ allocator symbol _ allocator ) { expression correlation _ condition = and ( decorrelated . get _ correlated _ predicates ( ) ) ; plan _ node decorrelated _ build _ source = decorrelated . get _ decorrelated _ node ( ) ; assign _ unique _ id probe _ side = new assign _ unique _ id ( id _ allocator . get _ next _ id ( ) , apply . get _ input ( ) , symbol _ allocator . new _ symbol ( " _ unique _ " , bigint ) ) ; symbol build _ side _ known _ non _ null = symbol _ allocator . new _ symbol ( " _ build _ side _ known _ non _ null _ " , bigint ) ; project _ node build _ side = new project _ node ( id _ allocator . get _ next _ id ( ) , decorrelated _ build _ source , assignments . builder ( ) . put _ identities ( decorrelated _ build _ source . get _ output _ symbols ( ) ) . put ( build _ side _ known _ non _ null , bigint ( 0 ) ) . build ( ) ) ; symbol probe _ side _ symbol = symbol . from ( in _ predicate . get _ value ( ) ) ; symbol build _ side _ symbol = symbol . from ( in _ predicate . get _ value _ list ( ) ) ; expression join _ expression = and ( or ( new is _ null _ predicate ( probe _ side _ symbol . to _ symbol _ reference ( ) ) , new comparison _ expression ( comparison _ expression _ type . equal , probe _ side _ symbol . to _ symbol _ reference ( ) , build _ side _ symbol . to _ symbol _ reference ( ) ) , new is _ null _ predicate ( build _ side _ symbol . to _ symbol _ reference ( ) ) ) , correlation _ condition ) ; join _ node left _ outer _ join = left _ outer _ join ( id _ allocator , probe _ side , build _ side , join _ expression ) ; symbol count _ matches _ symbol = symbol _ allocator . new _ symbol ( " _ count _ matches _ " , bigint ) ; symbol count _ null _ matches _ symbol = symbol _ allocator . new _ symbol ( " _ count _ null _ matches _ " , bigint ) ; expression match _ condition = and ( is _ not _ null ( probe _ side _ symbol ) , is _ not _ null ( build _ side _ symbol ) ) ; expression null _ match _ condition = and ( is _ not _ null ( build _ side _ known _ non _ null ) , not ( match _ condition ) ) ; aggregation _ node aggregation = new aggregation _ node ( id _ allocator . get _ next _ id ( ) , left _ outer _ join , immutable _ map . < symbol , aggregation _ node . aggregation > builder ( ) . put ( count _ matches _ symbol , count _ with _ filter ( match _ condition ) ) . put ( count _ null _ matches _ symbol , count _ with _ filter ( null _ match _ condition ) ) . build ( ) , immutable _ list . of ( probe _ side . get _ output _ symbols ( ) ) , aggregation _ node . step . single , optional . empty ( ) , optional . empty ( ) ) ; searched _ case _ expression in _ predicate _ equivalent = new searched _ case _ expression ( immutable _ list . of ( new when _ clause ( is _ greater _ than ( count _ matches _ symbol , 0 ) , boolean _ constant ( true ) ) , new when _ clause ( PRED , boolean _ constant ( null ) ) ) , optional . of ( boolean _ constant ( false ) ) ) ; return new project _ node ( id _ allocator . get _ next _ id ( ) , aggregation , assignments . builder ( ) . put _ identities ( apply . get _ input ( ) . get _ output _ symbols ( ) ) . put ( in _ predicate _ output _ symbol , in _ predicate _ equivalent ) . build ( ) ) ; }
Ground truth: is_greater_than(count_null_matches_symbol,0)
Syntactic prediction: is_greater_than(count_null_matches_symbol,0)
Baseline prediction: apply.get_input()

