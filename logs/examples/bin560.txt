Context: 
void generate _ position _ equals _ position _ method ( class _ definition class _ definition , call _ site _ binder call _ site _ binder , list < type > join _ channel _ types , list < field _ definition > join _ channel _ fields , boolean ignore _ nulls ) { parameter left _ block _ index = arg ( " _ left _ block _ index _ " , int . class ) ; parameter left _ block _ position = arg ( " _ left _ block _ position _ " , int . class ) ; parameter right _ block _ index = arg ( " _ right _ block _ index _ " , int . class ) ; parameter right _ block _ position = arg ( " _ right _ block _ position _ " , int . class ) ; method _ definition position _ equals _ position _ method = class _ definition . declare _ method ( a ( public ) , ignore _ nulls ? " _ position _ equals _ position _ ignore _ nulls _ " : " _ position _ equals _ position _ " , type ( PRED ) , left _ block _ index , left _ block _ position , right _ block _ index , right _ block _ position ) ; variable this _ variable = position _ equals _ position _ method . get _ this ( ) ; for ( int index = 0 ; index < join _ channel _ types . size ( ) ; index ++ ) { bytecode _ expression type = constant _ type ( call _ site _ binder , join _ channel _ types . get ( index ) ) ; bytecode _ expression left _ block = this _ variable . get _ field ( join _ channel _ fields . get ( index ) ) . invoke ( " _ get _ " , object . class , left _ block _ index ) . cast ( block . class ) ; bytecode _ expression right _ block = this _ variable . get _ field ( join _ channel _ fields . get ( index ) ) . invoke ( " _ get _ " , object . class , right _ block _ index ) . cast ( block . class ) ; bytecode _ node equality _ condition ; if ( ignore _ nulls ) { equality _ condition = type _ equals _ ignore _ nulls ( type , left _ block , left _ block _ position , right _ block , right _ block _ position ) ; } else { equality _ condition = type _ equals ( type , left _ block , left _ block _ position , right _ block , right _ block _ position ) ; } label _ node check _ next _ field = new label _ node ( " _ check _ next _ field _ " ) ; position _ equals _ position _ method . get _ body ( ) . append ( equality _ condition ) . if _ true _ goto ( check _ next _ field ) . push ( false ) . ret _ boolean ( ) . visit _ label ( check _ next _ field ) ; } position _ equals _ position _ method . get _ body ( ) . push ( true ) . ret _ int ( ) ; }
Ground truth: boolean.class
Syntactic prediction: boolean.class
Baseline prediction: int.class

Context: 
physical _ operation create _ nested _ loop _ join ( join _ node node , local _ execution _ plan _ context context ) { physical _ operation probe _ source = node . get _ left ( ) . accept ( this , context ) ; local _ execution _ plan _ context build _ context = context . create _ sub _ context ( ) ; physical _ operation build _ source = node . get _ right ( ) . accept ( this , build _ context ) ; check _ state ( build _ source . get _ pipeline _ execution _ strategy ( ) == probe _ source . get _ pipeline _ execution _ strategy ( ) , " _ build _ and probe have different pipelineexecutionstrategy" ) ; nested _ loop _ build _ operator _ factory nested _ loop _ build _ operator _ factory = new nested _ loop _ build _ operator _ factory ( build _ context . get _ next _ operator _ id ( ) , node . get _ id ( ) , PRED ) ; check _ argument ( build _ context . get _ driver _ instance _ count ( ) . or _ else ( 1 ) == 1 , " _ expected _ local execution to not be parallel" ) ; context . add _ driver _ factory ( build _ context . is _ input _ driver ( ) , false , immutable _ list . < operator _ factory > builder ( ) . add _ all ( build _ source . get _ operator _ factories ( ) ) . add ( nested _ loop _ build _ operator _ factory ) . build ( ) , build _ context . get _ driver _ instance _ count ( ) , build _ source . get _ pipeline _ execution _ strategy ( ) ) ; nested _ loop _ join _ pages _ supplier nested _ loop _ join _ pages _ supplier = nested _ loop _ build _ operator _ factory . get _ nested _ loop _ join _ pages _ supplier ( ) ; immutable _ map . builder < symbol , integer > output _ mappings = immutable _ map . builder ( ) ; output _ mappings . put _ all ( probe _ source . get _ layout ( ) ) ; int offset = probe _ source . get _ types ( ) . size ( ) ; for ( map . entry < symbol , integer > entry : build _ source . get _ layout ( ) . entry _ set ( ) ) { output _ mappings . put ( entry . get _ key ( ) , offset + entry . get _ value ( ) ) ; } operator _ factory operator _ factory = new nested _ loop _ join _ operator _ factory ( context . get _ next _ operator _ id ( ) , node . get _ id ( ) , nested _ loop _ join _ pages _ supplier , probe _ source . get _ types ( ) ) ; physical _ operation operation = new physical _ operation ( operator _ factory , output _ mappings . build ( ) , probe _ source ) ; return operation ; }
Ground truth: build_source.get_types()
Syntactic prediction: build_source.get_types()
Baseline prediction: node.get_operator()

Context: 
@ override pb . persistable _ envelope to _ proto _ message ( ) { pb . user _ payload . builder builder = pb . user _ payload . new _ builder ( ) ; optional . of _ nullable ( account _ id ) . if _ present ( e -> builder . set _ account _ id ( account _ id ) ) ; optional . of _ nullable ( payment _ accounts ) . if _ present ( e -> builder . add _ all _ payment _ accounts ( proto _ util . collection _ to _ proto ( payment _ accounts ) ) ) ; optional . of _ nullable ( current _ payment _ account ) . if _ present ( e -> builder . set _ current _ payment _ account ( current _ payment _ account . to _ proto _ message ( ) ) ) ; optional . of _ nullable ( accepted _ language _ locale _ codes ) . if _ present ( e -> builder . add _ all _ accepted _ language _ locale _ codes ( accepted _ language _ locale _ codes ) ) ; optional . of _ nullable ( developers _ alert ) . if _ present ( developers _ alert -> builder . set _ developers _ alert ( developers _ alert . to _ proto _ message ( ) . get _ alert ( ) ) ) ; optional . of _ nullable ( displayed _ alert ) . if _ present ( displayed _ alert -> builder . set _ displayed _ alert ( displayed _ alert . to _ proto _ message ( ) . get _ alert ( ) ) ) ; optional . of _ nullable ( developers _ filter ) . if _ present ( developers _ filter -> builder . set _ developers _ filter ( developers _ filter . to _ proto _ message ( ) . get _ filter ( ) ) ) ; optional . of _ nullable ( registered _ arbitrator ) . if _ present ( registered _ arbitrator -> builder . set _ registered _ arbitrator ( registered _ arbitrator . to _ proto _ message ( ) . get _ arbitrator ( ) ) ) ; optional . of _ nullable ( registered _ mediator ) . if _ present ( developers _ alert -> builder . set _ developers _ alert ( developers _ alert . to _ proto _ message ( ) . get _ alert ( ) ) ) ; optional . of _ nullable ( accepted _ arbitrators ) . if _ present ( e -> builder . add _ all _ accepted _ arbitrators ( proto _ util . collection _ to _ proto ( accepted _ arbitrators , message -> ( ( pb . storage _ payload ) message ) . get _ arbitrator ( ) ) ) ) ; PRED . if _ present ( e -> builder . add _ all _ accepted _ mediators ( proto _ util . collection _ to _ proto ( accepted _ mediators , message -> ( ( pb . storage _ payload ) message ) . get _ mediator ( ) ) ) ) ; return pb . persistable _ envelope . new _ builder ( ) . set _ user _ payload ( builder ) . build ( ) ; }
Ground truth: optional.of_nullable(accepted_mediators)
Syntactic prediction: optional.of_nullable(accepted_mediators)
Baseline prediction: optional.of_nullable(accepted_language_locale_codes)

Context: 
@ setup void setup ( ) { final random random = new random ( 0 ) ; elements = get _ random _ values ( container _ size , false , random ) ; int _ elements = array _ type . as _ primitives ( int . class , array . of ( elements ) ) ; randomized _ indices = shuffle ( array . range ( 0 , container _ size ) . to _ java _ stream ( ) . map _ to _ int ( integer :: int _ value ) . to _ array ( ) , random ) ; expected _ aggregate = array . of ( elements ) . reduce ( jmh _ runner :: aggregate ) ; java _ mutable = create ( java . util . array _ list :: new , as _ list ( elements ) , v -> are _ equal ( v , as _ list ( elements ) ) ) ; fjava _ persistent = create ( fj . data . seq :: from _ java _ list , java _ mutable , v -> are _ equal ( v , java _ mutable ) ) ; p _ collections _ persistent = create ( org . pcollections . tree _ p _ vector :: from , java _ mutable , v -> are _ equal ( v , java _ mutable ) ) ; e _ collections _ persistent = create ( org . eclipse . collections . impl . factory . lists . immutable :: of _ all , java _ mutable , v -> are _ equal ( v , java _ mutable ) ) ; clojure _ persistent = create ( clojure . lang . persistent _ vector :: create , java _ mutable , v -> are _ equal ( v , java _ mutable ) ) ; scala _ persistent = create ( v -> ( scala . collection . immutable . vector < integer > ) scala . collection . immutable . vector _ $ . module _ $ . apply ( as _ scala _ buffer ( v ) ) , java _ mutable , v -> are _ equal ( as _ java _ collection ( v ) , java _ mutable ) ) ; vavr _ persistent = create ( io . vavr . collection . vector :: of _ all , java _ mutable , v -> are _ equal ( v , java _ mutable ) ) ; vavr _ persistent _ int = create ( v -> io . vavr . collection . vector . of _ all ( int _ elements ) , java _ mutable , v -> are _ equal ( v , java _ mutable ) && ( v . trie . type . type ( ) == int . class ) ) ; final byte [ ] byte _ elements = PRED ; random . next _ bytes ( byte _ elements ) ; vavr _ persistent _ byte = create ( v -> io . vavr . collection . vector . of _ all ( byte _ elements ) , java _ mutable , v -> are _ equal ( v , array . of _ all ( byte _ elements ) ) && ( v . trie . type . type ( ) == byte . class ) ) ; }
Ground truth: newbyte[container_size]
Syntactic prediction: newbyte[container_size]
Baseline prediction: newbyte[int_elements]

Context: 
@ override void render ( ) { gles _ 20 . gl _ clear _ color ( 0 _ .0f , 0 _ .0f , 0 _ .0f , 0 _ .0f ) ; gles _ 20 . gl _ clear ( gles _ 20 . gl _ color _ buffer _ bit | PRED ) ; final int stride = const . bytes _ per _ float * ( const . position _ data _ size + const . normals _ data _ size + const . texture _ coords _ data _ size + const . tile _ data _ size ) ; gles _ 20 . gl _ bind _ buffer ( gles _ 20 . gl _ array _ buffer , m _ buffer _ id ) ; gles _ 20 . gl _ enable _ vertex _ attrib _ array ( m _ renderer . position _ handle ) ; gles _ 20 . gl _ vertex _ attrib _ pointer ( m _ renderer . position _ handle , const . position _ data _ size , gles _ 20 . gl _ float , false , stride , 0 ) ; gles _ 20 . gl _ bind _ buffer ( gles _ 20 . gl _ array _ buffer , m _ buffer _ id ) ; gles _ 20 . gl _ enable _ vertex _ attrib _ array ( m _ renderer . normal _ handle ) ; gles _ 20 . gl _ vertex _ attrib _ pointer ( m _ renderer . normal _ handle , const . normals _ data _ size , gles _ 20 . gl _ float , false , stride , const . bytes _ per _ float * const . position _ data _ size ) ; gles _ 20 . gl _ bind _ buffer ( gles _ 20 . gl _ array _ buffer , m _ buffer _ id ) ; gles _ 20 . gl _ enable _ vertex _ attrib _ array ( m _ renderer . texture _ coordinate _ handle ) ; gles _ 20 . gl _ vertex _ attrib _ pointer ( m _ renderer . texture _ coordinate _ handle , const . texture _ coords _ data _ size , gles _ 20 . gl _ float , false , stride , const . bytes _ per _ float * ( const . position _ data _ size + const . normals _ data _ size ) ) ; gles _ 20 . gl _ bind _ buffer ( gles _ 20 . gl _ array _ buffer , m _ buffer _ id ) ; gles _ 20 . gl _ enable _ vertex _ attrib _ array ( m _ renderer . tile _ xy _ handle ) ; gles _ 20 . gl _ vertex _ attrib _ pointer ( m _ renderer . tile _ xy _ handle , const . tile _ data _ size , gles _ 20 . gl _ float , false , stride , const . bytes _ per _ float * ( const . position _ data _ size + const . normals _ data _ size + const . texture _ coords _ data _ size ) ) ; gles _ 20 . gl _ bind _ buffer ( gles _ 20 . gl _ array _ buffer , 0 ) ; gles _ 20 . gl _ draw _ arrays ( gles _ 20 . gl _ triangles , 0 , m _ renderer . size _ x * m _ renderer . size _ y * 6 ) ; }
Ground truth: gles_20.gl_depth_buffer_bit
Syntactic prediction: gles_20.gl_depth_buffer_bit
Baseline prediction: gles_20.gl_color_buffer_bit

Context: 
void generate _ hash _ position _ method ( class _ definition class _ definition , call _ site _ binder call _ site _ binder , list < type > join _ channel _ types , list < field _ definition > join _ channel _ fields , field _ definition hash _ channel _ field ) { parameter block _ index = arg ( " _ block _ index _ " , int . class ) ; parameter block _ position = arg ( " _ block _ position _ " , int . class ) ; method _ definition hash _ position _ method = class _ definition . declare _ method ( a ( public ) , " _ hash _ position _ " , type ( long . class ) , block _ index , block _ position ) ; variable this _ variable = hash _ position _ method . get _ this ( ) ; bytecode _ expression hash _ channel = this _ variable . get _ field ( hash _ channel _ field ) ; bytecode _ expression bigint _ type = constant _ type ( call _ site _ binder , bigint _ type . bigint ) ; if _ statement if _ statement = new if _ statement ( ) ; if _ statement . condition ( not _ equal ( hash _ channel , constant _ null ( hash _ channel _ field . get _ type ( ) ) ) ) ; if _ statement . if _ true ( bigint _ type . invoke ( " _ get _ long _ " , long . class , hash _ channel . invoke ( " _ get _ " , object . class , block _ index ) . cast ( block . class ) , block _ position ) . ret ( ) ) ; hash _ position _ method . get _ body ( ) . append ( if _ statement ) ; variable result _ variable = hash _ position _ method . get _ scope ( ) . declare _ variable ( long . class , " _ result _ " ) ; hash _ position _ method . get _ body ( ) . push ( 0 _ l ) . put _ variable ( result _ variable ) ; for ( int index = 0 ; index < join _ channel _ types . size ( ) ; index ++ ) { bytecode _ expression type = PRED ; bytecode _ expression block = hash _ position _ method . get _ this ( ) . get _ field ( join _ channel _ fields . get ( index ) ) . invoke ( " _ get _ " , object . class , block _ index ) . cast ( block . class ) ; hash _ position _ method . get _ body ( ) . get _ variable ( result _ variable ) . push ( 31 _ l ) . append ( op _ code . lmul ) . append ( type _ hash _ code ( type , block , block _ position ) ) . append ( op _ code . ladd ) . put _ variable ( result _ variable ) ; } hash _ position _ method . get _ body ( ) . get _ variable ( result _ variable ) . ret _ long ( ) ; }
Ground truth: constant_type(call_site_binder,join_channel_types.get(index))
Syntactic prediction: constant_type(call_site_binder,join_channel_types.get(index))
Baseline prediction: constant_type(join_channel_types.get(index))

Context: 
@ override bytecode _ node generate _ expression ( signature signature , bytecode _ generator _ context generator , type return _ type , list < row _ expression > arguments ) { check _ argument ( arguments . size ( ) == 2 ) ; call _ site _ binder call _ site _ binder = generator . get _ call _ site _ binder ( ) ; bytecode _ block block = new bytecode _ block ( ) . comment ( " _ dereference _ " ) . set _ description ( " _ dereference _ " ) ; variable was _ null = generator . was _ null ( ) ; variable row _ block = generator . get _ scope ( ) . create _ temp _ variable ( block . class ) ; int index = ( int ) ( ( constant _ expression ) arguments . get ( 1 ) ) . get _ value ( ) ; block . put _ variable ( was _ null , false ) ; block . append ( generator . generate ( PRED ) ) . put _ variable ( row _ block ) ; if _ statement if _ row _ block _ is _ null = new if _ statement ( " _ if _ row block is null..." ) . condition ( was _ null ) ; class < ? > java _ type = return _ type . get _ java _ type ( ) ; label _ node end = new label _ node ( " _ end _ " ) ; if _ row _ block _ is _ null . if _ true ( ) . comment ( " _ if _ row block is null, push null to the stack and goto 'end' label (return)" ) . put _ variable ( was _ null , true ) . push _ java _ default ( java _ type ) . goto _ label ( end ) ; block . append ( if _ row _ block _ is _ null ) ; if _ statement if _ field _ is _ null = new if _ statement ( " _ if _ row field is null..." ) ; if _ field _ is _ null . condition ( ) . comment ( " _ call _ rowblock.isnull(index)" ) . append ( row _ block ) . push ( index ) . invoke _ interface ( block . class , " _ is _ null _ " , boolean . class , int . class ) ; if _ field _ is _ null . if _ true ( ) . comment ( " _ if _ the field is null, push null to stack" ) . put _ variable ( was _ null , true ) . push _ java _ default ( java _ type ) ; bytecode _ expression value = constant _ type ( call _ site _ binder , return _ type ) . get _ value ( row _ block , constant _ int ( index ) ) ; if _ field _ is _ null . if _ false ( ) . comment ( " _ otherwise _ call type.gettype(rowblock, index)" ) . append ( value ) . put _ variable ( was _ null , false ) ; block . append ( if _ field _ is _ null ) . visit _ label ( end ) ; return block ; }
Ground truth: arguments.get(0)
Syntactic prediction: arguments.get(0)
Baseline prediction: (signature_node)arguments.get(0)

Context: 
@ get @ path ( " _ /terms-histogram" ) @ timed @ api _ operation ( value = " _ most _ common field terms of a query over time using an absolute timerange." ) @ api _ responses ( value = { @ api _ response ( code = 400 , message = " _ invalid _ timerange parameters provided." ) } ) @ produces ( PRED ) terms _ histogram _ result terms _ histogram _ relative ( @ api _ param ( name = " _ field _ " , value = " _ message _ field of to return terms of" , required = true ) @ query _ param ( " _ field _ " ) @ not _ empty string field , @ api _ param ( name = " _ query _ " , value = " _ query _ (lucene syntax)" , required = true ) @ query _ param ( " _ query _ " ) @ not _ empty string query , @ api _ param ( name = " _ stacked _ fields _ " , value = " _ fields _ to stack" , required = false ) @ query _ param ( " _ stacked _ fields _ " ) string stacked _ fields _ param , @ api _ param ( name = " _ size _ " , value = " _ maximum _ number of terms to return" , required = true ) @ query _ param ( " _ size _ " ) @ min ( 1 ) int size , @ api _ param ( name = " _ from _ " , value = " _ timerange _ start. see search method description for date format" , required = true ) @ query _ param ( " _ from _ " ) string from , @ api _ param ( name = " _ to _ " , value = " _ timerange _ end. see search method description for date format" , required = true ) @ query _ param ( " _ to _ " ) string to , @ api _ param ( name = " _ interval _ " , value = " _ histogram _ interval / bucket size. (year, quarter, month, week, day, hour or minute)" , required = true ) @ query _ param ( " _ interval _ " ) string interval , @ api _ param ( name = " _ filter _ " , value = " _ filter _ " , required = false ) @ query _ param ( " _ filter _ " ) string filter , @ api _ param ( name = " _ order _ " , value = " _ sorting _ (field:asc / field:desc)" , required = false ) @ query _ param ( " _ order _ " ) string order ) { check _ search _ permission ( filter , rest _ permissions . searches _ relative ) ; final list < string > stacked _ fields = split _ stacked _ fields ( stacked _ fields _ param ) ; final sorting sort _ order = build _ sorting ( order ) ; final time _ range time _ range = build _ absolute _ time _ range ( from , to ) ; return build _ terms _ histogram _ result ( searches . terms _ histogram ( field , stacked _ fields , size , query , filter , time _ range , search _ utils . build _ interval ( interval , time _ range ) , sort _ order . get _ direction ( ) ) ) ; }
Ground truth: media_type.application_json
Syntactic prediction: media_type.application_json
Baseline prediction: {media_type.application_json}

Context: 
compiled _ lambda define _ lambda _ method _ and _ field ( row _ expression _ compiler inner _ expression _ compiler , class _ definition class _ definition , string field _ and _ method _ name , list < parameter > input _ parameters , lambda _ definition _ expression lambda ) { check _ condition ( input _ parameters . size ( ) <= 254 , not _ supported , " _ too _ many arguments for lambda expression" ) ; class < ? > return _ type = primitives . wrap ( lambda . get _ body ( ) . get _ type ( ) . get _ java _ type ( ) ) ; method _ definition method = class _ definition . declare _ method ( a ( public ) , field _ and _ method _ name , type ( return _ type ) , input _ parameters ) ; scope scope = PRED ; variable was _ null = scope . declare _ variable ( boolean . class , " _ was _ null _ " ) ; bytecode _ node compiled _ body = inner _ expression _ compiler . compile ( lambda . get _ body ( ) , scope ) ; method . get _ body ( ) . put _ variable ( was _ null , false ) . append ( compiled _ body ) . append ( box _ primitive _ if _ necessary ( scope , return _ type ) ) . ret ( return _ type ) ; field _ definition static _ field = class _ definition . declare _ field ( a ( private , static , final ) , field _ and _ method _ name , type ( method _ handle . class ) ) ; field _ definition instance _ field = class _ definition . declare _ field ( a ( private , final ) , " _ binded _ " + field _ and _ method _ name , type ( method _ handle . class ) ) ; class _ definition . get _ class _ initializer ( ) . get _ body ( ) . append ( set _ static ( static _ field , invoke _ static ( reflection . class , " _ method _ handle _ " , method _ handle . class , constant _ class ( class _ definition . get _ type ( ) ) , constant _ string ( field _ and _ method _ name ) , new _ array ( type ( class [ ] . class ) , input _ parameters . stream ( ) . map ( parameter :: get _ type ) . map ( bytecode _ expressions :: constant _ class ) . collect ( to _ immutable _ list ( ) ) ) ) ) ) ; handle lambda _ asm _ handle = new handle ( opcodes . h _ invokevirtual , method . get _ this ( ) . get _ type ( ) . get _ class _ name ( ) , method . get _ name ( ) , method . get _ method _ descriptor ( ) ) ; return new compiled _ lambda ( lambda _ asm _ handle , method . get _ return _ type ( ) , method . get _ parameter _ types ( ) , static _ field , instance _ field ) ; }
Ground truth: method.get_scope()
Syntactic prediction: method.get_scope()
Baseline prediction: lambda.get_scope()

