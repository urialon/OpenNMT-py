Context: 
void matrix _ 4 _ mul ( float [ ] mata , float [ ] matb ) { float tmp [ ] = new float [ 16 ] ; tmp [ m _ 00 ] = mata [ m _ 00 ] * matb [ m _ 00 ] + mata [ m _ 01 ] * matb [ m _ 10 ] + mata [ m _ 02 ] * matb [ m _ 20 ] + mata [ m _ 03 ] * matb [ m _ 30 ] ; tmp [ m _ 01 ] = mata [ m _ 00 ] * matb [ m _ 01 ] + mata [ m _ 01 ] * matb [ m _ 11 ] + mata [ m _ 02 ] * matb [ m _ 21 ] + mata [ m _ 03 ] * matb [ m _ 31 ] ; tmp [ m _ 02 ] = mata [ m _ 00 ] * matb [ m _ 02 ] + mata [ m _ 01 ] * matb [ m _ 12 ] + mata [ m _ 02 ] * matb [ m _ 22 ] + mata [ m _ 03 ] * matb [ m _ 32 ] ; tmp [ m _ 03 ] = mata [ m _ 00 ] * matb [ m _ 03 ] + mata [ m _ 01 ] * matb [ m _ 13 ] + mata [ m _ 02 ] * matb [ m _ 23 ] + mata [ m _ 03 ] * matb [ m _ 33 ] ; tmp [ m _ 10 ] = mata [ m _ 10 ] * matb [ m _ 00 ] + mata [ m _ 11 ] * matb [ m _ 10 ] + mata [ m _ 12 ] * matb [ m _ 20 ] + mata [ m _ 13 ] * matb [ m _ 30 ] ; tmp [ m _ 11 ] = mata [ m _ 10 ] * matb [ m _ 01 ] + mata [ m _ 11 ] * matb [ m _ 11 ] + mata [ m _ 12 ] * matb [ m _ 21 ] + mata [ m _ 13 ] * matb [ m _ 31 ] ; tmp [ m _ 12 ] = mata [ m _ 10 ] * matb [ m _ 02 ] + mata [ m _ 11 ] * matb [ m _ 12 ] + mata [ m _ 12 ] * matb [ m _ 22 ] + mata [ m _ 13 ] * matb [ m _ 32 ] ; tmp [ m _ 13 ] = mata [ m _ 10 ] * matb [ m _ 03 ] + mata [ m _ 11 ] * matb [ m _ 13 ] + mata [ m _ 12 ] * matb [ m _ 23 ] + mata [ m _ 13 ] * matb [ m _ 33 ] ; tmp [ m _ 20 ] = mata [ m _ 20 ] * matb [ m _ 00 ] + mata [ m _ 21 ] * matb [ m _ 10 ] + mata [ m _ 22 ] * matb [ m _ 20 ] + mata [ m _ 23 ] * matb [ m _ 30 ] ; tmp [ m _ 21 ] = mata [ m _ 20 ] * matb [ m _ 01 ] + mata [ m _ 21 ] * matb [ m _ 11 ] + mata [ m _ 22 ] * matb [ m _ 21 ] + mata [ m _ 23 ] * matb [ m _ 31 ] ; tmp [ m _ 22 ] = mata [ m _ 20 ] * matb [ m _ 02 ] + mata [ m _ 21 ] * matb [ m _ 12 ] + mata [ m _ 22 ] * matb [ m _ 22 ] + PRED ; tmp [ m _ 23 ] = mata [ m _ 20 ] * matb [ m _ 03 ] + mata [ m _ 21 ] * matb [ m _ 13 ] + mata [ m _ 22 ] * matb [ m _ 23 ] + mata [ m _ 23 ] * matb [ m _ 33 ] ; tmp [ m _ 30 ] = mata [ m _ 30 ] * matb [ m _ 00 ] + mata [ m _ 31 ] * matb [ m _ 10 ] + mata [ m _ 32 ] * matb [ m _ 20 ] + mata [ m _ 33 ] * matb [ m _ 30 ] ; tmp [ m _ 31 ] = mata [ m _ 30 ] * matb [ m _ 01 ] + mata [ m _ 31 ] * matb [ m _ 11 ] + mata [ m _ 32 ] * matb [ m _ 21 ] + mata [ m _ 33 ] * matb [ m _ 31 ] ; tmp [ m _ 32 ] = mata [ m _ 30 ] * matb [ m _ 02 ] + mata [ m _ 31 ] * matb [ m _ 12 ] + mata [ m _ 32 ] * matb [ m _ 22 ] + mata [ m _ 33 ] * matb [ m _ 32 ] ; tmp [ m _ 33 ] = mata [ m _ 30 ] * matb [ m _ 03 ] + mata [ m _ 31 ] * matb [ m _ 13 ] + mata [ m _ 32 ] * matb [ m _ 23 ] + mata [ m _ 33 ] * matb [ m _ 33 ] ; system . arraycopy ( tmp , 0 , mata , 0 , 16 ) ; }
Ground truth: mata[m_23]*matb[m_32]
Syntactic prediction: mata[m_23]*matb[m_32]
Baseline prediction: mata[m_22]*matb[m_22]

Context: 
void matrix _ 4 _ mul ( float [ ] mata , float [ ] matb ) { float tmp [ ] = new float [ 16 ] ; tmp [ m _ 00 ] = mata [ m _ 00 ] * matb [ m _ 00 ] + mata [ m _ 01 ] * matb [ m _ 10 ] + mata [ m _ 02 ] * matb [ m _ 20 ] + mata [ m _ 03 ] * matb [ m _ 30 ] ; tmp [ m _ 01 ] = mata [ m _ 00 ] * matb [ m _ 01 ] + mata [ m _ 01 ] * matb [ m _ 11 ] + mata [ m _ 02 ] * matb [ m _ 21 ] + mata [ m _ 03 ] * matb [ m _ 31 ] ; tmp [ m _ 02 ] = mata [ m _ 00 ] * matb [ m _ 02 ] + mata [ m _ 01 ] * matb [ m _ 12 ] + mata [ m _ 02 ] * matb [ m _ 22 ] + mata [ m _ 03 ] * matb [ m _ 32 ] ; tmp [ m _ 03 ] = mata [ m _ 00 ] * matb [ m _ 03 ] + mata [ m _ 01 ] * matb [ m _ 13 ] + mata [ m _ 02 ] * matb [ m _ 23 ] + mata [ m _ 03 ] * matb [ m _ 33 ] ; tmp [ m _ 10 ] = mata [ m _ 10 ] * matb [ m _ 00 ] + mata [ m _ 11 ] * matb [ m _ 10 ] + mata [ m _ 12 ] * matb [ m _ 20 ] + mata [ m _ 13 ] * matb [ m _ 30 ] ; tmp [ m _ 11 ] = mata [ m _ 10 ] * matb [ m _ 01 ] + mata [ m _ 11 ] * matb [ m _ 11 ] + mata [ m _ 12 ] * matb [ m _ 21 ] + mata [ m _ 13 ] * matb [ m _ 31 ] ; tmp [ m _ 12 ] = mata [ m _ 10 ] * matb [ m _ 02 ] + mata [ m _ 11 ] * matb [ m _ 12 ] + mata [ m _ 12 ] * matb [ m _ 22 ] + mata [ m _ 13 ] * matb [ m _ 32 ] ; tmp [ m _ 13 ] = mata [ m _ 10 ] * matb [ m _ 03 ] + mata [ m _ 11 ] * matb [ m _ 13 ] + mata [ m _ 12 ] * matb [ m _ 23 ] + mata [ m _ 13 ] * matb [ m _ 33 ] ; tmp [ m _ 20 ] = mata [ m _ 20 ] * matb [ m _ 00 ] + mata [ m _ 21 ] * matb [ m _ 10 ] + mata [ m _ 22 ] * matb [ m _ 20 ] + mata [ m _ 23 ] * matb [ m _ 30 ] ; tmp [ m _ 21 ] = mata [ m _ 20 ] * matb [ m _ 01 ] + mata [ m _ 21 ] * matb [ m _ 11 ] + mata [ m _ 22 ] * matb [ m _ 21 ] + PRED ; tmp [ m _ 22 ] = mata [ m _ 20 ] * matb [ m _ 02 ] + mata [ m _ 21 ] * matb [ m _ 12 ] + mata [ m _ 22 ] * matb [ m _ 22 ] + mata [ m _ 23 ] * matb [ m _ 32 ] ; tmp [ m _ 23 ] = mata [ m _ 20 ] * matb [ m _ 03 ] + mata [ m _ 21 ] * matb [ m _ 13 ] + mata [ m _ 22 ] * matb [ m _ 23 ] + mata [ m _ 23 ] * matb [ m _ 33 ] ; tmp [ m _ 30 ] = mata [ m _ 30 ] * matb [ m _ 00 ] + mata [ m _ 31 ] * matb [ m _ 10 ] + mata [ m _ 32 ] * matb [ m _ 20 ] + mata [ m _ 33 ] * matb [ m _ 30 ] ; tmp [ m _ 31 ] = mata [ m _ 30 ] * matb [ m _ 01 ] + mata [ m _ 31 ] * matb [ m _ 11 ] + mata [ m _ 32 ] * matb [ m _ 21 ] + mata [ m _ 33 ] * matb [ m _ 31 ] ; tmp [ m _ 32 ] = mata [ m _ 30 ] * matb [ m _ 02 ] + mata [ m _ 31 ] * matb [ m _ 12 ] + mata [ m _ 32 ] * matb [ m _ 22 ] + mata [ m _ 33 ] * matb [ m _ 32 ] ; tmp [ m _ 33 ] = mata [ m _ 30 ] * matb [ m _ 03 ] + mata [ m _ 31 ] * matb [ m _ 13 ] + mata [ m _ 32 ] * matb [ m _ 23 ] + mata [ m _ 33 ] * matb [ m _ 33 ] ; system . arraycopy ( tmp , 0 , mata , 0 , 16 ) ; }
Ground truth: mata[m_23]*matb[m_31]
Syntactic prediction: mata[m_23]*matb[m_31]
Baseline prediction: mata[m_22]*matb[m_22]

Context: 
void matrix _ 4 _ mul ( float [ ] mata , float [ ] matb ) { float tmp [ ] = new float [ 16 ] ; tmp [ m _ 00 ] = mata [ m _ 00 ] * matb [ m _ 00 ] + mata [ m _ 01 ] * matb [ m _ 10 ] + mata [ m _ 02 ] * matb [ m _ 20 ] + mata [ m _ 03 ] * matb [ m _ 30 ] ; tmp [ m _ 01 ] = mata [ m _ 00 ] * matb [ m _ 01 ] + mata [ m _ 01 ] * matb [ m _ 11 ] + mata [ m _ 02 ] * matb [ m _ 21 ] + mata [ m _ 03 ] * matb [ m _ 31 ] ; tmp [ m _ 02 ] = mata [ m _ 00 ] * matb [ m _ 02 ] + mata [ m _ 01 ] * matb [ m _ 12 ] + mata [ m _ 02 ] * matb [ m _ 22 ] + mata [ m _ 03 ] * matb [ m _ 32 ] ; tmp [ m _ 03 ] = mata [ m _ 00 ] * matb [ m _ 03 ] + mata [ m _ 01 ] * matb [ m _ 13 ] + mata [ m _ 02 ] * matb [ m _ 23 ] + mata [ m _ 03 ] * matb [ m _ 33 ] ; tmp [ m _ 10 ] = mata [ m _ 10 ] * matb [ m _ 00 ] + mata [ m _ 11 ] * matb [ m _ 10 ] + mata [ m _ 12 ] * matb [ m _ 20 ] + mata [ m _ 13 ] * matb [ m _ 30 ] ; tmp [ m _ 11 ] = mata [ m _ 10 ] * matb [ m _ 01 ] + mata [ m _ 11 ] * matb [ m _ 11 ] + mata [ m _ 12 ] * matb [ m _ 21 ] + mata [ m _ 13 ] * matb [ m _ 31 ] ; tmp [ m _ 12 ] = mata [ m _ 10 ] * matb [ m _ 02 ] + mata [ m _ 11 ] * matb [ m _ 12 ] + mata [ m _ 12 ] * matb [ m _ 22 ] + mata [ m _ 13 ] * matb [ m _ 32 ] ; tmp [ m _ 13 ] = mata [ m _ 10 ] * matb [ m _ 03 ] + mata [ m _ 11 ] * matb [ m _ 13 ] + mata [ m _ 12 ] * matb [ m _ 23 ] + mata [ m _ 13 ] * matb [ m _ 33 ] ; tmp [ m _ 20 ] = mata [ m _ 20 ] * matb [ m _ 00 ] + mata [ m _ 21 ] * matb [ m _ 10 ] + mata [ m _ 22 ] * matb [ m _ 20 ] + mata [ m _ 23 ] * matb [ m _ 30 ] ; tmp [ m _ 21 ] = mata [ m _ 20 ] * matb [ m _ 01 ] + mata [ m _ 21 ] * matb [ m _ 11 ] + mata [ m _ 22 ] * matb [ m _ 21 ] + mata [ m _ 23 ] * matb [ m _ 31 ] ; tmp [ m _ 22 ] = PRED + mata [ m _ 21 ] * matb [ m _ 12 ] + mata [ m _ 22 ] * matb [ m _ 22 ] + mata [ m _ 23 ] * matb [ m _ 32 ] ; tmp [ m _ 23 ] = mata [ m _ 20 ] * matb [ m _ 03 ] + mata [ m _ 21 ] * matb [ m _ 13 ] + mata [ m _ 22 ] * matb [ m _ 23 ] + mata [ m _ 23 ] * matb [ m _ 33 ] ; tmp [ m _ 30 ] = mata [ m _ 30 ] * matb [ m _ 00 ] + mata [ m _ 31 ] * matb [ m _ 10 ] + mata [ m _ 32 ] * matb [ m _ 20 ] + mata [ m _ 33 ] * matb [ m _ 30 ] ; tmp [ m _ 31 ] = mata [ m _ 30 ] * matb [ m _ 01 ] + mata [ m _ 31 ] * matb [ m _ 11 ] + mata [ m _ 32 ] * matb [ m _ 21 ] + mata [ m _ 33 ] * matb [ m _ 31 ] ; tmp [ m _ 32 ] = mata [ m _ 30 ] * matb [ m _ 02 ] + mata [ m _ 31 ] * matb [ m _ 12 ] + mata [ m _ 32 ] * matb [ m _ 22 ] + mata [ m _ 33 ] * matb [ m _ 32 ] ; tmp [ m _ 33 ] = mata [ m _ 30 ] * matb [ m _ 03 ] + mata [ m _ 31 ] * matb [ m _ 13 ] + mata [ m _ 32 ] * matb [ m _ 23 ] + mata [ m _ 33 ] * matb [ m _ 33 ] ; system . arraycopy ( tmp , 0 , mata , 0 , 16 ) ; }
Ground truth: mata[m_20]*matb[m_02]
Syntactic prediction: mata[m_20]*matb[m_02]
Baseline prediction: mata[m_20]*matb[m_23]

Context: 
es pot especificar una cadena de consulta en la via d 'accs i la cadena de consulta" } , { msg _ key . er _ no _ port _ if _ no _ host , " _ no _ es pot especificar el port si no s' especifica el sistema principal " } , { msg _ key . er _ no _ userinfo _ if _ no _ host , " _ no _ es pot especificar informaci de l 'usuari si no s' especifica el sistema principal " } , { msg _ key . er _ xml _ version _ not _ supported , " _ av _ s : la versi del document de sortida s ' 'ha sollicitat que sigui ' '{0}' '. aquesta versi de xml no est suportada. la versi del document de sortida ser ' '1.0' '." } , { msg _ key . er _ scheme _ required , " _ es _ necessita l' esquema " } , { msg _ key . er _ factory _ property _ missing , " _ l _ ' 'objecte de propietats passat a serializerfactory no t cap propietat ' '{0}' '." } , { msg _ key . er _ encoding _ not _ supported , " _ av _ s: el temps d' 'execuci de java no dna suport a la codificaci ' '{0}' '." } , { msg _ key . er _ feature _ not _ found , " _ el _ parmetre ' '{0}' ' no es reconeix." } , { msg _ key . er _ feature _ not _ supported , " _ el _ parmetre ' '{0}' ' es reconeix per el valor sollicitat no es pot establir." } , { msg _ key . er _ string _ too _ long , " _ la _ cadena resultant s massa llarga per cabre en una domstring: ' '{0}' '." } , { msg _ key . er _ type _ mismatch _ err , " _ el _ tipus de valor per a aquest nom de parmetre s incompatible amb el tipus de valor esperat." } , { msg _ key . er _ no _ output _ specified , " _ la _ destinaci de sortida per a les dades que s' ha d 'escriure era nulla." } , { msg _ key . er _ unsupported _ encoding , " _ s _ ' ha trobat una codificaci no suportada . " } , { msg _ key . er _ unable _ to _ serialize _ node , " _ el _ node no s 'ha pogut serialitzat." } , { msg _ key . er _ cdata _ sections _ split , " _ la _ secci cdata cont un o ms marcadors d' acabament ']]>' . " } , { msg _ key . er _ warning _ wf _ not _ checked , " _ no _ s 'ha pogut crear cap instncia per comprovar si t un format correcte o no. el parmetre del tipus ben format es va establir en cert, per la comprovaci de format no s' ha pogut realitzar . " } , { msg _ key . er _ wf _ invalid _ character , " _ el _ node ' '{0}' ' cont carcters xml no vlids." } , { msg _ key . er _ wf _ invalid _ character _ in _ comment , " _ s _ ' 'ha trobat un carcter xml no vlid (unicode: 0x{0}) en el comentari." } , { msg _ key . er _ wf _ invalid _ character _ in _ pi , " _ s _ ' 'ha trobat un carcter xml no vlid (unicode: 0x{0}) en les dades d' 'instrucci de procs." } , { msg _ key . er _ wf _ invalid _ character _ in _ cdata , " _ s _ ' 'ha trobat un carcter xml no vlid (unicode: 0x' '{0})' ' en els continguts de la cdatasection." } , { msg _ key . er _ wf _ invalid _ character _ in _ text , " _ s _ ' 'ha trobat un carcter xml no vlid (unicode: 0x' '{0})' ' en el contingut de dades de carcter del node." } , { msg _ key . er _ wf _ invalid _ character _ in _ node _ name , " _ s _ ' 'han trobat carcters xml no vlids al node {0} anomenat ' '{1}' '." } , { msg _ key . er _ wf _ dash _ in _ comment , " _ la _ cadena \"--\" no est permesa dins dels comentaris." } , { msg _ key . er _ wf _ lt _ in _ attval , " _ el _ valor d' 'atribut \"{1}\" associat amb un tipus d' 'element \"{0}\" no pot contenir el carcter ' '<' '." } , { msg _ key . er _ wf _ ref _ to _ unparsed _ ent , " _ la _ referncia de l' 'entitat no analitzada \"&{0};\" no est permesa." } , { msg _ key . er _ wf _ ref _ to _ external _ ent , " _ la _ referncia externa de l' 'entitat \"&{0};\" no est permesa en un valor d' 'atribut." } , { msg _ key . er _ ns _ prefix _ cannot _ be _ bound , " _ el _ prefix \"{0}\" no es pot vincular a l' 'espai de noms \"{1}\"." } , { msg _ key . er _ null _ local _ element _ name , " _ el _ nom local de l' 'element \"{0}\" s nul." } , { msg _ key . er _ null _ local _ attr _ name , " _ el _ nom local d' 'atr \"{0}\" s nul." } , { msg _ key . er _ elem _ unbound _ prefix _ in _ entref , " _ el _ text de recanvi del node de l' 'entitat \"{0}\" cont un node d' 'element \"{1}\" amb un prefix de no enllaat \"{2}\"." } , { PRED , " _ el _ text de recanvi del node de l' 'entitat \"{0}\" cont un node d' 'atribut \"{1}\" amb un prefix de no enllaat \"{2}\"." } } ; return contents ; }
Ground truth: msg_key.er_attr_unbound_prefix_in_entref
Syntactic prediction: msg_key.er_attr_unbound_prefix_in_entref
Baseline prediction: msg_key.er_elem_unbound_prefix_in_entref

Context: 
" _ [ {0} ]\n {1}" } , { msg _ key . er _ resource _ could _ not _ load , " _ [ {0} ] {1} \n {2} \t {3}" } , { msg _ key . er _ buffer _ size _ lessthan _ zero , " _ <=0" } , { msg _ key . er _ invalid _ utf _ 16 _ surrogate , " _ utf-16 {0}" } , { msg _ key . er _ oierror , " _ io _ " } , { msg _ key . er _ illegal _ attribute _ position , " _ {0}" } , { msg _ key . er _ namespace _ prefix , " _ {0}" } , { msg _ key . er _ stray _ attribute , " _ {0}" } , { msg _ key . er _ stray _ namespace , " _ {0}={1}" } , { msg _ key . er _ could _ not _ load _ resource , " _ {0} classpath" } , { msg _ key . er _ illegal _ character , " _ {0} {1} " } , { msg _ key . er _ could _ not _ load _ method _ property , " _ {1}{0} classpath" } , { msg _ key . er _ invalid _ port , " _ " } , { msg _ key . er _ port _ when _ host _ null , " _ " } , { msg _ key . er _ host _ address _ not _ wellformed , " _ " } , { msg _ key . er _ scheme _ not _ conformant , " _ " } , { msg _ key . er _ scheme _ from _ null _ string , " _ " } , { msg _ key . er _ path _ contains _ invalid _ escape _ sequence , " _ " } , { msg _ key . er _ path _ invalid _ char , " _ {0}" } , { msg _ key . er _ frag _ invalid _ char , " _ " } , { msg _ key . er _ frag _ when _ path _ null , " _ " } , { msg _ key . er _ frag _ for _ generic _ uri , " _ uri " } , { msg _ key . er _ no _ scheme _ in _ uri , " _ uri _ " } , { msg _ key . er _ cannot _ init _ uri _ empty _ parms , " _ uri" } , { msg _ key . er _ no _ fragment _ string _ in _ path , " _ " } , { msg _ key . er _ no _ query _ string _ in _ path , " _ " } , { msg _ key . er _ no _ port _ if _ no _ host , " _ " } , { msg _ key . er _ no _ userinfo _ if _ no _ host , " _ " } , { msg _ key . er _ xml _ version _ not _ supported , " _ {0} xml 1.0" } , { msg _ key . er _ scheme _ required , " _ " } , { msg _ key . er _ factory _ property _ missing , " _ serializerfactory properties {0}" } , { msg _ key . er _ feature _ not _ found , " _ {0}" } , { msg _ key . er _ feature _ not _ supported , " _ {0}" } , { msg _ key . er _ string _ too _ long , " _ domstring{0}" } , { msg _ key . er _ type _ mismatch _ err , " _ " } , { msg _ key . er _ no _ output _ specified , " _ " } , { msg _ key . er _ unsupported _ encoding , " _ " } , { msg _ key . er _ unable _ to _ serialize _ node , " _ " } , { msg _ key . er _ cdata _ sections _ split , " _ cdata _ ]]>" } , { msg _ key . er _ warning _ wf _ not _ checked , " _ true" } , { msg _ key . er _ wf _ invalid _ character , " _ {0} xml " } , { msg _ key . er _ wf _ invalid _ character _ in _ comment , " _ xml (unicode: 0x''{0})''" } , { msg _ key . er _ wf _ invalid _ character _ in _ pi , " _ xml (unicode: 0x''{0})''" } , { msg _ key . er _ wf _ invalid _ character _ in _ cdata , " _ cdata xml (unicode: 0x''{0})''" } , { msg _ key . er _ wf _ invalid _ character _ in _ text , " _ xml (unicode: 0x''{0})''" } , { msg _ key . er _ wf _ invalid _ character _ in _ node _ name , " _ {1}){0}) xml " } , { msg _ key . er _ wf _ dash _ in _ comment , " _ --" } , { msg _ key . er _ wf _ lt _ in _ attval , " _ {0}{1}<" } , { msg _ key . er _ wf _ ref _ to _ unparsed _ ent , " _ &{0};" } , { PRED , " _ &{0};" } , { msg _ key . er _ ns _ prefix _ cannot _ be _ bound , " _ {0}{1}" } , { msg _ key . er _ null _ local _ element _ name , " _ {0}" } , { msg _ key . er _ null _ local _ attr _ name , " _ {0}" } , { msg _ key . er _ elem _ unbound _ prefix _ in _ entref , " _ {0}{1}{2}" } , { msg _ key . er _ attr _ unbound _ prefix _ in _ entref , " _ {0}{1}{2}" } } ; return contents ; }
Ground truth: msg_key.er_wf_ref_to_external_ent
Syntactic prediction: msg_key.er_wf_ref_to_external_ent
Baseline prediction: msg_key.er_null_local_attr_name

