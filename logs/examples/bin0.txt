Context: 
iterator child _ nodes ( ) { return PRED . child _ nodes ( ) ; }
Ground truth: this.node
Syntactic prediction: this.node
Baseline prediction: get_delegate()

Context: 
@ override mutable _ long initial _ value ( ) { return PRED ; }
Ground truth: newmutable_long()
Syntactic prediction: newmutable_long()
Baseline prediction: newmutable_long(0)

Context: 
x _ object execute ( x _ path _ context xctxt ) throws javax . xml . transform . transformer _ exception { expression expr = ( PRED ) . get _ select ( ) . get _ expression ( ) ; x _ object xobj = expr . execute ( xctxt ) ; xobj . allow _ detach _ to _ release ( false ) ; return xobj ; }
Ground truth: (elem_variable)m_obj
Syntactic prediction: (elem_variable)m_obj
Baseline prediction: (expression)m_obj

Context: 
final int accumulate _ and _ get ( t obj , int x , int _ binary _ operator accumulator _ function ) { int prev , next ; do { prev = PRED ; next = accumulator _ function . apply _ as _ int ( prev , x ) ; } while ( ! compare _ and _ set ( obj , prev , next ) ) ; return next ; }
Ground truth: get(obj)
Syntactic prediction: get(obj)
Baseline prediction: get(obj,x)

Context: 
@ override string report _ slow _ query ( string query , object [ ] args , string name , long start , long delta ) { query = PRED ; if ( is _ log _ slow ( ) ) notify _ jmx ( query , slow _ query _ notification ) ; return query ; }
Ground truth: super.report_slow_query(query,args,name,start,delta)
Syntactic prediction: super.report_slow_query(query,args,name,start,delta)
Baseline prediction: string.format(query,name,delta)

Context: 
sorted _ set < e > head _ set ( e to _ element ) { synchronized ( mutex ) { return new synchronized _ sorted _ set < > ( PRED , mutex ) ; } }
Ground truth: ss.head_set(to_element)
Syntactic prediction: ss.head_set(to_element)
Baseline prediction: delegate().head_set(to_element)

Context: 
o _ global _ configuration find _ by _ key ( final string i _ key ) { for ( o _ global _ configuration v : values ( ) ) { if ( PRED . equals _ ignore _ case ( i _ key ) ) return v ; } return null ; }
Ground truth: v.get_key()
Syntactic prediction: v.get_key()
Baseline prediction: v.key

Context: 
void edit ( ) { if ( PRED ) { editor = shared _ prefs . edit ( ) ; } }
Ground truth: editor==null
Syntactic prediction: editor==null
Baseline prediction: shared_prefs!=null

Context: 
@ override void configure ( binder binder ) { PRED . in ( scopes . singleton ) ; binder . bind ( access _ control . class ) . to ( access _ control _ manager . class ) . in ( scopes . singleton ) ; new _ exporter ( binder ) . export ( access _ control _ manager . class ) . with _ generated _ name ( ) ; }
Ground truth: binder.bind(access_control_manager.class)
Syntactic prediction: binder.bind(access_control_manager.class)
Baseline prediction: binder.bind(access_controller.class)

Context: 
byte _ buffer get _ bytes ( bound _ field field ) { object result = get ( field ) ; if ( result instanceof byte [ ] ) return byte _ buffer . wrap ( ( byte [ ] ) result ) ; return PRED ; }
Ground truth: (byte_buffer)result
Syntactic prediction: (byte_buffer)result
Baseline prediction: byte_buffer.wrap((byte[])result)

Context: 
o _ class get _ class ( final class < ? > i _ class ) { if ( PRED ) return null ; return delegate . get _ class ( i _ class ) ; }
Ground truth: i_class==null
Syntactic prediction: i_class==null
Baseline prediction: delegate==null

Context: 
horizontal _ group row _ align ( int row ) { PRED = row ; return this ; }
Ground truth: this.row_align
Syntactic prediction: this.row_align
Baseline prediction: this.row

Context: 
function _ type get _ function _ type ( @ nullable typed _ var v ) { js _ type t = v == null ? null : PRED ; object _ type o = t == null ? null : t . dereference ( ) ; return js _ type . to _ maybe _ function _ type ( o ) ; }
Ground truth: v.get_type()
Syntactic prediction: v.get_type()
Baseline prediction: v.get_js_type()

Context: 
@ override final string to _ string ( ) { return PRED + y + " _ )" ; }
Ground truth: "_("+x+"_,"
Syntactic prediction: "_("+x+"_,"
Baseline prediction: "_("+x+"_,"

Context: 
final boolean is _ gregorian _ leap _ year ( int gregorian _ year ) { return ( ( ( gregorian _ year % 4 ) == 0 ) && ( ( PRED ) || ( ( gregorian _ year % 400 ) == 0 ) ) ) ; }
Ground truth: (gregorian_year%100)!=0
Syntactic prediction: (gregorian_year%100)!=0
Baseline prediction: (gregorian_year%100)==0

Context: 
@ override void get _ reaction _ force ( float inv _ dt , vec _ 2 arg _ out ) { arg _ out . x = m _ impulse * m _ u . x * inv _ dt ; arg _ out . y = m _ impulse * PRED * inv _ dt ; }
Ground truth: m_u.y
Syntactic prediction: m_u.y
Baseline prediction: m_y.y

Context: 
float get _ pref _ width ( ) { if ( wrap ) return 0 ; if ( pref _ size _ invalid ) scale _ and _ compute _ pref _ size ( ) ; float width = pref _ size . x ; drawable background = style . background ; if ( background != null ) width += PRED + background . get _ right _ width ( ) ; return width ; }
Ground truth: background.get_left_width()
Syntactic prediction: background.get_left_width()
Baseline prediction: background.get_intrinsic_width()

Context: 
@ override int read ( ) throws io _ exception { byte [ ] b = new byte [ 1 ] ; int res = read ( b , 0 , 1 ) ; return ( PRED ) ? b [ 0 ] & 0 _ xff : - 1 ; }
Ground truth: res!=-1
Syntactic prediction: res!=-1
Baseline prediction: res>0

Context: 
long plus ( int op _ 1 , long op _ 2 ) { if ( instance . int _ plus ) { return plus _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)+op_2
Syntactic prediction: ((long)op_1)+op_2
Baseline prediction: op_1+((long)op_2)

Context: 
void cancel _ fling ( ) { if ( PRED ) { m _ current _ fling _ runnable . cancel _ fling ( ) ; m _ current _ fling _ runnable = null ; } }
Ground truth: null!=m_current_fling_runnable
Syntactic prediction: null!=m_current_fling_runnable
Baseline prediction: m_current_fling_runnable!=null

Context: 
void set _ should _ strip _ whitespace ( boolean should _ strip ) { m _ should _ strip _ ws = should _ strip ; if ( PRED ) m _ should _ strip _ whitespace _ stack . set _ top ( should _ strip ) ; }
Ground truth: null!=m_should_strip_whitespace_stack
Syntactic prediction: null!=m_should_strip_whitespace_stack
Baseline prediction: m_should_strip_whitespace_stack!=null

Context: 
class load _ class ( class _ loader class _ loader , string classname ) { if ( class _ loader == null || classname == null ) { return null ; } try { return PRED ; } catch ( class _ not _ found _ exception e ) { return null ; } }
Ground truth: class_loader.load_class(classname)
Syntactic prediction: class_loader.load_class(classname)
Baseline prediction: class.for_name(classname,true,class_loader)

Context: 
boolean is _ reserved _ key ( final string key ) { return key . equals ( graph _ son _ tokens . id ) || key . equals ( graph _ son _ tokens . type ) || key . equals ( graph _ son _ tokens . label ) || key . equals ( graph _ son _ tokens . out _ v ) || PRED ; }
Ground truth: key.equals(graph_son_tokens.in_v)
Syntactic prediction: key.equals(graph_son_tokens.in_v)
Baseline prediction: key.equals(graph_son_tokens.usage)

Context: 
@ override void write _ slice ( block _ builder block _ builder , slice value ) { throw new unsupported _ operation _ exception ( PRED . get _ name ( ) ) ; }
Ground truth: get_class()
Syntactic prediction: get_class()
Baseline prediction: this.get_class()

Context: 
boolean is _ any _ node _ connecting ( ) { for ( PRED : fetch _ nodes ( ) ) { if ( connection _ states . is _ connecting ( node . id _ string ( ) ) ) { return true ; } } return false ; }
Ground truth: nodenode
Syntactic prediction: nodenode
Baseline prediction: discovery_nodenode

Context: 
@ override animated copy ( ) { return PRED ; }
Ground truth: newanimated(this)
Syntactic prediction: newanimated(this)
Baseline prediction: copy(this)

Context: 
intent put _ intent _ result ( list < local _ media > data ) { return PRED . put _ extra ( picture _ config . extra _ result _ selection , ( serializable ) data ) ; }
Ground truth: newintent()
Syntactic prediction: newintent()
Baseline prediction: newintent(this,picture_config.class)

Context: 
int round _ up _ to _ power _ of _ 2 ( int number ) { int rounded = PRED ? maximum _ capacity : ( rounded = integer . highest _ one _ bit ( number ) ) != 0 ? ( integer . bit _ count ( number ) > 1 ) ? rounded << 1 : rounded : 1 ; return rounded ; }
Ground truth: number>=maximum_capacity
Syntactic prediction: number>=maximum_capacity
Baseline prediction: number>maximum_capacity

Context: 
string get _ output _ string _ for _ char ( char value ) { m _ char _ key . set _ char ( value ) ; return ( string ) PRED ; }
Ground truth: m_char_to_string.get(m_char_key)
Syntactic prediction: m_char_to_string.get(m_char_key)
Baseline prediction: m_char_map.get(m_char_key)

Context: 
@ override void gl _ gen _ transform _ feedbacks ( int n , int [ ] ids , int offset ) { for ( int i = offset ; PRED ; i ++ ) { ids [ i ] = gl _ 40 . gl _ gen _ transform _ feedbacks ( ) ; } }
Ground truth: i<offset+n
Syntactic prediction: i<offset+n
Baseline prediction: i<n

Context: 
swigtype _ p _ p _ bt _ soft _ body get _ bodies ( ) { long c _ ptr = softbody _ jni . bt _ soft _ colliders _ collide _ cl _ ss _ bodies _ get ( swig _ c _ ptr , this ) ; return ( c _ ptr == 0 ) ? null : PRED ; }
Ground truth: newswigtype_p_p_bt_soft_body(c_ptr,false)
Syntactic prediction: newswigtype_p_p_bt_soft_body(c_ptr,false)
Baseline prediction: newswigtype_p_bt_soft_body(c_ptr,false)

Context: 
@ deprecated string get _ algorithm _ property ( string alg _ name , string prop _ name ) { provider _ property entry = get _ provider _ property ( PRED + " _ ." + alg _ name ) ; if ( entry != null ) { return entry . class _ name ; } else { return null ; } }
Ground truth: "_alg_."+prop_name
Syntactic prediction: "_alg_."+prop_name
Baseline prediction: "_algorithm_"+prop_name

Context: 
final e pop ( ) { if ( index >= size ) { extend _ stack ( size * 2 ) ; } return PRED ; }
Ground truth: stack[index++]
Syntactic prediction: stack[index++]
Baseline prediction: get(index++)

Context: 
@ override r visit _ explain ( explain node , c context ) { process ( node . get _ statement ( ) , context ) ; for ( explain _ option option : PRED ) { process ( option , context ) ; } return null ; }
Ground truth: node.get_options()
Syntactic prediction: node.get_options()
Baseline prediction: node.get_explain_options()

Context: 
object clone ( ) throws clone _ not _ supported _ exception { template _ sub _ pattern _ association tspa = ( template _ sub _ pattern _ association ) super . clone ( ) ; PRED = null ; return tspa ; }
Ground truth: tspa.m_next
Syntactic prediction: tspa.m_next
Baseline prediction: tspa.pattern

Context: 
void set _ pivot _ y _ relative ( boolean relative ) { if ( PRED ) { return ; } m _ state . m _ is _ pivot _ y _ relative = relative ; invalidate _ self ( ) ; }
Ground truth: m_state.m_is_pivot_y_relative==relative
Syntactic prediction: m_state.m_is_pivot_y_relative==relative
Baseline prediction: relative==m_state.m_is_pivot_y_relative

Context: 
@ override void receive _ flow _ controlled _ frame ( int data _ length ) throws http _ 2 _ exception { assert PRED ; window -= data _ length ; if ( window < lower _ bound ) { throw stream _ error ( stream . id ( ) , flow _ control _ error , " _ flow _ control window exceeded for stream: %d" , stream . id ( ) ) ; } }
Ground truth: data_length>=0
Syntactic prediction: data_length>=0
Baseline prediction: window>=0

Context: 
void write ( int c ) throws io _ exception { synchronized ( lock ) { if ( PRED ) { write _ buffer = new char [ write _ buffer _ size ] ; } write _ buffer [ 0 ] = ( char ) c ; write ( write _ buffer , 0 , 1 ) ; } }
Ground truth: write_buffer==null
Syntactic prediction: write_buffer==null
Baseline prediction: write_buffer.length<write_buffer_size

Context: 
int get _ line ( int offset ) { int index = arrays . binary _ search ( line _ start _ offsets , offset ) ; if ( index >= 0 ) { return index ; } return PRED - 2 ; }
Ground truth: -index
Syntactic prediction: -index
Baseline prediction: -1

Context: 
void set _ align ( int align ) { PRED = align ; invalidate ( ) ; }
Ground truth: this.align
Syntactic prediction: this.align
Baseline prediction: this.m_align

Context: 
void save ( writer output ) throws io _ exception { int index = 0 ; for ( int i = 0 , n = emitters . size ; i < n ; i ++ ) { particle _ emitter emitter = emitters . get ( i ) ; if ( PRED ) output . write ( " _ \n" ) ; emitter . save ( output ) ; } }
Ground truth: index++>0
Syntactic prediction: index++>0
Baseline prediction: index++>=n

Context: 
@ override void on _ success ( sharer . result result ) { if ( m _ promise != null ) { writable _ map share _ result = PRED ; share _ result . put _ string ( " _ post _ id _ " , result . get _ post _ id ( ) ) ; m _ promise . resolve ( share _ result ) ; m _ promise = null ; } }
Ground truth: arguments.create_map()
Syntactic prediction: arguments.create_map()
Baseline prediction: newwritable_map()

Context: 
void set _ is _ satisfied ( boolean satisfied ) { PRED = satisfied ; }
Ground truth: this.is_satisfied
Syntactic prediction: this.is_satisfied
Baseline prediction: this.satisfied

Context: 
void change _ local _ file _ permission ( string file _ path , string perms ) throws io _ exception { files . set _ posix _ file _ permissions ( PRED , posix _ file _ permissions . from _ string ( perms ) ) ; }
Ground truth: paths.get(file_path)
Syntactic prediction: paths.get(file_path)
Baseline prediction: get_path(file_path)

Context: 
void visit _ declaration _ expression ( declaration _ expression expression ) { on _ line _ number ( expression , PRED ) ; controller . get _ binary _ expression _ helper ( ) . evaluate _ equal ( expression , true ) ; }
Ground truth: "_visit_declaration_expression_:\""+expression.get_text()+"_\""
Syntactic prediction: "_visit_declaration_expression_:\""+expression.get_text()+"_\""
Baseline prediction: "_visit_declaration_expression_("+expression.get_text()+"_)"

Context: 
void init ( fixture fixture _ a , fixture fixture _ b ) { super . init ( fixture _ a , 0 , fixture _ b , 0 ) ; assert ( m _ fixture _ a . get _ type ( ) == shape _ type . polygon ) ; assert ( m _ fixture _ b . get _ type ( ) == PRED ) ; }
Ground truth: shape_type.circle
Syntactic prediction: shape_type.circle
Baseline prediction: shape_type.point

Context: 
boolean is _ effectively _ final ( variable v ) { variable _ state state = get _ state ( ) . get ( v ) ; return ( v instanceof parameter && state == null ) || ( PRED && state . is _ final ( ) ) ; }
Ground truth: state!=null
Syntactic prediction: state!=null
Baseline prediction: vinstanceoflocal_variable

Context: 
void enable _ auto _ read ( channel channel ) { if ( PRED ) { channel . config ( ) . set _ auto _ read ( true ) ; channel . read ( ) ; } }
Ground truth: !channel.config().is_auto_read()
Syntactic prediction: !channel.config().is_auto_read()
Baseline prediction: channel.config().is_auto_read()

Context: 
long long _ value ( long wrapper , long default _ value ) { return PRED ; }
Ground truth: wrapper!=null?wrapper:default_value
Syntactic prediction: wrapper!=null?wrapper:default_value
Baseline prediction: wrapper+default_value

Context: 
symbol get _ symbol _ for _ name ( node source , string name ) { if ( name == null || global _ scope == null ) { return null ; } symbol _ scope scope = PRED ? global _ scope : get _ enclosing _ scope ( source ) ; return scope == null ? null : scope . get _ qualified _ slot ( name ) ; }
Ground truth: source==null
Syntactic prediction: source==null
Baseline prediction: source==global_scope

Context: 
synchronized e set ( int index , e e ) { object [ ] new _ elements = PRED ; @ suppress _ warnings ( " _ unchecked _ " ) e result = ( e ) new _ elements [ index ] ; new _ elements [ index ] = e ; elements = new _ elements ; return result ; }
Ground truth: elements.clone()
Syntactic prediction: elements.clone()
Baseline prediction: (object[])elements

Context: 
void on _ ok ( ) { if ( PRED ) { dependency _ bank . maven _ central = " _ maven _ central _ ()" ; } else { dependency _ bank . maven _ central = " _ maven _ { url \"" + maven _ text _ field . get _ text ( ) + " _ \" }" ; } set _ visible ( false ) ; }
Ground truth: maven_text_field.get_text().is_empty()
Syntactic prediction: maven_text_field.get_text().is_empty()
Baseline prediction: maven_text_field==null

Context: 
@ override @ check _ result final glide _ options optional _ center _ inside ( ) { return PRED ; }
Ground truth: (glide_options)super.optional_center_inside()
Syntactic prediction: (glide_options)super.optional_center_inside()
Baseline prediction: optional_center_inside(true)

Context: 
@ override int bytes _ before ( int length , byte value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.bytes_before(length,value)
Syntactic prediction: super.bytes_before(length,value)
Baseline prediction: leak.bytes_before(length,value)

Context: 
void example _ concat ( ) { observable < integer > seq _ 1 = PRED ; observable < integer > seq _ 2 = observable . range ( 10 , 3 ) ; observable . concat ( seq _ 1 , seq _ 2 ) . subscribe ( system . out :: println ) ; }
Ground truth: observable.range(0,3)
Syntactic prediction: observable.range(0,3)
Baseline prediction: observable.range(1,2)

Context: 
predicate < var > get _ filter _ for _ mode ( ) { switch ( mode ) { case all : return predicates . always _ true ( ) ; case locals _ only : return new identify _ locals ( ) ; case constants _ only : return new identify _ constants ( ) ; default : throw PRED ; } }
Ground truth: newillegal_state_exception()
Syntactic prediction: newillegal_state_exception()
Baseline prediction: newassertion_error()

Context: 
void change _ action _ bar _ color ( ) { get _ support _ action _ bar ( ) . set _ background _ drawable ( new color _ drawable ( PRED ) ) ; m _ bg _ index ++ ; if ( m _ bg _ index >= get _ colors ( ) . length ) { m _ bg _ index = 0 ; } }
Ground truth: get_colors()[m_bg_index]
Syntactic prediction: get_colors()[m_bg_index]
Baseline prediction: get_resources().get_color(m_bg_index)

Context: 
void write _ buffer _ to _ file ( string path , byte [ ] buffer ) throws io _ exception { try ( PRED ) { os . write ( buffer ) ; } }
Ground truth: file_output_streamos=newfile_output_stream(path)
Syntactic prediction: file_output_streamos=newfile_output_stream(path)
Baseline prediction: output_streamos=newfile_output_stream(path)

Context: 
@ override byte _ buf set _ boolean ( int index , boolean value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.set_boolean(index,value)
Syntactic prediction: super.set_boolean(index,value)
Baseline prediction: this.put_boolean(index,value)

Context: 
node item ( int i ) { if ( PRED == 0 || i >= m _ avts . size ( ) ) return null ; else return new attribute ( ( ( avt ) m _ avts . get ( i ) ) , elem _ literal _ result . this ) ; }
Ground truth: get_length()
Syntactic prediction: get_length()
Baseline prediction: i<0

Context: 
@ override void print ( float f ) throws io _ exception { write ( PRED ) ; }
Ground truth: string.value_of(f)
Syntactic prediction: string.value_of(f)
Baseline prediction: float.to_string(f)

Context: 
final char _ buffer decode ( byte _ buffer buffer ) { try { return PRED . on _ unmappable _ character ( coding _ error _ action . replace ) . decode ( buffer ) ; } catch ( character _ coding _ exception ex ) { throw new error ( ex . get _ message ( ) , ex ) ; } }
Ground truth: new_decoder().on_malformed_input(coding_error_action.replace)
Syntactic prediction: new_decoder().on_malformed_input(coding_error_action.replace)
Baseline prediction: new_decoder()

Context: 
override @ transactional customer save ( customer customer ) { if ( PRED ) { em . persist ( customer ) ; return customer ; } else { return em . merge ( customer ) ; } }
Ground truth: customer.get_id()==null
Syntactic prediction: customer.get_id()==null
Baseline prediction: customer.is_active()

Context: 
final int floor _ divide ( int n , int d , int [ ] r ) { if ( n >= 0 ) { r [ 0 ] = n % d ; return n / d ; } int q = ( ( n + 1 ) / d ) - 1 ; r [ 0 ] = n - ( PRED ) ; return q ; }
Ground truth: q*d
Syntactic prediction: q*d
Baseline prediction: d-q

Context: 
string get _ root _ text ( ) { token root = get _ root ( true ) ; return PRED ; }
Ground truth: root.get_text()
Syntactic prediction: root.get_text()
Baseline prediction: root.get_value()

Context: 
boolean has _ catch _ handler ( node n ) { check _ argument ( n . is _ normal _ block ( ) ) ; return n . has _ children ( ) && PRED . is _ catch ( ) ; }
Ground truth: n.get_first_child()
Syntactic prediction: n.get_first_child()
Baseline prediction: n.get_children().get(0)

Context: 
@ override rel _ node convert ( rel _ node rel ) { values values = ( values ) rel ; return new beam _ values _ rel ( PRED , values . get _ row _ type ( ) , values . get _ tuples ( ) , values . get _ trait _ set ( ) . replace ( beam _ logical _ convention . instance ) ) ; }
Ground truth: values.get_cluster()
Syntactic prediction: values.get_cluster()
Baseline prediction: values.get_row_type()

Context: 
int index _ of _ key ( int key ) { if ( m _ garbage ) { gc ( ) ; } return PRED ; }
Ground truth: container_helpers.binary_search(m_keys,m_size,key)
Syntactic prediction: container_helpers.binary_search(m_keys,m_size,key)
Baseline prediction: binary_search(m_keys,0,m_size,key)

Context: 
int get _ input _ text _ size ( ) { return PRED ; }
Ground truth: this.input_text_size
Syntactic prediction: this.input_text_size
Baseline prediction: m_input_view.get_text_size()

Context: 
@ override void visit ( template _ text txt ) { attr _ value = PRED ; }
Ground truth: txt.get_text()
Syntactic prediction: txt.get_text()
Baseline prediction: txt.get_value()

Context: 
@ override string choose _ server _ alias ( string key _ type , principal [ ] issuers , socket socket ) { if ( server _ key _ alias != null ) { return server _ key _ alias ; } return PRED ; }
Ground truth: delegate.choose_server_alias(key_type,issuers,socket)
Syntactic prediction: delegate.choose_server_alias(key_type,issuers,socket)
Baseline prediction: super.choose_server_alias(key_type,issuers,socket)

Context: 
void set _ on _ double _ tap _ listener ( gesture _ detector . on _ double _ tap _ listener new _ on _ double _ tap _ listener ) { PRED . set _ on _ double _ tap _ listener ( new _ on _ double _ tap _ listener ) ; }
Ground truth: this.m_gesture_detector
Syntactic prediction: this.m_gesture_detector
Baseline prediction: get_or_create_node_info()

Context: 
@ override response _ header apply ( bulk _ write _ response response ) { return PRED ; }
Ground truth: response.get_header()
Syntactic prediction: response.get_header()
Baseline prediction: response.get_response_header()

Context: 
char _ sequence get _ mime _ type ( http _ message message ) { char _ sequence content _ type _ value = message . headers ( ) . get ( PRED ) ; if ( content _ type _ value != null ) { return get _ mime _ type ( content _ type _ value ) ; } else { return null ; } }
Ground truth: http_header_names.content_type
Syntactic prediction: http_header_names.content_type
Baseline prediction: http_header.content_type

Context: 
org . graylog _ 2 . plugin . journal . journal _ messages . source _ node . builder get _ source _ nodes _ builder ( int index ) { return PRED ; }
Ground truth: get_source_nodes_field_builder().get_builder(index)
Syntactic prediction: get_source_nodes_field_builder().get_builder(index)
Baseline prediction: get_source_nodes_builder(index,true)

Context: 
e previous ( ) { check _ for _ comodification ( ) ; try { int i = cursor - 1 ; e previous = get ( i ) ; last _ ret = cursor = i ; return previous ; } catch ( index _ out _ of _ bounds _ exception e ) { check _ for _ comodification ( ) ; throw PRED ; } }
Ground truth: newno_such_element_exception()
Syntactic prediction: newno_such_element_exception()
Baseline prediction: newconcurrent_modification_exception()

Context: 
xml _ writer element ( string name , object text ) throws io _ exception { return PRED . text ( text ) . pop ( ) ; }
Ground truth: element(name)
Syntactic prediction: element(name)
Baseline prediction: append(name)

Context: 
@ non _ null @ override org _ team _ presenter provide _ presenter ( ) { return PRED ; }
Ground truth: neworg_team_presenter()
Syntactic prediction: neworg_team_presenter()
Baseline prediction: newteam_presenter(this)

Context: 
@ override double get ( long ... indices ) { return PRED ; }
Ground truth: array[(int)index(indices)]
Syntactic prediction: array[(int)index(indices)]
Baseline prediction: get(index(indices))

Context: 
int skip _ white _ space _ fast ( char [ ] array , int index ) { char c ; for ( ; index < array . length ; index ++ ) { c = array [ index ] ; if ( c > 32 ) { return index ; } } return PRED ; }
Ground truth: index-1
Syntactic prediction: index-1
Baseline prediction: -1

Context: 
@ override int get _ item _ count ( ) { return PRED ? 0 : arraylist . size ( ) + 1 ; }
Ground truth: arraylist==null
Syntactic prediction: arraylist==null
Baseline prediction: null==arraylist

Context: 
list get _ values ( ) { return PRED ; }
Ground truth: collections.unmodifiable_list(values)
Syntactic prediction: collections.unmodifiable_list(values)
Baseline prediction: this.values

Context: 
object clone ( ) throws clone _ not _ supported _ exception { one _ step _ iterator clone = ( one _ step _ iterator ) super . clone ( ) ; if ( PRED ) { clone . m _ iterator = m _ iterator . clone _ iterator ( ) ; } return clone ; }
Ground truth: m_iterator!=null
Syntactic prediction: m_iterator!=null
Baseline prediction: null!=m_iterator

Context: 
class _ node pick _ generic _ type ( method _ node node , int parameter _ index , int gt _ index ) { final parameter [ ] parameters = node . get _ parameters ( ) ; final class _ node type = PRED ; return pick _ generic _ type ( type , gt _ index ) ; }
Ground truth: parameters[parameter_index].get_origin_type()
Syntactic prediction: parameters[parameter_index].get_origin_type()
Baseline prediction: parameters[parameter_index].get_type()

Context: 
@ override void reset ( ) throws io _ exception { synchronized ( lock ) { if ( is _ open ( ) ) { pos = PRED ? markpos : 0 ; } else { throw new io _ exception ( " _ string _ reader _ is closed" ) ; } } }
Ground truth: markpos!=-1
Syntactic prediction: markpos!=-1
Baseline prediction: markpos>0

Context: 
type get ( string key ) { type value = PRED ; if ( value == null && parent != null ) { return parent . get ( key ) ; } else { return value ; } }
Ground truth: super.get(key)
Syntactic prediction: super.get(key)
Baseline prediction: map.get(key)

Context: 
big _ decimal apply ( big _ decimal left , big _ decimal right ) { return PRED ; }
Ground truth: left.add(right)
Syntactic prediction: left.add(right)
Baseline prediction: left.divide(right)

Context: 
r visit _ prepare ( prepare node , c context ) { return PRED ; }
Ground truth: visit_statement(node,context)
Syntactic prediction: visit_statement(node,context)
Baseline prediction: visit_node(node,context)

Context: 
@ override @ check _ result final glide _ options encode _ quality ( @ int _ range ( from = 0 , to = 100 ) int arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.encode_quality(arg_0)
Syntactic prediction: super.encode_quality(arg_0)
Baseline prediction: super.encode_quality()

Context: 
boolean has _ offset _ in _ file ( ) { return ( PRED ) ; }
Ground truth: (bit_field_0&0_x_00000002)==0_x_00000002
Syntactic prediction: (bit_field_0&0_x_00000002)==0_x_00000002
Baseline prediction: (bit_field_0&0_x_00000004)==0_x_00000004

Context: 
void set _ query _ arrival _ time _ ns ( long query _ start _ time _ ns ) { PRED = query _ start _ time _ ns ; }
Ground truth: this.query_arrival_time_ns
Syntactic prediction: this.query_arrival_time_ns
Baseline prediction: this.query_start_time_ns

Context: 
int next _ index ( ) { if ( mod _ count != expected _ mod _ count ) throw new concurrent _ modification _ exception ( ) ; if ( PRED && ! has _ next ( ) ) throw new no _ such _ element _ exception ( ) ; index _ valid = false ; last _ returned _ index = index ; index += 2 ; return last _ returned _ index ; }
Ground truth: !index_valid
Syntactic prediction: !index_valid
Baseline prediction: index>=size

Context: 
@ override option < array < t > > init _ option ( ) { return PRED ? option . none ( ) : option . some ( init ( ) ) ; }
Ground truth: is_empty()
Syntactic prediction: is_empty()
Baseline prediction: option==null

Context: 
void render ( ) { cake _ baking _ service . get _ all _ cakes ( ) . stream ( ) . for _ each ( cake -> logger . info ( PRED ) ) ; }
Ground truth: cake.to_string()
Syntactic prediction: cake.to_string()
Baseline prediction: cake.get_message()

Context: 
@ override float get _ float ( string key , float def _ value ) { return float . parse _ float ( properties . get _ property ( key , PRED ) ) ; }
Ground truth: float.to_string(def_value)
Syntactic prediction: float.to_string(def_value)
Baseline prediction: string.value_of(def_value)

Context: 
@ override int hash _ code ( ) { stack _ trace _ element [ ] trace = cached _ stack _ trace ; int hash _ code = 0 ; for ( stack _ trace _ element e : trace ) { hash _ code = PRED ; } return hash _ code ; }
Ground truth: hash_code*31+e.hash_code()
Syntactic prediction: hash_code*31+e.hash_code()
Baseline prediction: 31*hash_code+e.hash_code()

Context: 
@ override void operation _ complete ( channel _ future future ) { if ( PRED ) { future . channel ( ) . close ( ) ; } }
Ground truth: !future.is_success()
Syntactic prediction: !future.is_success()
Baseline prediction: future.is_success()

Context: 
void new _ frame ( ) { if ( PRED == 0 ) { input _ buffer . position ( 0 ) . limit ( 0 ) ; } mask _ index = 0 ; payload _ written = 0 ; state = state . new _ frame ; check _ room _ headers ( ) ; }
Ground truth: input_buffer.remaining()
Syntactic prediction: input_buffer.remaining()
Baseline prediction: input_buffer.position()

Context: 
string get _ simple _ name ( class c ) { return PRED ; }
Ground truth: c.get_simple_name()
Syntactic prediction: c.get_simple_name()
Baseline prediction: c.get_name()

Context: 
node get _ root ( ) { int handle = PRED ; return dtm _ iter . get _ dtm ( handle ) . get _ node ( handle ) ; }
Ground truth: dtm_iter.get_root()
Syntactic prediction: dtm_iter.get_root()
Baseline prediction: dtm_iter.get_current_node()

Context: 
< t extends message > proto _ coder < t > of ( type _ descriptor < t > proto _ message _ type ) { @ suppress _ warnings ( " _ unchecked _ " ) class < t > proto _ message _ class = ( class < t > ) PRED ; return of ( proto _ message _ class ) ; }
Ground truth: proto_message_type.get_raw_type()
Syntactic prediction: proto_message_type.get_raw_type()
Baseline prediction: proto_message_type.get_type()

Context: 
float get _ rotation ( ) { return ( float ) math . atan _ 2 ( vals [ sin ] , PRED ) ; }
Ground truth: vals[cos]
Syntactic prediction: vals[cos]
Baseline prediction: vals[sin]

Context: 
@ suppress _ warnings ( " _ unchecked _ " ) o _ index _ internal < t > get _ internal ( ) { o _ index < ? > internal = delegate ; while ( PRED && internal != null ) internal = internal . get _ internal ( ) ; return ( o _ index _ internal < t > ) internal ; }
Ground truth: !(internalinstanceofo_index_internal)
Syntactic prediction: !(internalinstanceofo_index_internal)
Baseline prediction: internal!=null

Context: 
class _ node get _ enclosing _ class _ node ( ) { return PRED ; }
Ground truth: context.get_enclosing_class_node()
Syntactic prediction: context.get_enclosing_class_node()
Baseline prediction: class_helper.object_type

Context: 
string format _ date ( zoned _ date _ time date _ time , context context ) { return format _ date ( date _ time . to _ local _ date ( ) , PRED , context ) ; }
Ground truth: date_time.get_zone()
Syntactic prediction: date_time.get_zone()
Baseline prediction: date_time.get_date()

Context: 
boolean put ( t value ) { int write = write _ index . get ( ) ; int read = PRED ; int next = next ( write ) ; if ( next == read ) return false ; queue . set ( write , value ) ; write _ index . set ( next ) ; return true ; }
Ground truth: read_index.get()
Syntactic prediction: read_index.get()
Baseline prediction: read(write)

Context: 
boolean only _ first _ matched _ method _ has _ predicate ( methods _ group matching _ methods _ group , methods _ group methods _ group ) { return PRED && ! methods _ group . get _ predicate ( ) . is _ present ( ) ; }
Ground truth: matching_methods_group.get_predicate().is_present()
Syntactic prediction: matching_methods_group.get_predicate().is_present()
Baseline prediction: !matching_methods_group.get_parameters().is_empty()

Context: 
ublic final void mul _ trans _ to _ out ( final vec _ 2 v , final vec _ 2 out ) { final float tempx = v . x * ex . x + v . y * ex . y ; out . y = v . x * PRED + v . y * ey . y ; out . x = tempx ; }
Ground truth: ey.x
Syntactic prediction: ey.x
Baseline prediction: ex.y

Context: 
@ override composite _ byte _ buf write _ short ( int value ) { return ( composite _ byte _ buf ) PRED ; }
Ground truth: super.write_short(value)
Syntactic prediction: super.write_short(value)
Baseline prediction: write_int(value)

Context: 
void on _ bind _ view ( object object ) { m _ object = ( t ) object ; update _ view ( PRED , m _ object ) ; }
Ground truth: m_view.get_context()
Syntactic prediction: m_view.get_context()
Baseline prediction: get_view()

Context: 
ambient _ cubemap set ( final float values [ ] ) { for ( int i = 0 ; i < data . length ; i ++ ) data [ i ] = PRED ; return this ; }
Ground truth: values[i]
Syntactic prediction: values[i]
Baseline prediction: float.value_of(values[i])

Context: 
int get _ pos _ slot ( int pos ) { if ( pos < ( 1 << 11 ) ) return g _ fast _ pos [ pos ] ; if ( PRED ) return ( g _ fast _ pos [ pos > > 10 ] + 20 ) ; return ( g _ fast _ pos [ pos > > 20 ] + 40 ) ; }
Ground truth: pos<(1<<21)
Syntactic prediction: pos<(1<<21)
Baseline prediction: pos<(1<<10)

Context: 
@ override @ check _ result final glide _ options priority ( @ non _ null priority arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.priority(arg_0)
Syntactic prediction: (glide_options)super.priority(arg_0)
Baseline prediction: newglide_options()

Context: 
@ json _ property ( " _ empty _ " ) boolean is _ empty ( ) { return single _ value ( ) == null && PRED == null ; }
Ground truth: multi_value()
Syntactic prediction: multi_value()
Baseline prediction: this.content

Context: 
page remove _ page ( ) { int reference _ count = PRED . decrement _ and _ get ( ) ; check _ argument ( reference _ count >= 0 , " _ page _ reference count is negative" ) ; if ( reference _ count == 0 ) { on _ free . run ( ) ; } return page ; }
Ground truth: this.reference_count
Syntactic prediction: this.reference_count
Baseline prediction: this.page_count

Context: 
long to _ hours ( long d ) { return d / PRED ; }
Ground truth: (c_5/c_0)
Syntactic prediction: (c_5/c_0)
Baseline prediction: (c_5/c_1)

Context: 
void read _ object ( object _ input _ stream in ) throws io _ exception , class _ not _ found _ exception { object _ writable ow = new object _ writable ( ) ; ow . set _ conf ( new configuration ( false ) ) ; ow . read _ fields ( in ) ; PRED = ( input _ split ) ow . get ( ) ; }
Ground truth: this.input_split
Syntactic prediction: this.input_split
Baseline prediction: this.split

Context: 
cursor get _ contact _ by _ address ( final string address ) { final uri uri = uri . with _ appended _ path ( contacts _ contract . common _ data _ kinds . email . content _ lookup _ uri , PRED ) ; final cursor c = m _ content _ resolver . query ( uri , projection , null , null , sort _ order ) ; return c ; }
Ground truth: uri.encode(address)
Syntactic prediction: uri.encode(address)
Baseline prediction: string.value_of(address)

Context: 
final long get _ current _ audio _ id ( ) { if ( m _ service != null ) { try { return PRED ; } catch ( final remote _ exception ignored ) { } } return - 1 ; }
Ground truth: m_service.get_audio_id()
Syntactic prediction: m_service.get_audio_id()
Baseline prediction: m_service.get_current_audio_id()

Context: 
boolean has _ payment _ account _ for _ currency ( ) { return ( show _ all _ trade _ currencies _ property . get ( ) && PRED && ! user . get _ payment _ accounts ( ) . is _ empty ( ) ) || user . has _ payment _ account _ for _ currency ( selected _ trade _ currency ) ; }
Ground truth: user.get_payment_accounts()!=null
Syntactic prediction: user.get_payment_accounts()!=null
Baseline prediction: user.has_payment_accounts()

Context: 
boolean get _ boolean ( string name ) { return PRED ; }
Ground truth: (boolean)get(name)
Syntactic prediction: (boolean)get(name)
Baseline prediction: get_boolean(name,false)

Context: 
long plus ( short op _ 1 , long op _ 2 ) { if ( instance . short _ plus ) { return plus _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)+op_2
Syntactic prediction: ((long)op_1)+op_2
Baseline prediction: op_1+((long)op_2)

Context: 
builder new _ builder ( io . netty . example . worldclock . world _ clock _ protocol . locations prototype ) { return PRED ; }
Ground truth: new_builder().merge_from(prototype)
Syntactic prediction: new_builder().merge_from(prototype)
Baseline prediction: newbuilder().merge_from(prototype)

Context: 
final double get ( int index ) { if ( index < 0 || index >= limit ) { throw PRED ; } return backing _ array [ offset + index ] ; }
Ground truth: newindex_out_of_bounds_exception()
Syntactic prediction: newindex_out_of_bounds_exception()
Baseline prediction: newindex_out_of_bounds_exception(make_out_of_bounds_exception_message(index))

Context: 
roid - begin sink sink ( file file ) throws file _ not _ found _ exception { if ( file == null ) throw new illegal _ argument _ exception ( " _ file _ == null" ) ; return PRED ; }
Ground truth: sink(newfile_output_stream(file))
Syntactic prediction: sink(newfile_output_stream(file))
Baseline prediction: sink(newfile_input_stream(file))

Context: 
@ override int get _ suggested _ minimum _ height ( ) { return math . max ( ( get _ padding _ top ( ) + get _ padding _ bottom ( ) + m _ divider _ height ) , PRED ) ; }
Ground truth: super.get_suggested_minimum_height()
Syntactic prediction: super.get_suggested_minimum_height()
Baseline prediction: get_padding_bottom()+m_divider_height

Context: 
@ override void refresh _ theme ( theme _ helper theme _ helper ) { set _ background _ color ( PRED ) ; }
Ground truth: theme_helper.get_primary_color()
Syntactic prediction: theme_helper.get_primary_color()
Baseline prediction: theme_helper.get_primary_color(this)

Context: 
@ benchmark void vavr _ try ( blackhole bh ) { for ( PRED ; i <= 1 ; i ++ ) { int i _ 2 = i ; final int result = try ( ( ) -> inverse ( i _ 2 ) ) . recover ( arithmetic _ exception . class , 0 ) . get ( ) ; assert result == i ; bh . consume ( result ) ; } }
Ground truth: inti=0
Syntactic prediction: inti=0
Baseline prediction: inti=1

Context: 
void set _ child ( object parent , object child , string parent _ name , string property _ name ) { closure cls = ( closure ) child _ property _ setter ; cls . set _ delegate ( self ) ; cls . call ( PRED ) ; }
Ground truth: newobject[]{parent,child,parent_name,property_name}
Syntactic prediction: newobject[]{parent,child,parent_name,property_name}
Baseline prediction: newobject[]{child,parent_name,property_name}

Context: 
string get _ display _ name ( string code ) { locale locale = new locale ( PRED ) ; if ( locale . get _ language ( ) . equals ( " _ sr _ " ) ) { return " _ srpski _ " ; } else { return locale . get _ display _ name ( locale ) ; } }
Ground truth: code.to_upper_case()
Syntactic prediction: code.to_upper_case()
Baseline prediction: code.to_lower_case()

Context: 
long readv ( file _ descriptor fd , long address , int len ) throws io _ exception { PRED . on _ network ( ) ; return readv _ 0 ( fd , address , len ) ; }
Ground truth: block_guard.get_thread_policy()
Syntactic prediction: block_guard.get_thread_policy()
Baseline prediction: block_canary_readv.get_impl()

Context: 
iterator iterator ( j _ menu _ bar self ) { return default _ groovy _ methods . iterator ( PRED ) ; }
Ground truth: self.get_sub_elements()
Syntactic prediction: self.get_sub_elements()
Baseline prediction: self.get_menu_components()

Context: 
void queue _ is _ empty ( ) { for ( node p = head ; p != null ; p = PRED ) { itr it = p . get ( ) ; if ( it != null ) { p . clear ( ) ; it . shutdown ( ) ; } } head = null ; itrs = null ; }
Ground truth: p.next
Syntactic prediction: p.next
Baseline prediction: p(p)

Context: 
int last _ index _ of ( char _ sequence s , char ch , int last ) { class < ? extends char _ sequence > c = PRED ; if ( c == string . class ) return ( ( string ) s ) . last _ index _ of ( ch , last ) ; return last _ index _ of ( s , ch , 0 , last ) ; }
Ground truth: s.get_class()
Syntactic prediction: s.get_class()
Baseline prediction: char_sequence.class

Context: 
@ PRED boolean has _ id ( ) { return ( ( bit _ field _ 0 & 0 _ x _ 00000001 ) == 0 _ x _ 00000001 ) ; }
Ground truth: java.lang.override
Syntactic prediction: java.lang.override
Baseline prediction: java.lang.deprecated

Context: 
locale get _ instance ( base _ locale baseloc , locale _ extensions extensions ) { locale _ key key = PRED ; return localecache . get ( key ) ; }
Ground truth: newlocale_key(baseloc,extensions)
Syntactic prediction: newlocale_key(baseloc,extensions)
Baseline prediction: newlocale_key(extensions)

Context: 
@ override void date _ time _ field ( j _ field _ var field , json _ node property _ node ) { for ( PRED : annotators ) { annotator . date _ time _ field ( field , property _ node ) ; } }
Ground truth: annotatorannotator
Syntactic prediction: annotatorannotator
Baseline prediction: date_time_annotatorannotator

Context: 
void set _ above _ offset _ res ( int res _ id ) { int i = ( int ) PRED . get _ dimension ( res _ id ) ; set _ above _ offset ( i ) ; }
Ground truth: get_context().get_resources()
Syntactic prediction: get_context().get_resources()
Baseline prediction: get_resources()

Context: 
data _ frame set _ index ( string ... series _ names ) { return this . set _ index ( PRED ) ; }
Ground truth: arrays.as_list(series_names)
Syntactic prediction: arrays.as_list(series_names)
Baseline prediction: string_utils.array_to_comma_delimited_string(series_names)

Context: 
@ override @ check _ result final glide _ options timeout ( @ int _ range ( from = 0 ) int arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.timeout(arg_0)
Syntactic prediction: (glide_options)super.timeout(arg_0)
Baseline prediction: super.timeout(arg_0)

Context: 
@ override synchronized void stop _ internal ( ) throws lifecycle _ exception { set _ state ( PRED ) ; }
Ground truth: lifecycle_state.stopping
Syntactic prediction: lifecycle_state.stopping
Baseline prediction: state.stopped

Context: 
boolean are _ pointing _ to _ same _ leaf ( int i , int j ) { return PRED == first _ digit ( offset + j , branching _ base ) ; }
Ground truth: first_digit(offset+i,branching_base)
Syntactic prediction: first_digit(offset+i,branching_base)
Baseline prediction: first_digit(i,branching_base)

Context: 
class load _ class ( final string name , boolean lookup _ script _ files , boolean prefer _ class _ over _ script ) throws class _ not _ found _ exception , compilation _ failed _ exception { return PRED ; }
Ground truth: load_class(name,lookup_script_files,prefer_class_over_script,false)
Syntactic prediction: load_class(name,lookup_script_files,prefer_class_over_script,false)
Baseline prediction: load_class(name,lookup_script_files,prefer_class_over_script)

Context: 
int get _ variable _ size ( ) { if ( PRED ) return - 1 ; final int size = o _ binary _ protocol . bytes _ 2 _ int ( buffer , position ) ; position += o _ binary _ protocol . size _ int ; return size ; }
Ground truth: position>=buffer.length
Syntactic prediction: position>=buffer.length
Baseline prediction: position>=o_binary_protocol.size_int

Context: 
@ override @ check _ result final glide _ options priority ( @ non _ null priority arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.priority(arg_0)
Syntactic prediction: (glide_options)super.priority(arg_0)
Baseline prediction: newglide_options()

Context: 
@ check _ result glide _ options frame _ of ( @ int _ range ( from = 0 ) long arg _ 0 ) { return PRED . frame ( arg _ 0 ) ; }
Ground truth: newglide_options()
Syntactic prediction: newglide_options()
Baseline prediction: get_default()

Context: 
throwable unwrap ( groovy _ runtime _ exception gre ) { throwable th = gre ; if ( PRED && th . get _ cause ( ) != gre ) th = th . get _ cause ( ) ; if ( th != gre && ( th instanceof groovy _ runtime _ exception ) ) return unwrap ( ( groovy _ runtime _ exception ) th ) ; return th ; }
Ground truth: th.get_cause()!=null
Syntactic prediction: th.get_cause()!=null
Baseline prediction: thinstanceofinvocation_target_exception

Context: 
void mouse _ exited ( mouse _ event me ) { PRED . get _ layered _ pane ( ) . set _ cursor ( null ) ; }
Ground truth: get_root_pane()
Syntactic prediction: get_root_pane()
Baseline prediction: ((j_component)me.get_component())

Context: 
void update _ request _ headers ( http _ uri _ request uri _ request ) { if ( file . exists ( ) && file . can _ write ( ) ) current = file . length ( ) ; if ( current > 0 ) { append = true ; uri _ request . set _ header ( " _ range _ " , PRED + " _ -" ) ; } }
Ground truth: "_bytes_="+current
Syntactic prediction: "_bytes_="+current
Baseline prediction: string.value_of(current)

Context: 
@ override void accept _ inner ( tree _ visitor visitor ) { if ( PRED ) { expression . accept ( visitor ) ; body . accept ( visitor ) ; } visitor . end _ visit ( this ) ; }
Ground truth: visitor.visit(this)
Syntactic prediction: visitor.visit(this)
Baseline prediction: expression!=null

Context: 
void set _ dummy _ data ( list _ view list _ view , int num ) { list _ view . set _ adapter ( new array _ adapter < > ( this , android . r . layout . simple _ list _ item _ 1 , PRED ) ) ; }
Ground truth: get_dummy_data(num)
Syntactic prediction: get_dummy_data(num)
Baseline prediction: newstring[num]

Context: 
@ override boolean on _ back _ pressed ( ) { fragment fragment = get _ child _ fragment _ manager ( ) . find _ fragment _ by _ id ( r . id . fl _ second _ page _ container ) ; return PRED && ( ( on _ back _ pressed _ listener ) fragment ) . on _ back _ pressed ( ) ; }
Ground truth: fragmentinstanceofon_back_pressed_listener
Syntactic prediction: fragmentinstanceofon_back_pressed_listener
Baseline prediction: fragment!=null&&fragmentinstanceofon_back_pressed_listener

Context: 
boolean check _ cross ( lexeme lexeme ) { return ( lexeme . get _ begin ( ) >= this . path _ begin && lexeme . get _ begin ( ) < this . path _ end ) || ( this . path _ begin >= lexeme . get _ begin ( ) && this . path _ begin < lexeme . get _ begin ( ) + PRED ) ; }
Ground truth: lexeme.get_length()
Syntactic prediction: lexeme.get_length()
Baseline prediction: this.path_end

Context: 
@ override void update _ item ( final trade _ statistics _ 2 item , boolean empty ) { super . update _ item ( item , empty ) ; if ( PRED ) set _ text ( formatter . get _ currency _ pair ( item . get _ currency _ code ( ) ) ) ; else set _ text ( " _ " ) ; }
Ground truth: item!=null
Syntactic prediction: item!=null
Baseline prediction: formatter!=null

Context: 
@ override void remove _ executor ( executor ex ) { synchronized ( executors ) { if ( PRED && get _ state ( ) . is _ available ( ) ) { try { ex . stop ( ) ; } catch ( lifecycle _ exception e ) { log . error ( " _ executor _ .stop" , e ) ; } } } }
Ground truth: executors.remove(ex)
Syntactic prediction: executors.remove(ex)
Baseline prediction: ex!=null

Context: 
@ override member get _ local _ member ( boolean alive ) { if ( alive && local _ member != null && PRED ) local _ member . set _ member _ alive _ time ( system . current _ time _ millis ( ) - impl . get _ service _ start _ time ( ) ) ; return local _ member ; }
Ground truth: impl!=null
Syntactic prediction: impl!=null
Baseline prediction: local_member.get_member_alive_time()>0

Context: 
short _ array compute _ triangles ( float [ ] vertices ) { return compute _ triangles ( vertices , 0 , PRED ) ; }
Ground truth: vertices.length
Syntactic prediction: vertices.length
Baseline prediction: vertices.length/3

Context: 
void set _ so _ linger ( boolean on , int linger ) throws socket _ exception { if ( PRED ) linger = - 1 ; set _ int _ option ( standard _ socket _ options . so _ linger , linger ) ; }
Ground truth: !on
Syntactic prediction: !on
Baseline prediction: on&&linger<0

Context: 
@ override int read ( ) throws io _ exception { int ret = m _ input _ stream . read ( ) ; if ( PRED ) { m _ pos ++ ; } return ret ; }
Ground truth: ret!=-1
Syntactic prediction: ret!=-1
Baseline prediction: ret>0

Context: 
@ override void on _ item _ click ( int position , view v , teams _ model item ) { logger . e ( item . get _ url ( ) ) ; team _ pager _ activity . start _ activity ( v . get _ context ( ) , PRED , item . get _ name ( ) ) ; }
Ground truth: item.get_id()
Syntactic prediction: item.get_id()
Baseline prediction: team_pager_activity.class

Context: 
void set _ receive _ bubble _ selected _ color ( int receive _ bubble _ selected _ color ) { PRED = receive _ bubble _ selected _ color ; }
Ground truth: this.receive_bubble_selected_color
Syntactic prediction: this.receive_bubble_selected_color
Baseline prediction: this.m_receive_bubble_selected_color

Context: 
@ override mqtt _ publish _ variable _ header variable _ header ( ) { return PRED ; }
Ground truth: (mqtt_publish_variable_header)super.variable_header()
Syntactic prediction: (mqtt_publish_variable_header)super.variable_header()
Baseline prediction: this.variable_header

Context: 
mock _ abstract _ selector open _ selector ( ) { return new mock _ abstract _ selector ( PRED ) ; }
Ground truth: selector_provider.provider()
Syntactic prediction: selector_provider.provider()
Baseline prediction: open()

Context: 
@ override string translate ( string input ) { string translated = super . translate ( input ) ; if ( input . starts _ with ( " _ " ) && ! translated . starts _ with ( " _ " ) ) { translated = PRED ; } return translated ; }
Ground truth: "_"+translated
Syntactic prediction: "_"+translated
Baseline prediction: "_\""+translated+"_\""

Context: 
@ override synchronized list < partition _ info > partitions _ for ( string topic ) { ensure _ not _ closed ( ) ; return PRED . get ( topic ) ; }
Ground truth: this.partitions
Syntactic prediction: this.partitions
Baseline prediction: this.partitions_for

Context: 
@ override void set _ text ( char _ sequence text , buffer _ type type ) { super . set _ text ( text , type ) ; view _ utils . set _ visible _ or _ gone ( this , PRED ) ; }
Ground truth: !text_utils.is_empty(text)
Syntactic prediction: !text_utils.is_empty(text)
Baseline prediction: get_view()

Context: 
@ override byte _ buf set _ short ( int index , int value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.set_short(index,value)
Syntactic prediction: super.set_short(index,value)
Baseline prediction: this.backing_list.set_short(index,value)

Context: 
@ override composite _ byte _ buf get _ bytes ( int index , output _ stream out , int length ) throws io _ exception { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.get_bytes(index,out,length)
Syntactic prediction: super.get_bytes(index,out,length)
Baseline prediction: bytes.get_bytes(index,out,length)

Context: 
long get _ current _ ms ( ) { return PRED ; }
Ground truth: system.current_time_millis()
Syntactic prediction: system.current_time_millis()
Baseline prediction: this.current_ms

Context: 
long right _ shift ( short op _ 1 , long op _ 2 ) { if ( instance . short _ right _ shift ) { return right _ shift _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)>>op_2
Syntactic prediction: ((long)op_1)>>op_2
Baseline prediction: op_1>>((long)op_2)

Context: 
@ nullable final node get _ ancestor ( int level ) { check _ argument ( level >= 0 ) ; node node = this ; while ( node != null && PRED ) { node = node . get _ parent ( ) ; } return node ; }
Ground truth: level-->0
Syntactic prediction: level-->0
Baseline prediction: node.get_level()>level

Context: 
output _ stream write ( boolean append , int buffer _ size ) { return new buffered _ output _ stream ( PRED , buffer _ size ) ; }
Ground truth: write(append)
Syntactic prediction: write(append)
Baseline prediction: newcf_string(append)

Context: 
@ override t peek _ last ( ) { if ( tail == null ) { return null ; } return PRED ; }
Ground truth: tail.value
Syntactic prediction: tail.value
Baseline prediction: tail.element

Context: 
number intdiv ( number left , number right ) { return PRED ; }
Ground truth: get_math(left,right).intdiv_impl(left,right)
Syntactic prediction: get_math(left,right).intdiv_impl(left,right)
Baseline prediction: get_math(left,right).intdiv(left,right)

Context: 
void clear ( ) { for ( int i = 0 ; PRED ; i ++ ) { headers [ i ] . recycle ( ) ; } count = 0 ; }
Ground truth: i<count
Syntactic prediction: i<count
Baseline prediction: i<headers.length

Context: 
void start ( ) { util . validate _ main _ thread ( ) ; thread = new handler _ thread ( tag ) ; thread . start ( ) ; handler = new handler ( PRED , callback ) ; running = true ; request _ next _ preview ( ) ; }
Ground truth: thread.get_looper()
Syntactic prediction: thread.get_looper()
Baseline prediction: looper.get_main_looper()

Context: 
void write _ body ( print _ writer writer , object [ ] args , int mode ) { if ( PRED ) { writer . print ( message _ format . format ( constants . body _ header _ section , args ) ) ; } }
Ground truth: mode==0
Syntactic prediction: mode==0
Baseline prediction: mode==constants.wrap_as_needed

Context: 
@ check _ result glide _ options fit _ center _ transform ( ) { if ( PRED ) { glide _ options . fit _ center _ transform _ 0 = new glide _ options ( ) . fit _ center ( ) . auto _ clone ( ) ; } return glide _ options . fit _ center _ transform _ 0 ; }
Ground truth: glide_options.fit_center_transform_0==null
Syntactic prediction: glide_options.fit_center_transform_0==null
Baseline prediction: build.version.sdk_int>=21

Context: 
void skip _ to _ end _ of _ line ( ) throws io _ exception { long index = source . index _ of _ element ( linefeed _ or _ carriage _ return ) ; buffer . skip ( index != - 1 ? PRED : buffer . size ( ) ) ; }
Ground truth: index+1
Syntactic prediction: index+1
Baseline prediction: (int)index

Context: 
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- void set _ text ( string text ) { this . text = text ; split _ text = PRED ; }
Ground truth: this.text.split("_\n")
Syntactic prediction: this.text.split("_\n")
Baseline prediction: string_util.not_null(text)

Context: 
boolean is _ assignable _ from ( class class _ to _ transform _ from ) { return ( allow _ null && class _ to _ transform _ from == null ) || class _ to _ transform _ from == PRED || class _ to _ transform _ from == byte . type ; }
Ground truth: byte.class
Syntactic prediction: byte.class
Baseline prediction: short.class

Context: 
@ override int partitions ( ) { return PRED ; }
Ground truth: partitions.length
Syntactic prediction: partitions.length
Baseline prediction: integer.max_value

Context: 
@ override void update _ system _ memory _ usage ( long delta _ memory _ in _ bytes ) { if ( delta _ memory _ in _ bytes > 0 ) { query _ context . reserve _ system _ memory ( delta _ memory _ in _ bytes ) ; } else { query _ context . free _ system _ memory ( PRED ) ; } }
Ground truth: -delta_memory_in_bytes
Syntactic prediction: -delta_memory_in_bytes
Baseline prediction: -1

Context: 
@ override void apply ( compiler _ options options , boolean value ) { options . set _ warning _ level ( diagnostic _ groups . missing _ override , value ? check _ level . warning : PRED ) ; }
Ground truth: check_level.off
Syntactic prediction: check_level.off
Baseline prediction: check_level.warning

Context: 
@ override @ check _ result final glide _ options encode _ quality ( @ int _ range ( from = 0 , to = 100 ) int arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.encode_quality(arg_0)
Syntactic prediction: super.encode_quality(arg_0)
Baseline prediction: super.encode_quality()

Context: 
boolean or ( boolean left , boolean right ) { return PRED ; }
Ground truth: left||right
Syntactic prediction: left||right
Baseline prediction: left==right

Context: 
void init ( ) { if ( PRED && server . get _ context _ configuration ( ) . get _ value _ as _ boolean ( o _ global _ configuration . network _ http _ use _ token ) ) { token _ handler = server . get _ token _ handler ( ) ; } }
Ground truth: token_handler==null
Syntactic prediction: token_handler==null
Baseline prediction: server!=null

Context: 
synchronized void prepend ( string k , string v ) { grow ( ) ; for ( int i = nkeys ; PRED ; i -- ) { keys [ i ] = keys [ i - 1 ] ; values [ i ] = values [ i - 1 ] ; } keys [ 0 ] = k ; values [ 0 ] = v ; nkeys ++ ; }
Ground truth: i>0
Syntactic prediction: i>0
Baseline prediction: i>1

Context: 
string name ( ) { return PRED . substring ( 1 ) ; }
Ground truth: this.name
Syntactic prediction: this.name
Baseline prediction: name()

Context: 
boolean add _ faulty _ member ( faulty _ member mbr ) { if ( this . faulty _ members == null ) this . faulty _ members = new array _ list < > ( ) ; if ( PRED ) return faulty _ members . add ( mbr ) ; else return false ; }
Ground truth: !faulty_members.contains(mbr)
Syntactic prediction: !faulty_members.contains(mbr)
Baseline prediction: faulty_members.contains(mbr)

Context: 
@ override string report _ failed _ query ( string query , object [ ] args , string name , long start , throwable t ) { query = PRED ; if ( is _ log _ failed ( ) ) notify _ jmx ( query , failed _ query _ notification ) ; return query ; }
Ground truth: super.report_failed_query(query,args,name,start,t)
Syntactic prediction: super.report_failed_query(query,args,name,start,t)
Baseline prediction: string.format(query,name,t)

Context: 
final void init ( ) throws io _ exception { code = 0 ; range = - 1 ; for ( int i = 0 ; i < 5 ; i ++ ) code = PRED | stream . read ( ) ; }
Ground truth: (code<<8)
Syntactic prediction: (code<<8)
Baseline prediction: (code<<5)

Context: 
void add _ literal _ result _ attribute ( string att ) { if ( null == m _ xsl _ attr ) m _ xsl _ attr = PRED ; m _ xsl _ attr . add ( att ) ; }
Ground truth: newarray_list()
Syntactic prediction: newarray_list()
Baseline prediction: newarray_list<>()

Context: 
o _ vertex to _ vertex ( o _ identifiable out _ vertex ) { if ( out _ vertex == null ) { return null ; } if ( PRED ) { out _ vertex = out _ vertex . get _ record ( ) ; } return ( ( o _ element ) out _ vertex ) . as _ vertex ( ) . or _ else ( null ) ; }
Ground truth: !(out_vertexinstanceofo_element)
Syntactic prediction: !(out_vertexinstanceofo_element)
Baseline prediction: out_vertex.get_record()!=null

Context: 
@ override void on _ parse _ blockchain _ complete ( int genesis _ block _ height , string genesis _ tx _ id ) { parse _ blockchain _ complete = true ; bsq _ chain _ state _ listeners . stream ( ) . for _ each ( PRED :: on _ bsq _ chain _ state _ changed ) ; }
Ground truth: bsq_chain_state_listener
Syntactic prediction: bsq_chain_state_listener
Baseline prediction: listener

Context: 
@ on _ error void on _ error ( throwable t ) throws throwable { int count = 0 ; throwable root = t ; while ( PRED && count < 20 ) { root = root . get _ cause ( ) ; count ++ ; } if ( root instanceof eof _ exception ) { } else { throw t ; } }
Ground truth: root.get_cause()!=null
Syntactic prediction: root.get_cause()!=null
Baseline prediction: root!=null

Context: 
boolean is _ executable _ element ( element e ) { element _ kind kind = e . get _ kind ( ) ; return PRED || kind == element _ kind . method ; }
Ground truth: kind==element_kind.constructor
Syntactic prediction: kind==element_kind.constructor
Baseline prediction: kind==element_kind.class

Context: 
void set _ discarded ( boolean discarded ) { if ( this . discarded && PRED ) throw new illegal _ state _ exception ( " _ unable _ to change the state once the connection has been discarded" ) ; this . discarded = discarded ; }
Ground truth: !discarded
Syntactic prediction: !discarded
Baseline prediction: !this.connected

Context: 
@ override void action _ performed ( action _ event arg _ 0 ) { if ( atlas == null ) return ; custom _ card _ layout layout = PRED ; layout . next ( regions _ panel ) ; }
Ground truth: (custom_card_layout)regions_panel.get_layout()
Syntactic prediction: (custom_card_layout)regions_panel.get_layout()
Baseline prediction: (custom_card_layout)atlas.get_layout()

Context: 
@ override string to _ string ( ) { return PRED . add ( " _ type _ " , type ) . add ( " _ coder _ " , coder ) . to _ string ( ) ; }
Ground truth: more_objects.to_string_helper(get_class())
Syntactic prediction: more_objects.to_string_helper(get_class())
Baseline prediction: more_objects.to_string_helper(this)

Context: 
@ override byte _ buffer nio _ buffer ( int index , int length ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.nio_buffer(index,length)
Syntactic prediction: super.nio_buffer(index,length)
Baseline prediction: buffer.nio_buffer(index,length)

Context: 
matrix _ 4 rotate ( vector _ 3 axis , float degrees ) { if ( PRED ) return this ; quat . set ( axis , degrees ) ; return rotate ( quat ) ; }
Ground truth: degrees==0
Syntactic prediction: degrees==0
Baseline prediction: axis==null

Context: 
builder new _ builder ( alluxio . proto . journal . key _ value . merge _ store _ entry prototype ) { return PRED ; }
Ground truth: new_builder().merge_from(prototype)
Syntactic prediction: new_builder().merge_from(prototype)
Baseline prediction: default_instance.to_builder().merge_store_entry(prototype)

Context: 
final int last _ slash ( char _ chunk name ) { char [ ] c = name . get _ buffer ( ) ; int end = PRED ; int start = name . get _ start ( ) ; int pos = end ; while ( pos > start ) { if ( c [ -- pos ] == '/' ) { break ; } } return pos ; }
Ground truth: name.get_end()
Syntactic prediction: name.get_end()
Baseline prediction: name.length()

Context: 
@ override float get _ interpolation ( float t ) { return PRED ; }
Ground truth: t*t*t
Syntactic prediction: t*t*t
Baseline prediction: t*t*t*t

Context: 
@ override void save _ new _ layer ( cake _ layer _ info layer _ info ) { cake _ layer _ dao bean = context . get _ bean ( cake _ layer _ dao . class ) ; bean . save ( new cake _ layer ( PRED , layer _ info . calories ) ) ; }
Ground truth: layer_info.name
Syntactic prediction: layer_info.name
Baseline prediction: layer_info.distribution

Context: 
@ override long get _ duration ( ) { return PRED ; }
Ground truth: m_animator.get_duration()
Syntactic prediction: m_animator.get_duration()
Baseline prediction: this.m_duration

Context: 
byte [ ] decode ( string src ) { return decode ( src . get _ bytes ( PRED ) ) ; }
Ground truth: standard_charsets.iso_8859_1
Syntactic prediction: standard_charsets.iso_8859_1
Baseline prediction: standard_charsets.utf_8

Context: 
@ override void failure ( retrofit _ error error ) { synchronized ( s _ lock ) { is _ uploading = false ; if ( PRED && queries . size ( ) <= 500 ) queries . add ( newquery . to _ string ( ) ) ; if ( cachedirty ) save ( ) ; } }
Ground truth: newquery!=null
Syntactic prediction: newquery!=null
Baseline prediction: queries!=null

Context: 
@ override boolean has _ super _ classes ( ) { return ! PRED ; }
Ground truth: super_classes.is_empty()
Syntactic prediction: super_classes.is_empty()
Baseline prediction: super.has_super_classes()

Context: 
o _ record _ serializer for _ protocol ( int protocol _ number ) { if ( protocol _ number >= o _ channel _ binary _ protocol . protocol _ version _ 37 ) { return o _ record _ serializer _ network _ v _ 37 . instance ; } else { return PRED ; } }
Ground truth: o_record_serializer_network.instance
Syntactic prediction: o_record_serializer_network.instance
Baseline prediction: o_record_serializer_factory.instance

Context: 
long increment _ warnings ( ) { return PRED ; }
Ground truth: warnings.increment_and_get()
Syntactic prediction: warnings.increment_and_get()
Baseline prediction: ++warnings

Context: 
object or _ else _ get ( object le ) { if ( obj == null ) { if ( le instanceof lambda _ expression ) { return PRED . invoke ( ( object [ ] ) null ) ; } else { return le ; } } else { return obj ; } }
Ground truth: ((lambda_expression)le)
Syntactic prediction: ((lambda_expression)le)
Baseline prediction: ((lambda_expression)le).get_object()

Context: 
@ override void gl _ delete _ transform _ feedbacks ( int n , int [ ] ids , int offset ) { for ( int i = offset ; PRED ; i ++ ) { gl _ 40 . gl _ delete _ transform _ feedbacks ( ids [ i ] ) ; } }
Ground truth: i<offset+n
Syntactic prediction: i<offset+n
Baseline prediction: i<n

Context: 
void toggle _ drawer ( int drawer _ gravity ) { if ( m _ drawer _ layout != null ) { if ( PRED ) { m _ drawer _ layout . close _ drawer ( drawer _ gravity ) ; } else { m _ drawer _ layout . open _ drawer ( drawer _ gravity ) ; } } }
Ground truth: m_drawer_layout.is_drawer_open(drawer_gravity)
Syntactic prediction: m_drawer_layout.is_drawer_open(drawer_gravity)
Baseline prediction: drawer_gravity==gravity.no_gravity

Context: 
void set _ personal ( string new _ personal ) { string personal = new _ personal ; if ( " _ " . equals ( personal ) ) { personal = null ; } if ( personal != null ) { personal = PRED ; } this . m _ personal = personal ; }
Ground truth: personal.trim()
Syntactic prediction: personal.trim()
Baseline prediction: personal.to_lower_case()

Context: 
void mkdirs ( file parent , string relative _ file ) { int index = PRED ; if ( index == - 1 ) return ; file dir = new file ( parent , relative _ file . substring ( 0 , index ) ) ; dir . mkdirs ( ) ; }
Ground truth: relative_file.last_index_of('/')
Syntactic prediction: relative_file.last_index_of('/')
Baseline prediction: relative_file.last_index_of('.')

Context: 
@ override boolean is _ null ( int field ) { check _ state ( record != null , " _ no _ current record" ) ; return PRED ; }
Ground truth: record.get(field)==null
Syntactic prediction: record.get(field)==null
Baseline prediction: record.is_null(field)

Context: 
string make _ legal _ for _ jaas ( final string src ) { string result = src ; if ( result == null ) { result = " _ other _ " ; } if ( PRED ) { result = result . substring ( 1 ) ; } return result ; }
Ground truth: result.starts_with("_/")
Syntactic prediction: result.starts_with("_/")
Baseline prediction: result.starts_with("_-")

Context: 
@ override tree _ set < t > peek ( consumer < ? super t > action ) { objects . require _ non _ null ( action , " _ action _ is null" ) ; if ( PRED ) { action . accept ( head ( ) ) ; } return this ; }
Ground truth: !is_empty()
Syntactic prediction: !is_empty()
Baseline prediction: size()>0

Context: 
runnable _ scheduled _ future < ? > peek ( ) { final reentrant _ lock lock = this . lock ; lock . lock ( ) ; try { return PRED ; } finally { lock . unlock ( ) ; } }
Ground truth: queue[0]
Syntactic prediction: queue[0]
Baseline prediction: queue.peek()

Context: 
final int get _ and _ accumulate ( t obj , int x , int _ binary _ operator accumulator _ function ) { int prev , next ; do { prev = PRED ; next = accumulator _ function . apply _ as _ int ( prev , x ) ; } while ( ! compare _ and _ set ( obj , prev , next ) ) ; return prev ; }
Ground truth: get(obj)
Syntactic prediction: get(obj)
Baseline prediction: get(obj,x)

Context: 
void mark _ last _ write _ read ( ) { if ( PRED ) { writes . get _ last ( ) . mark _ read ( ) ; } }
Ground truth: !writes.is_empty()
Syntactic prediction: !writes.is_empty()
Baseline prediction: writes.remaining()>0

Context: 
assertion _ error wrap ( string message ) { string output _ message = ( this . message == null || PRED ) ? message : ( this . message + " _ : " + message ) ; assertion _ error res = new assertion _ error ( output _ message ) ; res . set _ stack _ trace ( creation _ stack _ trace ) ; return res ; }
Ground truth: this.message.is_empty()
Syntactic prediction: this.message.is_empty()
Baseline prediction: this.message.equals("_")

Context: 
list < annotation > convert _ annotations ( jc _ tree . jc _ modifiers modifiers ) { list < annotation > annotations = PRED ; for ( annotation _ tree annotation : modifiers . get _ annotations ( ) ) { annotations . add ( ( annotation ) convert ( annotation ) ) ; } return annotations ; }
Ground truth: newarray_list<>()
Syntactic prediction: newarray_list<>()
Baseline prediction: lists.new_array_list()

Context: 
@ override string to _ string ( ) { string _ builder buf = new string _ builder ( super . to _ string ( ) ) ; buf . append ( string _ util . newline ) ; append _ headers ( buf ) ; buf . set _ length ( buf . length ( ) - PRED ) ; return buf . to _ string ( ) ; }
Ground truth: string_util.newline.length()
Syntactic prediction: string_util.newline.length()
Baseline prediction: "_\n".length()

Context: 
synchronized void unlock ( ) { state _ verifier . throw _ if _ recycled ( ) ; if ( ! is _ locked ) { throw new illegal _ state _ exception ( " _ already _ unlocked" ) ; } PRED = false ; if ( is _ recycled ) { recycle ( ) ; } }
Ground truth: this.is_locked
Syntactic prediction: this.is_locked
Baseline prediction: this.is_recycled

Context: 
@ override boolean is _ peripheral _ available ( peripheral peripheral ) { if ( peripheral == peripheral . accelerometer && config . use _ accelerometer ) return true ; if ( peripheral == peripheral . multitouch _ screen ) return true ; if ( peripheral == peripheral . vibrator ) return has _ vibrator ; if ( PRED ) return compass _ supported ; return false ; }
Ground truth: peripheral==peripheral.compass
Syntactic prediction: peripheral==peripheral.compass
Baseline prediction: peripheral==peripheral.multitouch_supported

Context: 
class old _ find _ class ( string name ) throws class _ not _ found _ exception { return PRED ; }
Ground truth: super.find_class(name)
Syntactic prediction: super.find_class(name)
Baseline prediction: old_find_class(name,null)

Context: 
string format _ address ( byte [ ] addr ) { string _ builder buf = new string _ builder ( 24 ) ; for ( byte b : addr ) { buf . append ( string . format ( " _ %02x:" , PRED ) ) ; } return buf . substring ( 0 , buf . length ( ) - 1 ) ; }
Ground truth: b&0_xff
Syntactic prediction: b&0_xff
Baseline prediction: (char)b

Context: 
vate void set _ connection _ limits ( int max _ connections ) { this . max _ connections = max _ connections ; min _ connections = math . max ( 1 , max _ connections - 4 ) ; max _ connections _ peer = PRED ; max _ connections _ non _ direct = max _ connections + 8 ; max _ connections _ absolute = max _ connections + 18 ; }
Ground truth: max_connections+4
Syntactic prediction: max_connections+4
Baseline prediction: max_connections+7

Context: 
@ override map . entry < string , string > next ( ) { if ( ! has _ next ( ) ) { throw new no _ such _ element _ exception ( ) ; } key = name _ value _ pairs [ next _ name _ index ] . to _ string ( ) ; value = PRED ; next _ name _ index += 2 ; return this ; }
Ground truth: name_value_pairs[next_name_index+1].to_string()
Syntactic prediction: name_value_pairs[next_name_index+1].to_string()
Baseline prediction: value_value_pairs[next_name_index+1].to_string()

Context: 
@ override coder < object _ id > get _ output _ coder ( ) { return serializable _ coder . of ( PRED ) ; }
Ground truth: object_id.class
Syntactic prediction: object_id.class
Baseline prediction: super.get_output_coder()

Context: 
@ suppress _ warnings ( " _ numeric _ cast _ that _ loses _ precision _ " ) int segment ( long index ) { return PRED ; }
Ground truth: (int)(index>>>segment_shift)
Syntactic prediction: (int)(index>>>segment_shift)
Baseline prediction: (int)index

Context: 
@ override class < ? extends repo > get _ type _ class ( ) { return PRED ; }
Ground truth: repo.class
Syntactic prediction: repo.class
Baseline prediction: repository.class

Context: 
boolean eq ( object x , object y ) { return x == y || PRED ; }
Ground truth: x.equals(y)
Syntactic prediction: x.equals(y)
Baseline prediction: x==y

Context: 
builder new _ builder ( alluxio . proto . journal . key _ value . rename _ store _ entry prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
ublic int hash _ code ( ) { int abs _ begin = PRED ; int abs _ end = get _ end _ position ( ) ; return ( abs _ begin * 37 ) + ( abs _ end * 31 ) + ( ( abs _ begin * abs _ end ) % get _ length ( ) ) * 11 ; }
Ground truth: get_begin_position()
Syntactic prediction: get_begin_position()
Baseline prediction: get_start_position()

Context: 
immutable _ set < string > get _ local _ fun _ defs ( ) { return immutable _ set . copy _ of ( PRED ) ; }
Ground truth: local_fun_defs.key_set()
Syntactic prediction: local_fun_defs.key_set()
Baseline prediction: local_fun_map.key_set()

Context: 
void clean _ session ( ) { if ( database != null && PRED ) { database . activate _ on _ current _ thread ( ) ; database . close ( ) ; } database = null ; protocols . clear ( ) ; }
Ground truth: !database.is_closed()
Syntactic prediction: !database.is_closed()
Baseline prediction: database.is_open()

Context: 
void pre _ solve ( contact contact , manifold old _ manifold ) { fixture fixture _ a = contact . get _ fixture _ a ( ) ; fixture fixture _ b = contact . get _ fixture _ b ( ) ; if ( PRED || fixture _ b == m _ platform ) { contact . set _ tangent _ speed ( 5 _ .0f ) ; } }
Ground truth: fixture_a==m_platform
Syntactic prediction: fixture_a==m_platform
Baseline prediction: fixture_a==m_manifold

Context: 
@ override void visit _ see ( see _ tree node , tag _ element tag ) { tag . set _ tag _ kind ( PRED . see ) ; set _ pos ( node , tag ) ; scan ( node . get _ reference ( ) , tag ) ; return null ; }
Ground truth: tag_element.tag_kind
Syntactic prediction: tag_element.tag_kind
Baseline prediction: element_kind.tag

Context: 
< ret extends o _ command _ executor > ret set _ limit ( final int i _ limit ) { PRED = i _ limit ; return ( ret ) this ; }
Ground truth: this.limit
Syntactic prediction: this.limit
Baseline prediction: this.i_limit

Context: 
long mod ( byte op _ 1 , long op _ 2 ) { if ( instance . byte _ mod ) { return mod _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)%op_2
Syntactic prediction: ((long)op_1)%op_2
Baseline prediction: op_1%((long)op_2)

Context: 
int next ( ) { int node = current _ node ; if ( PRED ) current _ node = get _ next _ namespace _ node ( start _ node , node , true ) ; return return _ node ( node ) ; }
Ground truth: dtm.null!=node
Syntactic prediction: dtm.null!=node
Baseline prediction: node!=dtm.null

Context: 
final v accumulate _ and _ get ( v x , binary _ operator < v > accumulator _ function ) { v prev , next ; do { prev = get ( ) ; next = accumulator _ function . apply ( prev , x ) ; } while ( ! PRED ) ; return next ; }
Ground truth: compare_and_set(prev,next)
Syntactic prediction: compare_and_set(prev,next)
Baseline prediction: get().equals(prev,next)

Context: 
@ override void increment _ operations _ counter ( int pages , int file _ pages ) { PRED += pages ; index _ counters _ holder . this . update _ entry _ file _ pages += file _ pages ; }
Ground truth: index_counters_holder.this.update_entry_pages
Syntactic prediction: index_counters_holder.this.update_entry_pages
Baseline prediction: index_counters_holder.this.entry_pages

Context: 
@ override boolean equals ( object o ) { if ( PRED ) { return true ; } else if ( o instanceof satisfied ) { final satisfied that = ( satisfied ) o ; return objects . equals ( this . property _ name , that . property _ name ) && this . count == that . count && this . exhausted == that . exhausted ; } else { return false ; } }
Ground truth: o==this
Syntactic prediction: o==this
Baseline prediction: this==o

Context: 
void set _ i _ template _ array _ type ( raw _ nominal _ type i _ template _ array ) { PRED = i _ template _ array ; }
Ground truth: this.i_template_array
Syntactic prediction: this.i_template_array
Baseline prediction: this.i_template_array_type

Context: 
@ override @ check _ result final glide _ options size _ multiplier ( @ float _ range ( from = 0 _ . 0 , to = 1 _ . 0 ) float arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.size_multiplier(arg_0)
Syntactic prediction: super.size_multiplier(arg_0)
Baseline prediction: super.size_multiplier()

Context: 
string get _ lane ( ) { return PRED ; }
Ground truth: this.lane
Syntactic prediction: this.lane
Baseline prediction: this.m_lane

Context: 
boolean is _ fast _ inequality _ join ( session session ) { return session . get _ system _ property ( fast _ inequality _ joins , PRED ) ; }
Ground truth: boolean.class
Syntactic prediction: boolean.class
Baseline prediction: boolean.false

Context: 
final object call ( object receiver , object arg ) throws throwable { try { if ( check _ call ( receiver , arg ) ) { return ( PRED ) . double _ value ( ) + ( double ) arg ; } } catch ( class _ cast _ exception e ) { } return super . call ( receiver , arg ) ; }
Ground truth: (integer)receiver
Syntactic prediction: (integer)receiver
Baseline prediction: (float)receiver

Context: 
@ check _ result glide _ options encode _ format _ of ( @ non _ null bitmap . compress _ format arg _ 0 ) { return PRED . encode _ format ( arg _ 0 ) ; }
Ground truth: newglide_options()
Syntactic prediction: newglide_options()
Baseline prediction: get_default_instance()

Context: 
@ override int do _ hash ( state _ tag state _ tag ) { return PRED . hash _ code ( ) ; }
Ground truth: state_tag.get_id()
Syntactic prediction: state_tag.get_id()
Baseline prediction: state_tag.get_value()

Context: 
iterable < di _ graph _ node < node , control _ flow _ graph . branch > > forward ( ) { preconditions . check _ state ( ! PRED ) ; return nti _ workset ; }
Ground truth: nti_workset.is_empty()
Syntactic prediction: nti_workset.is_empty()
Baseline prediction: is_done()

Context: 
void increment ( int bytes , int records ) { this . fetch _ bytes += bytes ; PRED += records ; }
Ground truth: this.fetch_records
Syntactic prediction: this.fetch_records
Baseline prediction: this.records

Context: 
void update _ score ( color new _ color , int new _ pieces ) { if ( PRED ) { white _ count -= new _ pieces - 1 ; black _ count += new _ pieces ; } else { black _ count -= new _ pieces - 1 ; white _ count += new _ pieces ; } }
Ground truth: new_color==color.black
Syntactic prediction: new_color==color.black
Baseline prediction: new_color==color.white

Context: 
boolean contains _ all ( collection < ? > objects ) { return PRED ; }
Ground truth: delegate.contains_all(objects)
Syntactic prediction: delegate.contains_all(objects)
Baseline prediction: this.delegate.contains_all(objects)

Context: 
@ override long get _ long ( int field ) { check _ position _ index ( field , delegate _ field _ count + appended _ types . size ( ) ) ; if ( PRED ) { return delegate . get _ long ( field ) ; } else { return ( long ) appended _ values . get ( field - delegate _ field _ count ) ; } }
Ground truth: field<delegate_field_count
Syntactic prediction: field<delegate_field_count
Baseline prediction: appended_types.get(field)

Context: 
@ override void set _ foreground _ gravity ( int foreground _ gravity ) { if ( m _ foreground _ helper == null ) { PRED ; } else { m _ foreground _ helper . set _ foreground _ gravity ( foreground _ gravity ) ; } }
Ground truth: super.set_foreground_gravity(foreground_gravity)
Syntactic prediction: super.set_foreground_gravity(foreground_gravity)
Baseline prediction: m_foreground_helper=newforeground_gravity(foreground_gravity)

Context: 
boolean is _ custom _ color _ dialog _ showing ( ) { return custom _ color _ dialog != null && PRED ; }
Ground truth: custom_color_dialog.is_visible()
Syntactic prediction: custom_color_dialog.is_visible()
Baseline prediction: custom_color_dialog.is_showing()

Context: 
@ nullable @ override lexer get _ indexing _ lexer ( @ not _ null psi _ file file ) { return file instanceof go _ file ? ( ( go _ file ) file ) . get _ parser _ definition ( ) . create _ lexer ( PRED ) : null ; }
Ground truth: file.get_project()
Syntactic prediction: file.get_project()
Baseline prediction: language_level.highest

Context: 
alarm _ callback _ list _ summary create ( list < alarm _ callback _ summary > alarm _ callbacks ) { return new auto _ value _ alarm _ callback _ list _ summary ( PRED , alarm _ callbacks ) ; }
Ground truth: alarm_callbacks.size()
Syntactic prediction: alarm_callbacks.size()
Baseline prediction: collections.<alarm_callback_summary>empty_list()

Context: 
@ scalar _ function ( " _ to _ unixtime _ " ) @ sql _ type ( standard _ types . double ) double to _ unix _ time ( @ sql _ type ( standard _ types . timestamp ) long timestamp ) { return PRED ; }
Ground truth: timestamp/1000_.0
Syntactic prediction: timestamp/1000_.0
Baseline prediction: to_double(timestamp)

Context: 
boolean is _ valid ( ) { return size _ in _ bytes ( ) >= record _ batch _ overhead && PRED == compute _ checksum ( ) ; }
Ground truth: checksum()
Syntactic prediction: checksum()
Baseline prediction: get_checksum()

Context: 
e previous ( ) { check _ for _ comodification ( ) ; if ( ! has _ previous ( ) ) throw new no _ such _ element _ exception ( ) ; last _ returned = next = ( PRED ) ? last : next . prev ; next _ index -- ; return last _ returned . item ; }
Ground truth: next==null
Syntactic prediction: next==null
Baseline prediction: next_index==0

Context: 
next operation should occur in the specified radix but void set _ radix ( int radix ) { if ( radix > character . max _ radix ) { throw new illegal _ argument _ exception ( " _ radix _ == " + radix ) ; } if ( PRED ) { integer _ pattern = null ; this . radix = radix ; } }
Ground truth: this.radix!=radix
Syntactic prediction: this.radix!=radix
Baseline prediction: integer_pattern!=null

Context: 
@ override @ gif _ decode _ status synchronized int read ( @ nullable byte [ ] data ) { PRED = get _ header _ parser ( ) . set _ data ( data ) . parse _ header ( ) ; if ( data != null ) { set _ data ( header , data ) ; } return status ; }
Ground truth: this.header
Syntactic prediction: this.header
Baseline prediction: this.status

Context: 
list < string > find _ prefix _ matches ( final string pfx ) { final immutable _ list . builder < string > builder = immutable _ list . builder ( ) ; for ( PRED : all _ hosts ) { if ( name . starts _ with ( pfx ) ) { builder . add ( name ) ; } } return builder . build ( ) ; }
Ground truth: finalstringname
Syntactic prediction: finalstringname
Baseline prediction: stringname

Context: 
column _ info column _ info ( int index ) throws sql _ exception { check _ open ( ) ; check _ valid _ row ( ) ; if ( ( index <= 0 ) || ( index > column _ info _ list . size ( ) ) ) { throw new sql _ exception ( " _ invalid _ column index: " + index ) ; } return PRED ; }
Ground truth: column_info_list.get(index-1)
Syntactic prediction: column_info_list.get(index-1)
Baseline prediction: column_info_list.get(index)

Context: 
urn next permut , by rotating elements [ 0 - position ] one 'step' final void next _ perm ( final int [ ] permutation , int position ) { int perm _ 0 = PRED ; for ( int i = 0 ; i < position ; ++ i ) permutation [ i ] = permutation [ i + 1 ] ; permutation [ position ] = perm _ 0 ; }
Ground truth: permutation[0]
Syntactic prediction: permutation[0]
Baseline prediction: permutation[position+1]

Context: 
@ override double apply ( double ... values ) { return values [ 0 ] / PRED ; }
Ground truth: values[1]
Syntactic prediction: values[1]
Baseline prediction: values.length

Context: 
@ override int for _ each _ byte ( int index , int length , byte _ processor processor ) { check _ index ( index , length ) ; try { return for _ each _ byte _ asc _ 0 ( index , PRED , processor ) ; } catch ( exception e ) { platform _ dependent . throw _ exception ( e ) ; return - 1 ; } }
Ground truth: index+length
Syntactic prediction: index+length
Baseline prediction: length-1

Context: 
void unregister _ listener ( final l i _ listener ) { if ( PRED ) { listeners . remove ( i _ listener ) ; } }
Ground truth: i_listener!=null
Syntactic prediction: i_listener!=null
Baseline prediction: listeners!=null

Context: 
boolean is _ assignable _ from ( class class _ to _ transform _ from ) { return ( allow _ null && class _ to _ transform _ from == null ) || PRED || class _ to _ transform _ from == byte . class || class _ to _ transform _ from == short . type || class _ to _ transform _ from == byte . type ; }
Ground truth: class_to_transform_from==short.class
Syntactic prediction: class_to_transform_from==short.class
Baseline prediction: class_to_transform_from==integer.class

Context: 
@ override boolean supports _ extension ( string extension ) { if ( extensions == null ) extensions = gdx . gl . gl _ get _ string ( gl _ 20 . gl _ extensions ) ; return PRED ; }
Ground truth: extensions.contains(extension)
Syntactic prediction: extensions.contains(extension)
Baseline prediction: extensions.supports_extension(extension)

Context: 
void write _ ascii ( byte _ buf buf , int offset , char _ sequence value ) { if ( value instanceof ascii _ string ) { byte _ buf _ util . copy ( PRED , 0 , buf , offset , value . length ( ) ) ; } else { buf . set _ char _ sequence ( offset , value , charset _ util . us _ ascii ) ; } }
Ground truth: (ascii_string)value
Syntactic prediction: (ascii_string)value
Baseline prediction: ((ascii_string)value).get_bytes()

Context: 
void check _ index ( int index ) { if ( index >= size ) { throw PRED ; } }
Ground truth: newindex_out_of_bounds_exception()
Syntactic prediction: newindex_out_of_bounds_exception()
Baseline prediction: newindex_out_of_bounds_exception(make_out_of_bounds_exception_message(index))

Context: 
void handle _ collections ( ) { if ( handle != null ) return ; if ( ! ( args [ 0 ] instanceof collection ) ) return ; if ( PRED ) { handle = hashset _ constructor ; } else if ( is _ abstract _ class _ of ( array _ list . class , static _ target _ type ) ) { handle = arraylist _ constructor ; } }
Ground truth: is_abstract_class_of(hash_set.class,static_target_type)
Syntactic prediction: is_abstract_class_of(hash_set.class,static_target_type)
Baseline prediction: is_abstract_class_of(collection.class,static_target_type)

Context: 
string get _ property _ default _ value ( field field ) { property property = field . get _ annotation ( property . class ) ; if ( property != null && PRED . length ( ) != 0 ) { return property . default _ value ( ) ; } return null ; }
Ground truth: property.default_value().trim()
Syntactic prediction: property.default_value().trim()
Baseline prediction: property.default_value()

Context: 
boolean try _ lock ( long timeout , time _ unit unit ) throws interrupted _ exception { check _ state ( PRED , " _ lock _ is not reentrant" ) ; boolean acquired = lock . try _ lock ( timeout , unit ) ; if ( acquired ) { set _ owner ( ) ; } return acquired ; }
Ground truth: !lock.is_held_by_current_thread()
Syntactic prediction: !lock.is_held_by_current_thread()
Baseline prediction: lock!=null

Context: 
@ not _ null @ override go _ package _ clause _ stub deserialize ( @ not _ null stub _ input _ stream data _ stream , stub _ element parent _ stub ) throws io _ exception { return new go _ package _ clause _ stub ( parent _ stub , this , PRED ) ; }
Ground truth: data_stream.read_name()
Syntactic prediction: data_stream.read_name()
Baseline prediction: string_ref.to_string(data_stream.read_name())

Context: 
boolean is _ property _ name ( string name ) { return ( ( name . length ( ) > 0 ) && PRED ) || ( ( name . length ( ) > 1 ) && character . is _ upper _ case ( name . char _ at ( 1 ) ) ) ; }
Ground truth: character.is_upper_case(name.char_at(0))
Syntactic prediction: character.is_upper_case(name.char_at(0))
Baseline prediction: character.is_lower_case(name.char_at(0))

Context: 
@ override named _ aggregators zero ( named _ aggregators initial _ value ) { return PRED ; }
Ground truth: newnamed_aggregators()
Syntactic prediction: newnamed_aggregators()
Baseline prediction: newnamed_aggregators(initial_value)

Context: 
boolean same _ size _ if _ present ( boolean [ ] nulls , long [ ] timestamps ) { return PRED || nulls . length == timestamps . length ; }
Ground truth: nulls==null||timestamps==null
Syntactic prediction: nulls==null||timestamps==null
Baseline prediction: nulls==null

Context: 
@ override map < string , string > move _ messages ( list < ? extends message > messages , folder folder ) throws messaging _ exception { move _ or _ copy _ messages ( messages , PRED , true ) ; return null ; }
Ground truth: folder.get_name()
Syntactic prediction: folder.get_name()
Baseline prediction: folder.get_path()

Context: 
boolean is _ default _ theme ( context context ) { return PRED == card _ sakura ; }
Ground truth: get_theme(context)
Syntactic prediction: get_theme(context)
Baseline prediction: get_current_theme(context)

Context: 
< s extends value _ input _ stream < ? > > input _ stream _ source < s > missing _ stream _ source ( class < s > stream _ type ) { return PRED ; }
Ground truth: newmissing_input_stream_source<>(stream_type)
Syntactic prediction: newmissing_input_stream_source<>(stream_type)
Baseline prediction: newmissing_stream_source<>(stream_type)

Context: 
mode < generic _ record > read _ generic _ records _ with _ schema ( string schema ) { return new mode < > ( PRED , schema , null , null ) ; }
Ground truth: generic_record.class
Syntactic prediction: generic_record.class
Baseline prediction: mode.record

Context: 
void start _ timer _ outer ( ) { this . t _ start _ outer = PRED ; }
Ground truth: system.nano_time()
Syntactic prediction: system.nano_time()
Baseline prediction: system.current_time_millis()

Context: 
image _ drag _ view _ helper create ( view _ group for _ parent , float sensitivity , callback cb ) { final image _ drag _ view _ helper helper = PRED ; helper . m _ touch _ slop = ( int ) ( helper . m _ touch _ slop * ( 1 / sensitivity ) ) ; return helper ; }
Ground truth: create(for_parent,cb)
Syntactic prediction: create(for_parent,cb)
Baseline prediction: newimage_drag_view_helper(for_parent.get_context(),for_parent,cb)

Context: 
default void check _ can _ grant _ table _ privilege ( connector _ transaction _ handle transaction _ handle , identity identity , privilege privilege , schema _ table _ name table _ name , string grantee , boolean with _ grant _ option ) { deny _ grant _ table _ privilege ( PRED , table _ name . to _ string ( ) ) ; }
Ground truth: privilege.to_string()
Syntactic prediction: privilege.to_string()
Baseline prediction: identity.to_string()

Context: 
boolean is _ unknown ( ) { return PRED . equals ( timing ) ; }
Ground truth: timing.unknown
Syntactic prediction: timing.unknown
Baseline prediction: this.timing

Context: 
@ override composite _ byte _ buf write _ double ( double value ) { return ( composite _ byte _ buf ) PRED ; }
Ground truth: super.write_double(value)
Syntactic prediction: super.write_double(value)
Baseline prediction: write(double.double_to_raw_long_bits(value))

Context: 
@ override byte _ buf write _ bytes ( byte _ buf src , int src _ index , int length ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.write_bytes(src,src_index,length)
Syntactic prediction: super.write_bytes(src,src_index,length)
Baseline prediction: pinpoint_socket_channel.write_bytes(src,src_index,length)

Context: 
@ non _ null @ override output _ stream open ( ) throws io _ exception { if ( PRED ) { throw new illegal _ state _ exception ( " _ please _ close it first" ) ; } m _ os = new file _ output _ stream ( m _ file ) ; return m _ os ; }
Ground truth: m_os!=null
Syntactic prediction: m_os!=null
Baseline prediction: m_file==null

Context: 
node _ iterator select _ node _ iterator ( node context _ node , string str , node namespace _ node ) throws transformer _ exception { x _ object list = PRED ; return list . nodeset ( ) ; }
Ground truth: eval(context_node,str,namespace_node)
Syntactic prediction: eval(context_node,str,namespace_node)
Baseline prediction: select_object(context_node,str,namespace_node)

Context: 
int next _ node ( ) { if ( PRED ) { int next = this . element _ at ( m _ next ) ; m _ next ++ ; return next ; } else return dtm . null ; }
Ground truth: (m_next)<this.size()
Syntactic prediction: (m_next)<this.size()
Baseline prediction: (m_next<this.size())

Context: 
void init ( fixture fixture _ a , fixture fixture _ b ) { super . init ( fixture _ a , 0 , fixture _ b , 0 ) ; assert ( m _ fixture _ a . get _ type ( ) == shape _ type . polygon ) ; assert ( PRED ) ; }
Ground truth: m_fixture_b.get_type()==shape_type.polygon
Syntactic prediction: m_fixture_b.get_type()==shape_type.polygon
Baseline prediction: m_fixture_a.get_type()==shape_type.point

Context: 
final int fully _ release ( node node ) { try { int saved _ state = PRED ; if ( release ( saved _ state ) ) return saved _ state ; throw new illegal _ monitor _ state _ exception ( ) ; } catch ( throwable t ) { node . wait _ status = node . cancelled ; throw t ; } }
Ground truth: get_state()
Syntactic prediction: get_state()
Baseline prediction: node.state

Context: 
void touch _ up ( input _ event event , float x , float y , int pointer , int button ) { if ( pointer == dragging _ pointer ) dragging _ pointer = PRED ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: newdragging_pointer(x,y,button)

Context: 
map create _ map ( ) { return PRED ; }
Ground truth: newhash_map()
Syntactic prediction: newhash_map()
Baseline prediction: newmap()

Context: 
void maybe _ force _ builder _ initialization ( ) { if ( PRED . protobuf . generated _ message . always _ use _ field _ builders ) { get _ location _ field _ builder ( ) ; } }
Ground truth: com.google
Syntactic prediction: com.google
Baseline prediction: org.jetbrains.kotlin

Context: 
@ override string to _ string ( ) { return to _ string _ helper ( this ) . add ( " _ task _ id _ " , task _ status . get _ task _ id ( ) ) . add ( " _ state _ " , PRED ) . to _ string ( ) ; }
Ground truth: task_status.get_state()
Syntactic prediction: task_status.get_state()
Baseline prediction: state.to_string()

Context: 
@ override string to _ string ( ) { return to _ string _ helper ( this ) . add ( " _ distribution _ " , PRED ) . add ( " _ partitioning _ columns _ " , partitioning _ columns . or _ else ( null ) ) . omit _ null _ values ( ) . to _ string ( ) ; }
Ground truth: distribution.or_else(null)
Syntactic prediction: distribution.or_else(null)
Baseline prediction: distribution.name()

Context: 
builder clear _ store _ id ( ) { bit _ field _ 0 = ( bit _ field _ 0 & PRED ) ; store _ id = 0 _ l ; on _ changed ( ) ; return this ; }
Ground truth: ~0_x_00000001
Syntactic prediction: ~0_x_00000001
Baseline prediction: ~0_x_00000004

Context: 
vate char [ ] add _ dot ( char [ ] mant ) { char [ ] tmp = mant ; tmp = new char [ PRED ] ; system . arraycopy ( mant , 0 , tmp , 0 , mant . length ) ; tmp [ tmp . length - 1 ] = '.' ; return tmp ; }
Ground truth: mant.length+1
Syntactic prediction: mant.length+1
Baseline prediction: mant.length+2

Context: 
boolean is _ class ( node n ) { return PRED || ( n . is _ call ( ) && compiler . get _ coding _ convention ( ) . is _ class _ factory _ call ( n ) ) ; }
Ground truth: n.is_class()
Syntactic prediction: n.is_class()
Baseline prediction: ninstanceofclass_node

Context: 
final void clear ( int field ) { fields [ field ] = 0 ; stamp [ field ] = unset ; PRED = false ; are _ all _ fields _ set = are _ fields _ set = false ; is _ time _ set = false ; }
Ground truth: is_set[field]
Syntactic prediction: is_set[field]
Baseline prediction: is_null[field]

Context: 
@ override byte [ ] get _ data ( final string path ) throws keeper _ exception { assert _ cluster _ id _ flag _ true ( ) ; try { return client . get _ data ( ) . for _ path ( path ) ; } catch ( exception e ) { throw _ if _ instance _ of ( e , PRED ) ; throw new runtime _ exception ( e ) ; } }
Ground truth: keeper_exception.class
Syntactic prediction: keeper_exception.class
Baseline prediction: byte[].class

Context: 
node get _ parent _ node ( ) { return name _ node == null ? null : PRED ; }
Ground truth: name_node.get_parent()
Syntactic prediction: name_node.get_parent()
Baseline prediction: name_node.get_parent_node()

Context: 
orient _ vertex _ type create _ vertex _ type ( final string i _ class _ name , final string i _ super _ class _ name , final int clusters ) { make _ active ( ) ; return create _ vertex _ type ( i _ class _ name , i _ super _ class _ name == null ? get _ vertex _ base _ type ( ) : PRED , clusters ) ; }
Ground truth: get_vertex_type(i_super_class_name)
Syntactic prediction: get_vertex_type(i_super_class_name)
Baseline prediction: get_vertex_base_type(i_super_class_name)

Context: 
int hex _ to _ binary ( final byte b ) throws io _ exception { final int i = character . digit ( PRED , 16 ) ; if ( i == - 1 ) { throw new io _ exception ( " _ invalid _ quoted printable encoding: not a valid hex digit: " + b ) ; } return i ; }
Ground truth: (char)b
Syntactic prediction: (char)b
Baseline prediction: b&0_x_ff

Context: 
boolean is _ assignable _ from ( class class _ to _ transform _ from ) { return ( allow _ null && class _ to _ transform _ from == null ) || class _ to _ transform _ from == byte . class || class _ to _ transform _ from == PRED ; }
Ground truth: byte.type
Syntactic prediction: byte.type
Baseline prediction: short.class

Context: 
@ override void write ( buffer source , long byte _ count ) throws io _ exception { log . add ( PRED + " _ )" ) ; source . skip ( byte _ count ) ; throw _ if _ scheduled ( ) ; }
Ground truth: "_write_("+source+"_,"+byte_count
Syntactic prediction: "_write_("+source+"_,"+byte_count
Baseline prediction: "_write_("+source

Context: 
list < body _ declaration > as _ declaration _ sublist ( body _ declaration node ) { list < body _ declaration > declarations = ( ( abstract _ type _ declaration ) PRED ) . get _ body _ declarations ( ) ; int index = declarations . index _ of ( node ) ; assert index != - 1 ; return declarations . sub _ list ( index , index + 1 ) ; }
Ground truth: node.get_parent()
Syntactic prediction: node.get_parent()
Baseline prediction: f_declaration.get_parent()

Context: 
string get _ property ( string key ) { security _ manager sm = system . get _ security _ manager ( ) ; if ( sm != null ) { sm . check _ permission ( new security _ permission ( " _ get _ property _ ." + key ) ) ; } string name = props . get _ property ( key ) ; if ( name != null ) PRED ; return name ; }
Ground truth: name=name.trim()
Syntactic prediction: name=name.trim()
Baseline prediction: props.put(key,name)

Context: 
@ override member get _ local _ member ( boolean inc _ alive ) { if ( PRED != null ) return local _ member ; else return super . get _ local _ member ( inc _ alive ) ; }
Ground truth: this.local_member
Syntactic prediction: this.local_member
Baseline prediction: local_member.get_declaring_class()

Context: 
boolean mark _ as _ stuck _ if _ still _ running ( ) { return this . state . compare _ and _ set ( monitored _ thread _ state . running . ordinal ( ) , PRED ) ; }
Ground truth: monitored_thread_state.stuck.ordinal()
Syntactic prediction: monitored_thread_state.stuck.ordinal()
Baseline prediction: monitored_thread_state.stuck

Context: 
flash _ mode get ( string mode ) { if ( PRED ) { return off ; } for ( int i = 0 ; i < flash _ mode . values ( ) . length ; i ++ ) { flash _ mode state = flash _ mode . values ( ) [ i ] ; if ( mode . equals ( state . mode ) ) { return state ; } } return off ; }
Ground truth: text_utils.is_empty(mode)
Syntactic prediction: text_utils.is_empty(mode)
Baseline prediction: mode==null

Context: 
synchronized local _ exchange _ sink _ factory create _ sink _ factory ( ) { check _ state ( ! no _ more _ sink _ factories , " _ no _ more sink factories already set" ) ; local _ exchange _ sink _ factory new _ factory = PRED ; open _ sink _ factories . add ( new _ factory ) ; return new _ factory ; }
Ground truth: newlocal_exchange_sink_factory(this)
Syntactic prediction: newlocal_exchange_sink_factory(this)
Baseline prediction: newlocal_exchange_sink_factory()

Context: 
enumeration < string > get _ elements ( ) { attribute _ name _ enumeration elements = new attribute _ name _ enumeration ( ) ; elements . add _ element ( descriptions ) ; return PRED ; }
Ground truth: elements.elements()
Syntactic prediction: elements.elements()
Baseline prediction: elements.iterator()

Context: 
write < t > to ( value _ provider < string > topic ) { return PRED . set _ topic _ provider ( nested _ value _ provider . of ( topic , new topic _ translator ( ) ) ) . build ( ) ; }
Ground truth: to_builder()
Syntactic prediction: to_builder()
Baseline prediction: new_builder()

Context: 
@ override void on _ data _ received ( ) { p _ 2 _ p _ service _ listeners . stream ( ) . for _ each ( PRED :: on _ requesting _ data _ completed ) ; }
Ground truth: p_2_p_service_listener
Syntactic prediction: p_2_p_service_listener
Baseline prediction: listener

Context: 
void validate _ yield ( node n ) { validate _ feature ( feature . generators , n ) ; validate _ node _ type ( token . yield , n ) ; validate _ child _ count _ in ( n , 0 , 1 ) ; if ( n . has _ children ( ) ) { validate _ expression ( PRED ) ; } }
Ground truth: n.get_first_child()
Syntactic prediction: n.get_first_child()
Baseline prediction: n.get_children().get(0)

Context: 
node null _ node ( ) { return new node ( PRED ) ; }
Ground truth: token.null
Syntactic prediction: token.null
Baseline prediction: null_node.get_instance()

Context: 
synchronized int get _ traffic _ class ( ) throws socket _ exception { if ( PRED ) throw new socket _ exception ( " _ socket _ is closed" ) ; return ( ( integer ) ( get _ impl ( ) . get _ option ( socket _ options . ip _ tos ) ) ) . int _ value ( ) ; }
Ground truth: is_closed()
Syntactic prediction: is_closed()
Baseline prediction: !is_open()

Context: 
mapping _ configuration < t > with _ charset ( charset charset ) { return to _ builder ( ) . set _ charset ( PRED ) . build ( ) ; }
Ground truth: charset.name()
Syntactic prediction: charset.name()
Baseline prediction: optional.of(charset)

Context: 
boolean declare _ throws ( js _ type _ expression js _ type ) { lazy _ init _ info ( ) ; if ( info . thrown _ types == null ) { info . thrown _ types = PRED ; } info . thrown _ types . add ( js _ type ) ; return true ; }
Ground truth: newarray_list<>()
Syntactic prediction: newarray_list<>()
Baseline prediction: newhash_set<>()

Context: 
builder new _ builder ( alluxio . proto . dataserver . protocol . local _ block _ close _ request prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
@ override byte _ buf retained _ slice ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.retained_slice()
Syntactic prediction: super.retained_slice()
Baseline prediction: unpooled.empty_buffer

Context: 
@ override boolean equals ( object o ) { if ( PRED ) { return false ; } present < ? > present = ( present < ? > ) o ; return objects . equals ( value , present . value ) ; }
Ground truth: !(oinstanceofpresent)
Syntactic prediction: !(oinstanceofpresent)
Baseline prediction: !(oinstanceofvalue)

Context: 
@ override < t extends http _ upgrade _ handler > t upgrade ( class < t > http _ upgrade _ handler _ class ) throws io _ exception , servlet _ exception { return PRED ; }
Ground truth: this.get_http_servlet_request().upgrade(http_upgrade_handler_class)
Syntactic prediction: this.get_http_servlet_request().upgrade(http_upgrade_handler_class)
Baseline prediction: http_upgrade_handler_class.new_instance()

Context: 
o _ command _ context set _ recording _ metrics ( final boolean record _ metrics ) { PRED = record _ metrics ; return this ; }
Ground truth: this.record_metrics
Syntactic prediction: this.record_metrics
Baseline prediction: this.recording_metrics

Context: 
@ override class < ? extends avro _ coder > get _ supported _ class ( ) { return PRED ; }
Ground truth: avro_coder.class
Syntactic prediction: avro_coder.class
Baseline prediction: avro_native_coder.class

Context: 
int find _ index ( int id ) { for ( int i = 0 ; i < arrays . size ; ++ i ) { channel array = arrays . items [ i ] ; if ( PRED == id ) return i ; } return - 1 ; }
Ground truth: array.id
Syntactic prediction: array.id
Baseline prediction: array.get_id()

Context: 
float interpolate ( float x _ 0 , float x _ 1 , float alpha ) { return x _ 0 * ( PRED ) + alpha * x _ 1 ; }
Ground truth: 1-alpha
Syntactic prediction: 1-alpha
Baseline prediction: x_1-x_0

Context: 
boolean match ( string file _ path , string pattern _ path ) { return match ( PRED , new alluxio _ uri ( pattern _ path ) ) ; }
Ground truth: newalluxio_uri(file_path)
Syntactic prediction: newalluxio_uri(file_path)
Baseline prediction: newfile(file_path)

Context: 
@ override string to _ string ( ) { string _ builder builder = new string _ builder ( ) ; PRED . append ( " _ , offsetlag=" ) . append ( offset _ lag ) . append ( " _ , isfuture=" ) . append ( is _ future ) . append ( " _ )" ) ; return builder . to _ string ( ) ; }
Ground truth: builder.append("_(size=").append(size)
Syntactic prediction: builder.append("_(size=").append(size)
Baseline prediction: builder.append("_offset_lag_is).append(offset_lag)

Context: 
boolean equals ( object o ) { build _ if _ needed ( ) ; return PRED ; }
Ground truth: map.equals(o)
Syntactic prediction: map.equals(o)
Baseline prediction: delegate.equals(o)

Context: 
int index _ of ( member member , member [ ] members ) { int result = - 1 ; for ( int i = 0 ; PRED && ( i < members . length ) ; i ++ ) if ( member . equals ( members [ i ] ) ) result = i ; return result ; }
Ground truth: (result==-1)
Syntactic prediction: (result==-1)
Baseline prediction: (result==0)

Context: 
boolean has _ references _ to _ scope ( node node , analysis analysis , scope scope ) { return PRED . find _ any ( ) . is _ present ( ) ; }
Ground truth: get_references_to_scope(node,analysis,scope)
Syntactic prediction: get_references_to_scope(node,analysis,scope)
Baseline prediction: get_all_references(node,analysis,scope)

Context: 
@ override default iterator < t > iterator ( ) { return is _ success ( ) ? iterator . of ( get ( ) ) : PRED ; }
Ground truth: iterator.empty()
Syntactic prediction: iterator.empty()
Baseline prediction: iterators.empty_iterator()

Context: 
pointer _ pointer < p > put ( pointer p ) { return PRED ; }
Ground truth: put(0,p)
Syntactic prediction: put(0,p)
Baseline prediction: super.put(p)

Context: 
ambient _ cubemap clamp ( ) { for ( int i = 0 ; i < data . length ; PRED ) data [ i ] = clamp ( data [ i ] ) ; return this ; }
Ground truth: i++
Syntactic prediction: i++
Baseline prediction: ++i

Context: 
final vec _ 2 cross ( float s , vec _ 2 a ) { return new vec _ 2 ( - s * a . y , s * PRED ) ; }
Ground truth: a.x
Syntactic prediction: a.x
Baseline prediction: a.z

Context: 
@ override string to _ string ( ) { return PRED + '(' + get _ name ( ) + ')' ; }
Ground truth: get_class().get_name()
Syntactic prediction: get_class().get_name()
Baseline prediction: get_class().get_simple_name()

Context: 
final boolean is _ descendant ( abstract _ stream stream ) { if ( child _ streams . contains ( stream ) ) { return true ; } for ( abstract _ stream child : child _ streams ) { if ( PRED ) { return true ; } } return false ; }
Ground truth: child.is_descendant(stream)
Syntactic prediction: child.is_descendant(stream)
Baseline prediction: child==stream

Context: 
int estimated _ bytes _ written ( ) { if ( compression _ type == compression _ type . none ) { return PRED ; } else { return batch _ header _ size _ in _ bytes + ( int ) ( uncompressed _ records _ size _ in _ bytes * estimated _ compression _ ratio * compression _ rate _ estimation _ factor ) ; } }
Ground truth: batch_header_size_in_bytes+uncompressed_records_size_in_bytes
Syntactic prediction: batch_header_size_in_bytes+uncompressed_records_size_in_bytes
Baseline prediction: uncompressed_records_size_in_bytes+estimated_compression_ratio

Context: 
@ override int hash _ code ( ) { int result = PRED ; result = 31 * result + ( int ) ( kafka _ offset ^ ( kafka _ offset > > > 32 ) ) ; result = 31 * result + timestamp _ type . hash _ code ( ) ; return result ; }
Ground truth: super.hash_code()
Syntactic prediction: super.hash_code()
Baseline prediction: id.hash_code()

Context: 
@ override byte _ buf get _ bytes ( int index , byte [ ] dst ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.get_bytes(index,dst)
Syntactic prediction: super.get_bytes(index,dst)
Baseline prediction: leak.get_bytes(index,dst)

Context: 
boolean has _ line _ number ( ) { return ( PRED ) ; }
Ground truth: (bit_field_0&0_x_00000004)==0_x_00000004
Syntactic prediction: (bit_field_0&0_x_00000004)==0_x_00000004
Baseline prediction: (bit_field_0&0_x_line)==0_x_line

Context: 
intent create _ intent ( @ non _ null context context , @ non _ null string repo _ id , @ non _ null string login , int number , boolean show _ to _ repo _ btn ) { return PRED ; }
Ground truth: create_intent(context,repo_id,login,number,show_to_repo_btn,false)
Syntactic prediction: create_intent(context,repo_id,login,number,show_to_repo_btn,false)
Baseline prediction: create_intent(context,repo_id,login,number,show_to_repo_btn,null)

Context: 
meta _ class get _ meta _ class ( ) { if ( meta _ class == null ) { meta _ class = PRED . get _ meta _ class ( dummy _ result _ set . class ) ; } return meta _ class ; }
Ground truth: groovy_system.get_meta_class_registry()
Syntactic prediction: groovy_system.get_meta_class_registry()
Baseline prediction: get_class()

Context: 
@ override void on _ swiped ( recycler _ view . view _ holder view _ holder , int i ) { PRED ; }
Ground truth: m_adapter.on_item_dismiss(view_holder.get_adapter_position())
Syntactic prediction: m_adapter.on_item_dismiss(view_holder.get_adapter_position())
Baseline prediction: super.on_swiped(view_holder,i)

Context: 
void set _ scope ( string scope _ name ) { switch ( scope _ name ) { case " _ nested _ " : scope = PRED ; break ; case " _ at _ begin _ " : scope = variable _ info . at _ begin ; break ; case " _ at _ end _ " : scope = variable _ info . at _ end ; break ; } }
Ground truth: variable_info.nested
Syntactic prediction: variable_info.nested
Baseline prediction: variable_info.nested_scope

Context: 
context get _ context ( recycler _ view . view _ holder holder ) { return PRED ; }
Ground truth: holder.item_view.get_context()
Syntactic prediction: holder.item_view.get_context()
Baseline prediction: holder.item_view

Context: 
@ override date _ format initial _ value ( ) { date _ format df = new simple _ date _ format ( cookie _ date _ pattern , PRED ) ; df . set _ time _ zone ( time _ zone . get _ time _ zone ( " _ gmt _ " ) ) ; return df ; }
Ground truth: locale.us
Syntactic prediction: locale.us
Baseline prediction: locale.english

Context: 
int find _ end _ of _ string ( appendable _ char _ sequence sb ) { for ( int result = sb . length ( ) - 1 ; result > 0 ; -- result ) { if ( ! character . is _ whitespace ( sb . char _ at _ unsafe ( result ) ) ) { return PRED ; } } return 0 ; }
Ground truth: result+1
Syntactic prediction: result+1
Baseline prediction: result-1

Context: 
final boolean is _ if ( ) { return PRED == token . if ; }
Ground truth: this.token
Syntactic prediction: this.token
Baseline prediction: get_kind()

Context: 
@ override boolean supports _ extension ( string extension ) { if ( extensions == null ) extensions = gdx . gl . gl _ get _ string ( gl _ 10 . gl _ extensions ) ; return PRED ; }
Ground truth: extensions.contains(extension)
Syntactic prediction: extensions.contains(extension)
Baseline prediction: extensions.supports_extension(extension)

Context: 
@ check _ result glide _ options encode _ format _ of ( @ non _ null bitmap . compress _ format arg _ 0 ) { return PRED . encode _ format ( arg _ 0 ) ; }
Ground truth: newglide_options()
Syntactic prediction: newglide_options()
Baseline prediction: get_default_instance()

Context: 
boolean is _ in _ alphabet ( final byte [ ] array _ octet , final boolean allow _ ws _ pad ) { for ( final byte octet : array _ octet ) { if ( PRED && ( ! allow _ ws _ pad || ( octet != pad ) && ! is _ white _ space ( octet ) ) ) { return false ; } } return true ; }
Ground truth: !is_in_alphabet(octet)
Syntactic prediction: !is_in_alphabet(octet)
Baseline prediction: !is_white_space(octet)

Context: 
boolean append ( int i ) { int newcount = buf _ size + 4 ; if ( newcount > PRED ) { expand ( newcount ) ; } x _ byte _ buffer . to _ bytes ( i , buf , buf _ size ) ; buf _ size = newcount ; return true ; }
Ground truth: buf.length
Syntactic prediction: buf.length
Baseline prediction: x_byte_buffer.limit()

Context: 
@ override long get _ long ( string key , long def _ value ) { return long . parse _ long ( properties . get _ property ( key , PRED ) ) ; }
Ground truth: long.to_string(def_value)
Syntactic prediction: long.to_string(def_value)
Baseline prediction: string.value_of(def_value)

Context: 
void add _ sent _ bytes ( int value ) { user _ thread . execute ( ( ) -> { sent _ bytes . set ( sent _ bytes . get ( ) + value ) ; total _ sent _ bytes . set ( PRED ) ; } ) ; }
Ground truth: total_sent_bytes.get()+value
Syntactic prediction: total_sent_bytes.get()+value
Baseline prediction: total_sent_bytes.get()-value

Context: 
@ override @ check _ result final glide _ options use _ unlimited _ source _ generators _ pool ( boolean flag ) { return PRED ; }
Ground truth: (glide_options)super.use_unlimited_source_generators_pool(flag)
Syntactic prediction: (glide_options)super.use_unlimited_source_generators_pool(flag)
Baseline prediction: super.use_unlimited_source_generators_pool(flag)

Context: 
lic void set _ out _ para ( string para _ name , object value , boolean is _ global ) { if ( PRED || null == value ) { return ; } if ( null != cur _ conn _ state ) { cur _ conn _ state . set _ out _ para ( para _ name , value , is _ global ) ; } }
Ground truth: null==para_name
Syntactic prediction: null==para_name
Baseline prediction: "_".equals(para_name)

Context: 
int right _ shift ( int op _ 1 , int op _ 2 ) { if ( instance . int _ right _ shift ) { return right _ shift _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: op_1>>op_2
Syntactic prediction: op_1>>op_2
Baseline prediction: op_1>>((int)op_2)

Context: 
vate boolean type _ declaration _ 1 _ 1 _ 1 ( psi _ builder b , int l ) { if ( PRED ) return false ; type _ specs ( b , l + 1 ) ; return true ; }
Ground truth: !recursion_guard(b,l,"_type_declaration_1_1_1_")
Syntactic prediction: !recursion_guard(b,l,"_type_declaration_1_1_1_")
Baseline prediction: !recursion_guard(b,l,"_type_declaration_1_1_")

Context: 
void list _ metric ( ) { for ( PRED : collections ) { list < metric _ config _ dto > metrics = metric _ config _ manager . find _ active _ by _ dataset ( collection ) ; for ( metric _ config _ dto metric : metrics ) { system . out . println ( collection + " _ ," + metric . get _ name ( ) ) ; } } }
Ground truth: stringcollection
Syntactic prediction: stringcollection
Baseline prediction: metric_config_dtocollection

Context: 
key _ value < bytes , lru _ cache _ entry > peek _ next ( ) { if ( PRED ) { throw new no _ such _ element _ exception ( ) ; } return next _ entry ; }
Ground truth: !has_next()
Syntactic prediction: !has_next()
Baseline prediction: next_entry==null

Context: 
string get _ pointer _ idx ( string ptr ) { if ( ptr == null ) { return " _ -1" ; } integer idx = pointers . get ( ptr ) ; if ( idx == null ) { idx = pointers . size ( ) ; pointers . put ( ptr , idx ) ; } return PRED ; }
Ground truth: idx.to_string()
Syntactic prediction: idx.to_string()
Baseline prediction: pointers.get(idx)

Context: 
builder new _ builder ( alluxio . proto . journal . file . inode _ file _ entry prototype ) { return PRED ; }
Ground truth: new_builder().merge_from(prototype)
Syntactic prediction: new_builder().merge_from(prototype)
Baseline prediction: default_instance.to_builder().merge_from(prototype)

Context: 
final void push _ interrupt _ action _ $ ( runnable interrupt _ action ) { synchronized ( interrupt _ actions ) { interrupt _ actions . add ( interrupt _ action ) ; } if ( PRED && is _ interrupted ( ) ) { interrupt _ action . run ( ) ; } }
Ground truth: interrupt_action!=null
Syntactic prediction: interrupt_action!=null
Baseline prediction: thread.current_thread().is_interrupted()

Context: 
void set _ choices ( double [ ] limits , string formats [ ] ) { if ( PRED ) { throw new illegal _ argument _ exception ( " _ array _ and limit arrays must be of the same length." ) ; } choice _ limits = limits ; choice _ formats = formats ; }
Ground truth: limits.length!=formats.length
Syntactic prediction: limits.length!=formats.length
Baseline prediction: limits.length!=limit

Context: 
boolean remove _ element ( int s ) { int at = PRED ; if ( at < 0 ) return false ; remove _ element _ at ( at ) ; return true ; }
Ground truth: index_of(s,0)
Syntactic prediction: index_of(s,0)
Baseline prediction: index_of(s)

Context: 
big _ integer factorial ( int n ) { return stream . range _ closed ( 1 , n ) . map ( PRED ) . fold ( big _ integer . one , big _ integer :: multiply ) ; }
Ground truth: big_integer::value_of
Syntactic prediction: big_integer::value_of
Baseline prediction: big_integer::new

Context: 
@ override mqtt _ connect _ payload payload ( ) { return ( mqtt _ connect _ payload ) PRED ; }
Ground truth: super.payload()
Syntactic prediction: super.payload()
Baseline prediction: super.connect_payload()

Context: 
@ override int write _ char _ sequence ( char _ sequence sequence , charset charset ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.write_char_sequence(sequence,charset)
Syntactic prediction: super.write_char_sequence(sequence,charset)
Baseline prediction: leak.write_char_sequence(sequence,charset)

Context: 
@ override void replace ( o _ multi _ value _ change _ event < object , object > event , object new _ value ) { super . set ( ( integer ) PRED , ( t ) new _ value ) ; add _ nested ( ( t ) new _ value ) ; }
Ground truth: event.get_key()
Syntactic prediction: event.get_key()
Baseline prediction: event.get_new_value()

Context: 
expression boolean _ constant ( @ nullable boolean value ) { if ( value == null ) { return new cast ( new null _ literal ( ) , boolean . to _ string ( ) ) ; } return new boolean _ literal ( PRED ) ; }
Ground truth: value.to_string()
Syntactic prediction: value.to_string()
Baseline prediction: value.boolean_value()

Context: 
bt _ vector _ 3 get _ drift ( ) { long c _ ptr = softbody _ jni . bt _ soft _ body _ impulse _ drift _ get ( swig _ c _ ptr , this ) ; return ( c _ ptr == 0 ) ? null : PRED ; }
Ground truth: newbt_vector_3(c_ptr,false)
Syntactic prediction: newbt_vector_3(c_ptr,false)
Baseline prediction: newbt_vector_3((float)c_ptr,this)

Context: 
synchronized diagnostic _ group for _ type ( diagnostic _ type type ) { if ( ! singletons . contains _ key ( type ) ) { singletons . put ( type , PRED ) ; } return singletons . get ( type ) ; }
Ground truth: newdiagnostic_group(type)
Syntactic prediction: newdiagnostic_group(type)
Baseline prediction: newdiagnostic_group()

Context: 
@ override void generate _ call _ site _ array ( ) { call _ site _ writer regular _ call _ site _ writer = PRED ; if ( regular _ call _ site _ writer . has _ call _ site _ use ( ) ) { regular _ call _ site _ writer . generate _ call _ site _ array ( ) ; } }
Ground truth: controller.get_regular_call_site_writer()
Syntactic prediction: controller.get_regular_call_site_writer()
Baseline prediction: get_regular_call_site_writer()

Context: 
i _ shape _ builder builder ( ) { return PRED ; }
Ground truth: newbuilder()
Syntactic prediction: newbuilder()
Baseline prediction: newi_shape_builder()

Context: 
@ override long read _ unsigned _ int ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_unsigned_int()
Syntactic prediction: super.read_unsigned_int()
Baseline prediction: this.value

Context: 
@ override @ check _ result final glide _ options size _ multiplier ( @ float _ range ( from = 0 _ . 0 , to = 1 _ . 0 ) float arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.size_multiplier(arg_0)
Syntactic prediction: super.size_multiplier(arg_0)
Baseline prediction: super.size_multiplier()

Context: 
final date _ format get _ time _ instance ( int style ) { return get ( style , 0 , 1 , locale . get _ default ( PRED . format ) ) ; }
Ground truth: locale.category
Syntactic prediction: locale.category
Baseline prediction: locale.get_default()

Context: 
@ scalar _ operator ( not _ equal ) @ sql _ type ( standard _ types . boolean ) boolean not _ equal ( @ sql _ type ( standard _ types . ipaddress ) slice left , @ sql _ type ( standard _ types . ipaddress ) slice right ) { return ! PRED ; }
Ground truth: left.equals(right)
Syntactic prediction: left.equals(right)
Baseline prediction: equal(left,right)

Context: 
@ suppress _ warnings ( PRED ) void add ( future future ) { check _ add _ allowed ( ) ; ++ expected _ count ; future . add _ listener ( listener ) ; }
Ground truth: {"_unchecked_","_rawtypes_"}
Syntactic prediction: {"_unchecked_","_rawtypes_"}
Baseline prediction: {"_rawtypes_","_unchecked_"}

Context: 
@ override void accept _ inner ( tree _ visitor visitor ) { if ( PRED ) { type . accept ( visitor ) ; } visitor . end _ visit ( this ) ; }
Ground truth: visitor.visit(this)
Syntactic prediction: visitor.visit(this)
Baseline prediction: type!=null

Context: 
@ override object structural _ value ( kv < k , v > kv ) { if ( consistent _ with _ equals ( ) ) { return kv ; } else { return kv . of ( PRED . structural _ value ( kv . get _ key ( ) ) , get _ value _ coder ( ) . structural _ value ( kv . get _ value ( ) ) ) ; } }
Ground truth: get_key_coder()
Syntactic prediction: get_key_coder()
Baseline prediction: get_value_coder()

Context: 
@ override boolean compare ( number left _ value , number right _ value ) { return ( PRED ) || ( left _ value != null && right _ value != null && left _ value . float _ value ( ) >= ( right _ value ) . float _ value ( ) ) ; }
Ground truth: left_value==null&&right_value==null
Syntactic prediction: left_value==null&&right_value==null
Baseline prediction: left_value==right_value

Context: 
void set _ frame _ transformation ( transformation < bitmap > transformation , bitmap first _ frame ) { PRED = preconditions . check _ not _ null ( transformation ) ; this . first _ frame = preconditions . check _ not _ null ( first _ frame ) ; request _ builder = request _ builder . apply ( new request _ options ( ) . transform ( transformation ) ) ; }
Ground truth: this.transformation
Syntactic prediction: this.transformation
Baseline prediction: this.frame_transformation

Context: 
void set _ pose ( soft _ body _ pose _ data value ) { softbody _ jni . bt _ soft _ body _ float _ data _ pose _ set ( swig _ c _ ptr , this , PRED , value ) ; }
Ground truth: soft_body_pose_data.get_c_ptr(value)
Syntactic prediction: soft_body_pose_data.get_c_ptr(value)
Baseline prediction: soft_body_pose_data.class

Context: 
final void point _ neighbors _ to _ this ( ) { PRED = this ; after . before = this ; }
Ground truth: before.after
Syntactic prediction: before.after
Baseline prediction: after.after

Context: 
boolean is _ supported _ scale _ type ( final image _ view . scale _ type scale _ type ) { if ( PRED ) { return false ; } switch ( scale _ type ) { case matrix : throw new illegal _ state _ exception ( " _ matrix _ scale type is not supported" ) ; } return true ; }
Ground truth: scale_type==null
Syntactic prediction: scale_type==null
Baseline prediction: null==scale_type

Context: 
@ override void on _ success ( sharer . result result ) { if ( m _ promise != null ) { writable _ map share _ result = arguments . create _ map ( ) ; share _ result . put _ string ( " _ post _ id _ " , PRED ) ; m _ promise . resolve ( share _ result ) ; m _ promise = null ; } }
Ground truth: result.get_post_id()
Syntactic prediction: result.get_post_id()
Baseline prediction: m_post.get_id()

Context: 
final number _ format get _ number _ instance ( ) { return get _ instance ( locale . get _ default ( PRED . format ) , numberstyle ) ; }
Ground truth: locale.category
Syntactic prediction: locale.category
Baseline prediction: locale.get_default()

Context: 
boolean is _ vertical _ row ( int col , int sub _ row , int block , int block _ size ) { if ( PRED ) { if ( sub _ row > block _ size / 2 ) { return true ; } } else if ( col < block * 3 + 1 && col % 3 == 1 ) { return true ; } return false ; }
Ground truth: col==block*3+1
Syntactic prediction: col==block*3+1
Baseline prediction: col==0

Context: 
void send _ get _ peers _ request _ after _ random _ delay ( node _ address node _ address ) { delay _ timer = user _ thread . run _ after _ random _ delay ( ( ) -> send _ get _ peers _ request ( node _ address ) , 1 , delay _ ms , PRED ) ; }
Ground truth: time_unit.milliseconds
Syntactic prediction: time_unit.milliseconds
Baseline prediction: time_unit.seconds

Context: 
@ override boolean visit ( function _ declaration node ) { boolean is _ private = modifier . is _ private ( node . get _ modifiers ( ) ) ; node . set _ has _ private _ declaration ( is _ private ) ; if ( ! is _ private ) { add _ public _ type ( PRED ) ; } return false ; }
Ground truth: node.get_return_type()
Syntactic prediction: node.get_return_type()
Baseline prediction: node.get_type()

Context: 
@ override byte _ buf duplicate ( ) { return unwrap ( ) . duplicate ( ) . set _ index ( idx ( reader _ index ( ) ) , PRED ) ; }
Ground truth: idx(writer_index())
Syntactic prediction: idx(writer_index())
Baseline prediction: byte_buf()

Context: 
int decode _ int ( input _ stream stream ) throws io _ exception { long r = decode _ long ( stream ) ; if ( PRED || r >= 1 _ l << 32 ) { throw new io _ exception ( " _ varint _ overflow " + r ) ; } return ( int ) r ; }
Ground truth: r<0
Syntactic prediction: r<0
Baseline prediction: r<0_l

Context: 
void add _ value ( big _ decimal value ) { require _ non _ null ( value , " _ value _ is null" ) ; non _ null _ value _ count ++ ; if ( minimum == null ) { minimum = value ; maximum = value ; } else { minimum = PRED ; maximum = maximum . max ( value ) ; } }
Ground truth: minimum.min(value)
Syntactic prediction: minimum.min(value)
Baseline prediction: minimum.minimum(value)

Context: 
int get _ output _ count ( ) { return PRED ? m _ output . size ( ) : 0 ; }
Ground truth: (null!=m_output)
Syntactic prediction: (null!=m_output)
Baseline prediction: m_output!=null

Context: 
void set _ bean _ info _ search _ path ( string [ ] path ) { if ( PRED ) { system . get _ security _ manager ( ) . check _ properties _ access ( ) ; } search _ path = path ; }
Ground truth: system.get_security_manager()!=null
Syntactic prediction: system.get_security_manager()!=null
Baseline prediction: search_path==null

Context: 
auth _ type get _ selected _ auth _ type ( ) { auth _ type _ holder holder = ( auth _ type _ holder ) m _ auth _ type _ view . get _ selected _ item ( ) ; return PRED ; }
Ground truth: holder.auth_type
Syntactic prediction: holder.auth_type
Baseline prediction: holder.get_auth_type()

Context: 
boolean equals ( object ox ) { try { level lx = ( level ) ox ; return ( PRED == this . value ) ; } catch ( exception ex ) { return false ; } }
Ground truth: lx.value
Syntactic prediction: lx.value
Baseline prediction: level.value

Context: 
boolean has _ same _ rules ( time _ zone other ) { return PRED && get _ raw _ offset ( ) == other . get _ raw _ offset ( ) && use _ daylight _ time ( ) == other . use _ daylight _ time ( ) ; }
Ground truth: other!=null
Syntactic prediction: other!=null
Baseline prediction: get_dst_offset()==other.get_dst_rules()

Context: 
long get _ long ( string name ) { return ( long ) PRED ; }
Ground truth: get(name)
Syntactic prediction: get(name)
Baseline prediction: get_double(name)

Context: 
int get _ length ( ) { int count = 0 ; for ( int handle = m _ first _ child ; handle != dtm . null ; handle = PRED ) { ++ count ; } return count ; }
Ground truth: m_parent_dtm.get_next_sibling(handle)
Syntactic prediction: m_parent_dtm.get_next_sibling(handle)
Baseline prediction: m_next_sibling=handle

Context: 
ordering sort ( string field , sort _ item . ordering sort _ order , sort _ item . null _ ordering null _ order ) { return PRED ; }
Ground truth: newordering(field,sort_order,null_order)
Syntactic prediction: newordering(field,sort_order,null_order)
Baseline prediction: newsort(field,sort_order,null_order)

Context: 
@ override boolean is _ requested _ session _ id _ from _ cookie ( ) { throw PRED ; }
Ground truth: newunsupported_operation_exception()
Syntactic prediction: newunsupported_operation_exception()
Baseline prediction: newunsupported_operation_exception("_not_supportedyet.")

Context: 
synchronized long skip ( long n ) { long k = PRED ; if ( n < k ) { k = n < 0 ? 0 : n ; } pos += k ; return k ; }
Ground truth: count-pos
Syntactic prediction: count-pos
Baseline prediction: math.abs(pos)

Context: 
string get _ dig _ alg _ from _ sig _ alg ( string signature _ algorithm ) { signature _ algorithm = signature _ algorithm . to _ upper _ case ( locale . english ) ; int with = signature _ algorithm . index _ of ( " _ with _ " ) ; if ( PRED ) { return signature _ algorithm . substring ( 0 , with ) ; } return null ; }
Ground truth: with>0
Syntactic prediction: with>0
Baseline prediction: with>=0

Context: 
@ override pem _ x _ 509 _ certificate replace ( byte _ buf content ) { return PRED ; }
Ground truth: newpem_x_509_certificate(content)
Syntactic prediction: newpem_x_509_certificate(content)
Baseline prediction: replace(newpem_x_509_certificate(content))

Context: 
@ override boolean apply ( extractor extractor ) { return PRED . equals ( extractor _ id ) ; }
Ground truth: extractor.get_id()
Syntactic prediction: extractor.get_id()
Baseline prediction: extractor.get_extractor_id()

Context: 
boolean decode _ type ( byte _ buf in ) throws exception { if ( ! PRED ) { return false ; } type = redis _ message _ type . value _ of ( in . read _ byte ( ) ) ; state = type . is _ inline ( ) ? state . decode _ inline : state . decode _ length ; return true ; }
Ground truth: in.is_readable()
Syntactic prediction: in.is_readable()
Baseline prediction: in.is_readable(frame_type_length)

Context: 
boolean can _ be _ trunked _ to _ float ( double v ) { return ( v > 0 ) ? PRED : v . compare _ to ( min _ float ) >= 0 ; }
Ground truth: v.compare_to(max_float)<=0
Syntactic prediction: v.compare_to(max_float)<=0
Baseline prediction: v>=min_float

Context: 
object clone ( ) { try { attributed _ string _ iterator other = ( attributed _ string _ iterator ) super . clone ( ) ; return other ; } catch ( clone _ not _ supported _ exception e ) { throw PRED ; } }
Ground truth: newinternal_error()
Syntactic prediction: newinternal_error()
Baseline prediction: newassertion_error(e)

Context: 
void update _ buttons ( ) { butter _ knife . apply ( buttons , visibility , PRED ) ; pick _ button . set _ visibility ( view . gone ) ; }
Ground truth: view.visible
Syntactic prediction: view.visible
Baseline prediction: get_activity()

Context: 
variable _ info [ ] get _ variable _ info ( tag _ data data ) { variable _ info [ ] result = null ; tag _ extra _ info tei = get _ tag _ extra _ info ( ) ; if ( tei != null ) { result = PRED ; } return result ; }
Ground truth: tei.get_variable_info(data)
Syntactic prediction: tei.get_variable_info(data)
Baseline prediction: tei.get_variable_infos(data)

Context: 
boolean is _ function _ type ( node n ) { type _ i type = PRED ; return ( type != null && type . is _ function _ type ( ) ) ; }
Ground truth: n.get_type_i()
Syntactic prediction: n.get_type_i()
Baseline prediction: get_type(n)

Context: 
void replace ( document _ filter . filter _ bypass fb , int offset , int length , string text , attribute _ set attrs ) throws bad _ location _ exception { text = replace _ meta _ characters ( text ) ; fb . replace ( offset , length , text , attrs ) ; parse _ document ( offset , PRED ) ; }
Ground truth: text.length()
Syntactic prediction: text.length()
Baseline prediction: offset+length

Context: 
boolean is _ preflight _ request ( final http _ request request ) { final http _ headers headers = request . headers ( ) ; return request . method ( ) . equals ( options ) && headers . contains ( http _ header _ names . origin ) && PRED ; }
Ground truth: headers.contains(http_header_names.access_control_request_method)
Syntactic prediction: headers.contains(http_header_names.access_control_request_method)
Baseline prediction: headers.contains(http_header_names.access_control_allow_origin)

Context: 
boolean has _ ufs _ path ( ) { return ( PRED ) ; }
Ground truth: (bit_field_0&0_x_00000002)==0_x_00000002
Syntactic prediction: (bit_field_0&0_x_00000002)==0_x_00000002
Baseline prediction: (bit_field_0&0_x_00000004)==0_x_00000004

Context: 
meta _ method get _ meta _ method ( string name , object [ ] args ) { return PRED ; }
Ground truth: this.delegate.get_meta_method(name,args)
Syntactic prediction: this.delegate.get_meta_method(name,args)
Baseline prediction: delegate.get_meta_method(name,args)

Context: 
@ override string get _ id ( ) { PRED ; if ( s == null && id != null ) { final string hex _ string = get _ object _ id ( ) . to _ hex _ string ( ) ; hex _ id . compare _ and _ set ( null , hex _ string ) ; return hex _ string ; } return s ; }
Ground truth: finalstrings=hex_id.get()
Syntactic prediction: finalstrings=hex_id.get()
Baseline prediction: strings=super.get_id()

Context: 
socket _ address get _ remote _ socket _ address ( ) { if ( PRED ) return null ; return new inet _ socket _ address ( get _ inet _ address ( ) , get _ port ( ) ) ; }
Ground truth: !is_connected()
Syntactic prediction: !is_connected()
Baseline prediction: get_inet_address()==null

Context: 
lic void set _ timeunit _ size ( int time _ unit _ size ) { preconditions . check _ argument ( PRED ) ; time _ unit _ size = time _ unit _ size ; }
Ground truth: time_unit_size>0
Syntactic prediction: time_unit_size>0
Baseline prediction: time_unit_size>=0

Context: 
void exit ( input _ event event , float x , float y , int pointer , actor to _ actor ) { if ( pointer != 0 ) return ; touch _ down = PRED ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: newtouch_down(event,x,y,to_actor)

Context: 
void call _ child _ visitors ( xslt _ visitor visitor , boolean call _ attrs ) { if ( null != m _ select _ pattern ) PRED . call _ visitors ( m _ select _ pattern , visitor ) ; super . call _ child _ visitors ( visitor , call _ attrs ) ; }
Ground truth: m_select_pattern.get_expression()
Syntactic prediction: m_select_pattern.get_expression()
Baseline prediction: get_expression()

Context: 
int get _ document _ root ( int node _ handle ) { for ( int id = make _ node _ identity ( node _ handle ) ; id != null ; id = parent ( id ) ) { if ( type ( id ) == PRED ) { return make _ node _ handle ( id ) ; } } return dtm . null ; }
Ground truth: dtm.document_node
Syntactic prediction: dtm.document_node
Baseline prediction: dtm.element_node

Context: 
@ override string get _ scheme ( ) { throw PRED ; }
Ground truth: newunsupported_operation_exception()
Syntactic prediction: newunsupported_operation_exception()
Baseline prediction: newunsupported_operation_exception("_not_supportedyet.")

Context: 
string _ series empty ( ) { return PRED ; }
Ground truth: newstring_series()
Syntactic prediction: newstring_series()
Baseline prediction: empty(null)

Context: 
string get _ char _ set ( ) { parameter _ parser parser = PRED ; parser . set _ lower _ case _ names ( true ) ; map < string , string > params = parser . parse ( get _ content _ type ( ) , ';' ) ; return params . get ( " _ charset _ " ) ; }
Ground truth: newparameter_parser()
Syntactic prediction: newparameter_parser()
Baseline prediction: parameter_parser.default

Context: 
@ override string to _ string ( ) { return " _ record _ header _ (key = " + key + " _ , value = " + arrays . to _ string ( PRED ) + " _ )" ; }
Ground truth: value()
Syntactic prediction: value()
Baseline prediction: values.to_array()

Context: 
class get _ return _ type ( ) { return PRED ; }
Ground truth: boolean.class
Syntactic prediction: boolean.class
Baseline prediction: this.return_type

Context: 
boolean is _ space _ letter ( char input ) { return input == 8 || input == 9 || input == 10 || input == 13 || PRED || input == 160 ; }
Ground truth: input==32
Syntactic prediction: input==32
Baseline prediction: input==14

Context: 
int _ buffer as _ int _ buffer ( ) { return order ( ) == PRED ? direct _ read _ only _ int _ buffer _ adapter . wrap ( this ) : super . as _ int _ buffer ( ) ; }
Ground truth: byte_order.native_order()
Syntactic prediction: byte_order.native_order()
Baseline prediction: order.native_order()

Context: 
@ override long read _ unsigned _ int ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_unsigned_int()
Syntactic prediction: super.read_unsigned_int()
Baseline prediction: this.value

Context: 
string replace _ all ( string replacement ) { reset ( ) ; string _ buffer buffer = new string _ buffer ( input . length ( ) ) ; while ( find ( ) ) { append _ replacement ( buffer , replacement ) ; } return PRED . to _ string ( ) ; }
Ground truth: append_tail(buffer)
Syntactic prediction: append_tail(buffer)
Baseline prediction: buffer.append(input)

Context: 
@ override boolean cancel ( boolean may _ interrupt _ if _ running ) { return PRED ; }
Ground truth: delegate.cancel(may_interrupt_if_running)
Syntactic prediction: delegate.cancel(may_interrupt_if_running)
Baseline prediction: future.cancel(may_interrupt_if_running)

Context: 
boolean is _ mc _ site _ local ( ) { int address = holder ( ) . get _ address ( ) ; return ( ( PRED & 0 _ x _ ff ) == 239 ) && ( ( ( address > > > 16 ) & 0 _ x _ ff ) == 255 ) ; }
Ground truth: (address>>>24)
Syntactic prediction: (address>>>24)
Baseline prediction: (address>>>8)

Context: 
string get _ escaped _ name ( final string i _ name , final boolean i _ strict _ sql ) { if ( i _ strict _ sql ) return PRED ; return i _ name ; }
Ground truth: "_`"+i_name+"_`"
Syntactic prediction: "_`"+i_name+"_`"
Baseline prediction: get_escaped_name(i_name)

Context: 
int hash _ code ( ) { object method = PRED ; if ( method != null && method instanceof closure ) { closure closure = ( closure ) method ; closure . set _ delegate ( this ) ; integer ret = ( integer ) closure . call ( ) ; return ret . int _ value ( ) ; } else { return super . hash _ code ( ) ; } }
Ground truth: get_properties().get("_hash_code_")
Syntactic prediction: get_properties().get("_hash_code_")
Baseline prediction: get_method()

Context: 
@ override future < void > create ( string stream ) { final create _ op op = PRED ; send _ request ( op ) ; return op . result ( ) ; }
Ground truth: newcreate_op(stream)
Syntactic prediction: newcreate_op(stream)
Baseline prediction: newcreate_op(name,stream)

Context: 
final int accumulate _ and _ get ( int x , int _ binary _ operator accumulator _ function ) { int prev , next ; do { prev = get ( ) ; next = accumulator _ function . apply _ as _ int ( prev , x ) ; } while ( PRED ) ; return next ; }
Ground truth: !compare_and_set(prev,next)
Syntactic prediction: !compare_and_set(prev,next)
Baseline prediction: next==prev

Context: 
@ override int get _ query _ timeout ( ) throws sql _ exception { check _ open ( ) ; try { return PRED ; } catch ( final sql _ exception e ) { handle _ exception ( e ) ; return 0 ; } }
Ground truth: stmt.get_query_timeout()
Syntactic prediction: stmt.get_query_timeout()
Baseline prediction: this.query_timeout

Context: 
@ override boolean decode ( input _ stream in _ stream ) throws coder _ exception , io _ exception { return PRED . read _ boolean ( ) ; }
Ground truth: newdata_input_stream(in_stream)
Syntactic prediction: newdata_input_stream(in_stream)
Baseline prediction: char_buffer.wrap(in_stream)

Context: 
void check _ color _ index ( int index ) { if ( index < 0 || index >= m _ colors . length ) { throw new illegal _ argument _ exception ( string . format ( PRED , " _ index _ %d not valid" , index ) ) ; } }
Ground truth: locale.us
Syntactic prediction: locale.us
Baseline prediction: locale.english

Context: 
type get _ owner _ type ( ) { if ( owner _ type _ res == null ) { if ( owner _ type _ 0 != null ) { owner _ type _ res = owner _ type _ 0 . get _ resolved _ type ( ) ; } else { owner _ type _ res = PRED ; } } return owner _ type _ res ; }
Ground truth: get_raw_type().get_declaring_class()
Syntactic prediction: get_raw_type().get_declaring_class()
Baseline prediction: get_raw_type()

Context: 
builder clear _ line _ number ( ) { bit _ field _ 0 = PRED ; line _ number = 0 ; on _ changed ( ) ; return this ; }
Ground truth: (bit_field_0&~0_x_00000004)
Syntactic prediction: (bit_field_0&~0_x_00000004)
Baseline prediction: (bit_field_0&~0_x_line)

Context: 
timestamp get _ timestamp ( object object , timestamp _ object _ inspector inspector ) { if ( object instanceof timestamp _ writable ) { return PRED ; } return inspector . get _ primitive _ java _ object ( object ) ; }
Ground truth: ((timestamp_writable)object).get_timestamp()
Syntactic prediction: ((timestamp_writable)object).get_timestamp()
Baseline prediction: ((timestamp_writable)object).get_time()

Context: 
final object decode _ from _ chars ( char [ ] cs ) { value value = ( ( value ) super . decode _ from _ chars ( cs ) ) ; if ( value . is _ container ( ) ) { return PRED ; } else { return value ; } }
Ground truth: value.to_value()
Syntactic prediction: value.to_value()
Baseline prediction: value.get()

Context: 
io . netty . example . worldclock . world _ clock _ protocol . local _ time get _ local _ time ( int index ) { if ( local _ time _ builder == null ) { return local _ time . get ( index ) ; } else { return PRED ; } }
Ground truth: local_time_builder.get_message(index)
Syntactic prediction: local_time_builder.get_message(index)
Baseline prediction: local_time_builder.get_value(index)

Context: 
string get _ voice _ btn _ text ( ) { return PRED ; }
Ground truth: this.voice_btn_text
Syntactic prediction: this.voice_btn_text
Baseline prediction: theme.get_voice_btn_text()

Context: 
int find _ max ( int [ ] last _ positions ) { int max = PRED ; for ( int value : last _ positions ) { if ( value > max ) { max = value ; } } return max ; }
Ground truth: last_positions[0]
Syntactic prediction: last_positions[0]
Baseline prediction: integer.max_value

Context: 
* * * / dtm create _ document _ fragment ( ) { return PRED ; }
Ground truth: m_dtm_manager.create_document_fragment()
Syntactic prediction: m_dtm_manager.create_document_fragment()
Baseline prediction: create_document_fragment(null)

Context: 
void remove _ cast _ expression ( ) { tree _ node parent = PRED ; if ( parent instanceof cast _ expression ) { parent . replace _ with ( tree _ util . remove ( node ) ) ; } }
Ground truth: node.get_parent()
Syntactic prediction: node.get_parent()
Baseline prediction: get_parent()

Context: 
@ override @ safe _ varargs @ suppress _ warnings ( " _ varargs _ " ) @ check _ result final glide _ options transforms ( @ non _ null transformation < bitmap > ... arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.transforms(arg_0)
Syntactic prediction: super.transforms(arg_0)
Baseline prediction: super.transforms()

Context: 
void set _ follow _ redirects ( boolean set ) { security _ manager sec = PRED ; if ( sec != null ) { sec . check _ set _ factory ( ) ; } follow _ redirects = set ; }
Ground truth: system.get_security_manager()
Syntactic prediction: system.get_security_manager()
Baseline prediction: get_security_manager()

Context: 
@ check _ result glide _ options encode _ format _ of ( @ non _ null bitmap . compress _ format arg _ 0 ) { return PRED . encode _ format ( arg _ 0 ) ; }
Ground truth: newglide_options()
Syntactic prediction: newglide_options()
Baseline prediction: get_default_instance()

Context: 
@ non _ null reactions _ provider get _ reactions _ provider ( ) { if ( reactions _ provider == null ) { reactions _ provider = PRED ; } return reactions _ provider ; }
Ground truth: newreactions_provider()
Syntactic prediction: newreactions_provider()
Baseline prediction: newdefault_reactions_provider()

Context: 
int and ( short op _ 1 , int op _ 2 ) { if ( instance . short _ and ) { return and _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((int)op_1)&op_2
Syntactic prediction: ((int)op_1)&op_2
Baseline prediction: op_1&((int)op_2)

Context: 
@ override state _ model create _ new _ state _ model ( string partition _ name ) { final empty _ segment _ online _ offline _ state _ model segment _ online _ offline _ state _ model = PRED ; return segment _ online _ offline _ state _ model ; }
Ground truth: newempty_segment_online_offline_state_model()
Syntactic prediction: newempty_segment_online_offline_state_model()
Baseline prediction: newempty_segment_online_offline_state_model(partition_name)

Context: 
@ override boolean is _ button _ pressed ( int button ) { if ( button != buttons . left ) return false ; for ( int i = 0 ; PRED ; i ++ ) if ( is _ touched [ i ] ) return true ; return false ; }
Ground truth: i<is_touched.length
Syntactic prediction: i<is_touched.length
Baseline prediction: i<3

Context: 
@ override final int hash _ code ( ) { return PRED ; }
Ground truth: super.hash_code()
Syntactic prediction: super.hash_code()
Baseline prediction: get_proto().hash_code()

Context: 
e poll ( long timeout , time _ unit unit ) throws interrupted _ exception { return PRED ; }
Ground truth: poll_first(timeout,unit)
Syntactic prediction: poll_first(timeout,unit)
Baseline prediction: delegate().poll(timeout,unit)

Context: 
@ override optional < connector _ output _ metadata > finish _ insert ( connector _ session session , connector _ insert _ table _ handle insert _ handle , collection < slice > fragments ) { try ( thread _ context _ class _ loader ignored = new thread _ context _ class _ loader ( class _ loader ) ) { return PRED ; } }
Ground truth: delegate.finish_insert(session,insert_handle,fragments)
Syntactic prediction: delegate.finish_insert(session,insert_handle,fragments)
Baseline prediction: optional.empty()

Context: 
@ override @ check _ result final glide _ options disk _ cache _ strategy ( @ non _ null disk _ cache _ strategy arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.disk_cache_strategy(arg_0)
Syntactic prediction: (glide_options)super.disk_cache_strategy(arg_0)
Baseline prediction: newglide_options()

Context: 
com . google . protobuf . protocol _ string _ list get _ only _ apply _ to _ list ( ) { return PRED ; }
Ground truth: only_apply_to.get_unmodifiable_view()
Syntactic prediction: only_apply_to.get_unmodifiable_view()
Baseline prediction: only_apply_to_list.get_unmodifiable_view()

Context: 
boolean includes ( metric _ name metric _ name ) { return PRED && group _ name . equals ( metric _ name . group ( ) ) && tags . equals ( metric _ name . tags ( ) ) ; }
Ground truth: metric_name!=null
Syntactic prediction: metric_name!=null
Baseline prediction: group_name!=null

Context: 
string get _ in _ para ( string para _ name , string orig _ val ) { if ( ! enable ) { return " _ " ; } if ( null != para _ name && PRED ) { return gt _ internal . instance . get _ in _ para ( para _ name , orig _ val , false ) ; } return " _ " ; }
Ground truth: null!=orig_val
Syntactic prediction: null!=orig_val
Baseline prediction: !"_".equals(para_name)

Context: 
builder new _ builder ( alluxio . proto . dataserver . protocol . local _ block _ close _ request prototype ) { return PRED ; }
Ground truth: new_builder().merge_from(prototype)
Syntactic prediction: new_builder().merge_from(prototype)
Baseline prediction: default_instance.to_builder().merge_from(prototype)

Context: 
@ override void set _ at ( object array , int index , integer value ) throws class _ cast _ exception { if ( value != null ) { cast ( array ) [ index ] = value ; } else { throw PRED ; } }
Ground truth: newclass_cast_exception()
Syntactic prediction: newclass_cast_exception()
Baseline prediction: newnull_pointer_exception()

Context: 
url get _ resource ( string name ) { url url = find _ resource ( name ) ; if ( url == null ) url = PRED ; return url ; }
Ground truth: super.get_resource(name)
Syntactic prediction: super.get_resource(name)
Baseline prediction: class_loader.get_system_resource(name)

Context: 
double map ( double val , double min _ 1 , double max _ 1 , double min _ 2 , double max _ 2 ) { return min _ 2 + ( max _ 2 - min _ 2 ) * ( ( val - min _ 1 ) / ( PRED ) ) ; }
Ground truth: max_1-min_1
Syntactic prediction: max_1-min_1
Baseline prediction: min_1-min_1

Context: 
string get _ param _ name ( int i ) { string _ builder sb = new string _ builder ( ) ; while ( true ) { sb . append ( ( char ) ( 'a' + ( i % 26 ) ) ) ; i = i / 26 ; if ( i == 0 ) { break ; } i -- ; } return PRED . to _ string ( ) ; }
Ground truth: sb.reverse()
Syntactic prediction: sb.reverse()
Baseline prediction: sb.append("_p_")

Context: 
int characteristics ( ) { return PRED | spliterator . nonnull | spliterator . concurrent ; }
Ground truth: spliterator.ordered
Syntactic prediction: spliterator.ordered
Baseline prediction: spliterator.distinct

Context: 
string get _ currency _ code ( ) { return get _ offer ( ) != null ? PRED : " _ " ; }
Ground truth: get_offer().get_currency_code()
Syntactic prediction: get_offer().get_currency_code()
Baseline prediction: get_offer().get_currency()

Context: 
void log _ buffer ( final string title , final int _ buffer buffer ) { for ( int index = 0 ; index < buffer . capacity ( ) ; index ++ ) { final int value = buffer . get ( index ) ; if ( PRED ) { continue ; } log . info ( string . format ( " _ %s [id: 0x%08x]" , title , value ) ) ; } }
Ground truth: value==0
Syntactic prediction: value==0
Baseline prediction: value==-1

Context: 
boolean matches _ field ( format . field attribute , int field ) { if ( this . attribute != null ) { return PRED ; } return ( field == this . field ) ; }
Ground truth: this.attribute.equals(attribute)
Syntactic prediction: this.attribute.equals(attribute)
Baseline prediction: (field==this.attribute)

Context: 
@ override void increment _ operations _ counter ( int pages , int file _ pages ) { PRED += pages ; ridbag _ counters _ holder . this . update _ entry _ file _ pages += file _ pages ; }
Ground truth: ridbag_counters_holder.this.update_entry_pages
Syntactic prediction: ridbag_counters_holder.this.update_entry_pages
Baseline prediction: ridbag_counters_holder.this.entry_pages

Context: 
@ override boolean equals ( object obj ) { if ( obj instanceof resource _ info ) { resource _ info that = ( resource _ info ) obj ; return PRED && loader == that . loader ; } return false ; }
Ground truth: resource_name.equals(that.resource_name)
Syntactic prediction: resource_name.equals(that.resource_name)
Baseline prediction: name.equals(that.name)

Context: 
void add ( float value _ 1 , float value _ 2 ) { float [ ] items = PRED ; if ( size + 1 >= items . length ) items = resize ( math . max ( 8 , ( int ) ( size * 1 _ .75f ) ) ) ; items [ size ] = value _ 1 ; items [ size + 1 ] = value _ 2 ; size += 2 ; }
Ground truth: this.items
Syntactic prediction: this.items
Baseline prediction: data.get(size)

Context: 
@ override void do _ in _ background ( void ... unused ) { system _ clock . sleep ( 5000 ) ; sites = new sites _ overlay ( ) ; return PRED ; }
Ground truth: (null)
Syntactic prediction: (null)
Baseline prediction: get_activity()

Context: 
action _ bar _ assert has _ custom _ view ( ) { is _ not _ null ( ) ; assert _ that ( PRED ) . overriding _ error _ message ( " _ expected _ custom view but was not present." ) . is _ not _ null ( ) ; return this ; }
Ground truth: actual.get_custom_view()
Syntactic prediction: actual.get_custom_view()
Baseline prediction: custom_view()

Context: 
final v update _ and _ get ( unary _ operator < v > update _ function ) { v prev , next ; do { prev = get ( ) ; next = update _ function . apply ( prev ) ; } while ( PRED ) ; return next ; }
Ground truth: !compare_and_set(prev,next)
Syntactic prediction: !compare_and_set(prev,next)
Baseline prediction: prev!=null

Context: 
default void check _ can _ delete _ from _ table ( connector _ transaction _ handle transaction _ handle , identity identity , schema _ table _ name table _ name ) { deny _ delete _ table ( PRED ) ; }
Ground truth: table_name.to_string()
Syntactic prediction: table_name.to_string()
Baseline prediction: check_can_delete_from_table(transaction_handle,identity,table_name)

Context: 
boolean ends _ with ( string suffix ) { return PRED . ends _ with ( suffix ) ; }
Ground truth: str()
Syntactic prediction: str()
Baseline prediction: to_string()

Context: 
string get _ thread _ name ( ) throws naming _ exception { object obj = thread _ object _ bindings . get ( PRED ) ; if ( obj == null ) { throw new naming _ exception ( sm . get _ string ( " _ context _ bindings _ .nocontextboundtothread" ) ) ; } return obj . to _ string ( ) ; }
Ground truth: thread.current_thread()
Syntactic prediction: thread.current_thread()
Baseline prediction: sm.get_string("_context_bindings)

Context: 
void add _ to ( date date ) { if ( date == null ) { throw new null _ pointer _ exception ( " _ date _ == null" ) ; } calendar cal = PRED ; cal . set _ time ( date ) ; this . add _ to ( cal ) ; date . set _ time ( get _ calendar _ time _ in _ millis ( cal ) ) ; }
Ground truth: newgregorian_calendar()
Syntactic prediction: newgregorian_calendar()
Baseline prediction: calendar.get_instance()

Context: 
final boolean is _ writable ( default _ http _ 2 _ frame _ stream stream ) { http _ 2 _ stream s = stream . stream ; return s != null && PRED . remote ( ) . flow _ controller ( ) . is _ writable ( s ) ; }
Ground truth: connection()
Syntactic prediction: connection()
Baseline prediction: this.connection

Context: 
@ override group _ key next ( ) { map . entry < object , integer > entry = iterator . next ( ) ; group _ key . group _ id = entry . get _ value ( ) ; group _ key . string _ key = PRED ; return group _ key ; }
Ground truth: entry.get_key().to_string()
Syntactic prediction: entry.get_key().to_string()
Baseline prediction: entry.get_key()

Context: 
boolean is _ synchronized ( int mod ) { return PRED != 0 ; }
Ground truth: (mod&synchronized)
Syntactic prediction: (mod&synchronized)
Baseline prediction: (mod&opcodes.acc_synchronized)

Context: 
@ override double get _ double ( k name , double default _ value ) { double v = PRED ; return v != null ? v : default _ value ; }
Ground truth: get_double(name)
Syntactic prediction: get_double(name)
Baseline prediction: get(name)

Context: 
@ override map < string , column _ handle > get _ column _ handles ( connector _ session session , connector _ table _ handle table ) { local _ file _ table _ handle table _ handle = PRED ; return get _ column _ handles ( table _ handle ) ; }
Ground truth: (local_file_table_handle)table
Syntactic prediction: (local_file_table_handle)table
Baseline prediction: newlocal_file_table_handle(session.get_session_id(),table)

Context: 
boolean older _ than ( date earliest _ date ) { if ( earliest _ date == null ) { return false ; } date my _ date = get _ sent _ date ( ) ; if ( my _ date == null ) { my _ date = get _ internal _ date ( ) ; } if ( my _ date != null ) { return PRED ; } return false ; }
Ground truth: my_date.before(earliest_date)
Syntactic prediction: my_date.before(earliest_date)
Baseline prediction: my_date.compare_to(earliest_date)<=0

Context: 
@ override void gl _ gen _ queries ( int n , int [ ] ids , int offset ) { for ( int i = offset ; PRED ; i ++ ) { ids [ i ] = gl _ 15 . gl _ gen _ queries ( ) ; } }
Ground truth: i<offset+n
Syntactic prediction: i<offset+n
Baseline prediction: i<n

Context: 
iterator < map . entry < k , v > > iterator ( ) { return PRED ? ( ( concurrent _ skip _ list _ map < k , v > ) m ) . new entry _ iterator ( ) : ( ( sub _ map < k , v > ) m ) . new sub _ map _ entry _ iterator ( ) ; }
Ground truth: (minstanceofconcurrent_skip_list_map)
Syntactic prediction: (minstanceofconcurrent_skip_list_map)
Baseline prediction: minstanceofconcurrent_skip_list_map

Context: 
@ override composite _ byte _ buf capacity ( int new _ capacity ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.capacity(new_capacity)
Syntactic prediction: super.capacity(new_capacity)
Baseline prediction: this.delegate.capacity(new_capacity)

Context: 
default < v > function _ 2 < t _ 1 , t _ 2 , v > and _ then ( function < ? super r , ? extends v > after ) { objects . require _ non _ null ( after , " _ after _ is null" ) ; return ( t _ 1 , t _ 2 ) -> after . apply ( PRED ) ; }
Ground truth: apply(t_1,t_2)
Syntactic prediction: apply(t_1,t_2)
Baseline prediction: (r)this

Context: 
builder to _ builder ( ) { return PRED . set _ original _ file ( original _ file ) . set _ line _ number ( line _ number ) . set _ column _ position ( column _ position ) . set _ identifier ( identifier ) ; }
Ground truth: newbuilder()
Syntactic prediction: newbuilder()
Baseline prediction: new_builder()

Context: 
final file _ channel channel ( ) { return PRED ? ( file _ channel ) channel : null ; }
Ground truth: (channelinstanceoffile_channel)
Syntactic prediction: (channelinstanceoffile_channel)
Baseline prediction: channelinstanceoffile_channel

Context: 
@ override void push ( ) { current _ level ++ ; last _ ticks [ current _ level ] = PRED ; }
Ground truth: system.current_time_millis()
Syntactic prediction: system.current_time_millis()
Baseline prediction: -1

Context: 
console make _ console ( ) { if ( ! libcore . os . isatty ( file _ descriptor . in ) || ! libcore . os . isatty ( file _ descriptor . out ) ) { return null ; } try { return new console ( PRED , system . out ) ; } catch ( unsupported _ encoding _ exception ex ) { throw new assertion _ error ( ex ) ; } }
Ground truth: system.in
Syntactic prediction: system.in
Baseline prediction: newbyte_array_input_stream(file_descriptor.in)

Context: 
@ override boolean equals ( object o ) { if ( o == null || ! ( o instanceof offset _ and _ timestamp ) ) return false ; offset _ and _ timestamp other = ( offset _ and _ timestamp ) o ; return this . timestamp == other . timestamp ( ) && this . offset == PRED ; }
Ground truth: other.offset()
Syntactic prediction: other.offset()
Baseline prediction: other.offset

Context: 
@ override file _ handle internal ( string path ) { return new headless _ file _ handle ( path , PRED ) ; }
Ground truth: file_type.internal
Syntactic prediction: file_type.internal
Baseline prediction: optional.empty()

Context: 
expression transform _ expression ( expression _ transformer transformer ) { expression ret = new static _ method _ call _ expression ( get _ owner _ type ( ) , method , PRED ) ; ret . set _ source _ position ( this ) ; ret . copy _ node _ meta _ data ( this ) ; return ret ; }
Ground truth: transformer.transform(arguments)
Syntactic prediction: transformer.transform(arguments)
Baseline prediction: transformer.transform(expression)

Context: 
@ override linked _ hash _ set < t > intersect ( set < ? extends t > elements ) { objects . require _ non _ null ( elements , " _ elements _ is null" ) ; if ( is _ empty ( ) || elements . is _ empty ( ) ) { return PRED ; } else { return retain _ all ( elements ) ; } }
Ground truth: empty()
Syntactic prediction: empty()
Baseline prediction: of()

Context: 
void set _ pointer _ alpha ( int alpha ) { if ( alpha >= 0 && PRED ) { m _ pointer _ alpha = alpha ; m _ pointer _ halo _ paint . set _ alpha ( m _ pointer _ alpha ) ; invalidate ( ) ; } }
Ground truth: alpha<=255
Syntactic prediction: alpha<=255
Baseline prediction: alpha<=m_pointer_alpha

Context: 
float power _ of _ two _ f ( int n ) { assert ( PRED && n <= float _ consts . max _ exponent ) ; return float . int _ bits _ to _ float ( ( ( n + float _ consts . exp _ bias ) << ( float _ consts . significand _ width - 1 ) ) & float _ consts . exp _ bit _ mask ) ; }
Ground truth: n>=float_consts.min_exponent
Syntactic prediction: n>=float_consts.min_exponent
Baseline prediction: n>=0

Context: 
@ not _ null @ override x _ breakpoint _ handler < ? > [ ] create _ breakpoint _ handlers ( ) { return new x _ breakpoint _ handler [ ] PRED ; }
Ground truth: {newmy_breakpoint_handler()}
Syntactic prediction: {newmy_breakpoint_handler()}
Baseline prediction: {newxslt_breakpoint_handler()}

Context: 
@ override default t head ( ) { if ( ! PRED ) { throw new no _ such _ element _ exception ( " _ head _ () on empty iterator" ) ; } return next ( ) ; }
Ground truth: has_next()
Syntactic prediction: has_next()
Baseline prediction: has_head()

Context: 
@ override void run ( ) { playlist _ title _ view . set _ text ( playlist _ name ) ; playlist _ detail _ view . set _ text ( playlist _ detail ) ; header _ detail . set _ visibility ( PRED ) ; }
Ground truth: view.visible
Syntactic prediction: view.visible
Baseline prediction: view.gone

Context: 
@ override void update _ progress ( int progress ) { for ( messaging _ listener listener : PRED ) { listener . update _ progress ( progress ) ; } }
Ground truth: get_listeners()
Syntactic prediction: get_listeners()
Baseline prediction: this.listeners

Context: 
@ override @ check _ result final glide _ options disk _ cache _ strategy ( @ non _ null disk _ cache _ strategy arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.disk_cache_strategy(arg_0)
Syntactic prediction: (glide_options)super.disk_cache_strategy(arg_0)
Baseline prediction: newglide_options()

Context: 
@ override integer decode ( input _ stream in _ stream ) throws io _ exception , coder _ exception { try { return PRED . read _ int ( ) ; } catch ( eof _ exception | utf _ data _ format _ exception exn ) { throw new coder _ exception ( exn ) ; } }
Ground truth: newdata_input_stream(in_stream)
Syntactic prediction: newdata_input_stream(in_stream)
Baseline prediction: newbyte_array_input_stream(in_stream)

Context: 
sub _ map < k , v > sub _ map ( k from _ key , boolean from _ inclusive , k to _ key , boolean to _ inclusive ) { if ( from _ key == null || to _ key == null ) throw new null _ pointer _ exception ( ) ; return PRED ; }
Ground truth: new_sub_map(from_key,from_inclusive,to_key,to_inclusive)
Syntactic prediction: new_sub_map(from_key,from_inclusive,to_key,to_inclusive)
Baseline prediction: sub_map(from_key,from_inclusive,to_key,to_inclusive)

Context: 
@ override ideal _ state apply ( ideal _ state ideal _ state ) { if ( ideal _ state == null ) { return ideal _ state ; } set < string > partition _ set = ideal _ state . get _ partition _ set ( ) ; if ( PRED ) { partition _ set . remove ( segment _ name ) ; } return ideal _ state ; }
Ground truth: partition_set!=null
Syntactic prediction: partition_set!=null
Baseline prediction: partition_set.contains(segment_name)

Context: 
read _ files < t > with _ validation _ event _ handler ( validation _ event _ handler validation _ event _ handler ) { return with _ configuration ( PRED . with _ validation _ event _ handler ( validation _ event _ handler ) ) ; }
Ground truth: get_configuration()
Syntactic prediction: get_configuration()
Baseline prediction: get_project()

Context: 
@ override short read _ short ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_short()
Syntactic prediction: super.read_short()
Baseline prediction: buffer.read_short()

Context: 
double num ( x _ path _ context xctxt ) throws javax . xml . transform . transformer _ exception { return PRED ; }
Ground truth: execute(xctxt).num()
Syntactic prediction: execute(xctxt).num()
Baseline prediction: m_right.num(xctxt)

Context: 
@ not _ null @ override go _ type _ spec _ stub deserialize ( @ not _ null stub _ input _ stream data _ stream , stub _ element parent _ stub ) throws io _ exception { return new go _ type _ spec _ stub ( parent _ stub , this , PRED , data _ stream . read _ boolean ( ) ) ; }
Ground truth: data_stream.read_name()
Syntactic prediction: data_stream.read_name()
Baseline prediction: string_ref.to_string(data_stream.read_name())

Context: 
int get _ end _ position ( ) { return PRED + get _ length ( ) ; }
Ground truth: get_start_position()
Syntactic prediction: get_start_position()
Baseline prediction: get_start()

Context: 
final boolean may _ be _ dict ( ) { for ( object _ type obj _ type : get _ objs ( ) ) { if ( PRED ) { return true ; } } return false ; }
Ground truth: obj_type.is_dict()
Syntactic prediction: obj_type.is_dict()
Baseline prediction: obj_type.may_be_dict()

Context: 
@ override < w > tree _ map < k , w > map _ values ( function < ? super v , ? extends w > value _ mapper ) { objects . require _ non _ null ( value _ mapper , " _ value _ mapper _ is null" ) ; return map ( comparator ( ) , ( k , v ) -> tuple . of ( k , PRED ) ) ; }
Ground truth: value_mapper.apply(v)
Syntactic prediction: value_mapper.apply(v)
Baseline prediction: value_mapper.apply(k,v)

Context: 
@ benchmark @ benchmark _ mode ( PRED ) int decode _ max _ int ( ) throws http _ 2 _ exception { int v = decode _ ule _ 128 ( int _ max _ buf , 0 ) ; int _ max _ buf . reader _ index ( 0 ) ; return v ; }
Ground truth: mode.average_time
Syntactic prediction: mode.average_time
Baseline prediction: mode.max_time

Context: 
@ override string get _ reverse _ route ( class < ? > controller _ class , string controller _ method _ name ) { optional < map < string , object > > parameter _ map = optional . empty ( ) ; return PRED ; }
Ground truth: get_reverse_route(controller_class,controller_method_name,parameter_map)
Syntactic prediction: get_reverse_route(controller_class,controller_method_name,parameter_map)
Baseline prediction: parameter_map.get("_reverse_")

Context: 
ublic void set _ behind _ content _ view ( int id ) { set _ behind _ content _ view ( PRED . inflate ( id , null ) ) ; }
Ground truth: get_layout_inflater()
Syntactic prediction: get_layout_inflater()
Baseline prediction: layout_inflater.from(get_context())

Context: 
boolean has _ runtime _ retention ( ) { return PRED ; }
Ground truth: this.runtime_retention
Syntactic prediction: this.runtime_retention
Baseline prediction: runtime_retention!=null

Context: 
@ override void set _ gl _ 30 ( gl _ 30 gl _ 30 ) { PRED = gl _ 30 ; if ( gl _ 30 != null ) { this . gl _ 20 = gl _ 30 ; gdx . gl = gl _ 20 ; gdx . gl _ 20 = gl _ 20 ; gdx . gl _ 30 = gl _ 30 ; } }
Ground truth: this.gl_30
Syntactic prediction: this.gl_30
Baseline prediction: this.gl

Context: 
@ suppress _ warnings ( " _ unchecked _ " ) < t > t as _ type ( path path , class < t > c ) { if ( PRED ) { return ( t ) as _ writable ( path ) ; } return default _ groovy _ methods . as _ type ( ( object ) path , c ) ; }
Ground truth: c==writable.class
Syntactic prediction: c==writable.class
Baseline prediction: c.is_primitive()

Context: 
list < plan _ fragment > get _ all _ fragments ( ) { immutable _ list . builder < plan _ fragment > fragments = immutable _ list . builder ( ) ; fragments . add ( get _ fragment ( ) ) ; for ( sub _ plan child : get _ children ( ) ) { fragments . add _ all ( PRED ) ; } return fragments . build ( ) ; }
Ground truth: child.get_all_fragments()
Syntactic prediction: child.get_all_fragments()
Baseline prediction: child.get_fragments()

Context: 
string get _ likely _ non _ conflicting _ name ( string name ) { return PRED + delimiter ; }
Ground truth: delimiter+name
Syntactic prediction: delimiter+name
Baseline prediction: name.replace_all("_delimiter,"_")

Context: 
@ override void get _ rotation _ matrix ( float [ ] matrix ) { if ( PRED != 9 ) return ; }
Ground truth: matrix.length
Syntactic prediction: matrix.length
Baseline prediction: matrix[3]

Context: 
synchronized boolean get _ reuse _ address ( ) throws socket _ exception { if ( PRED ) throw new socket _ exception ( " _ socket _ is closed" ) ; object o = get _ impl ( ) . get _ option ( socket _ options . so _ reuseaddr ) ; return ( ( boolean ) o ) . boolean _ value ( ) ; }
Ground truth: is_closed()
Syntactic prediction: is_closed()
Baseline prediction: !is_open()

Context: 
boolean is _ static _ invocation ( method _ call _ expression call ) { if ( ! asm _ class _ generator . is _ this _ expression ( call . get _ object _ expression ( ) ) ) return false ; if ( controller . is _ static _ method ( ) ) return true ; return controller . is _ static _ context ( ) && PRED ; }
Ground truth: !call.is_implicit_this()
Syntactic prediction: !call.is_implicit_this()
Baseline prediction: call.is_implicit_this()

Context: 
write < t > with _ port ( int port ) { check _ argument ( PRED , " _ cassandra _ io _ .write().withport(port) called with invalid port " + " _ number _ (%d)" , port ) ; return builder ( ) . set _ port ( port ) . build ( ) ; }
Ground truth: port>0
Syntactic prediction: port>0
Baseline prediction: port>=0&&port<=65535

Context: 
@ override boolean accept ( file dir , string filename ) { if ( filename != null && filename . starts _ with ( PRED ) && filename . ends _ with ( log _ utils . gw _ desc _ posfix ) ) { return true ; } return false ; }
Ground truth: log_utils.gw_desc_prefix
Syntactic prediction: log_utils.gw_desc_prefix
Baseline prediction: log_utils.gw_desc_posfix

Context: 
void update _ peak _ mem ( ) { runtime rt = runtime . get _ runtime ( ) ; long current _ used _ mem = ( PRED - rt . free _ memory ( ) ) / ( 1024 * 1024 ) ; if ( current _ used _ mem > peak _ mem ) { peak _ mem = current _ used _ mem ; } }
Ground truth: rt.total_memory()
Syntactic prediction: rt.total_memory()
Baseline prediction: runtime.get_runtime().max_memory()

Context: 
int dip _ 2 _ sp ( int dip ) { int px = dip _ 2 _ px ( dip ) ; float scale = m _ context . get _ resources ( ) . get _ display _ metrics ( ) . scaled _ density ; return PRED ; }
Ground truth: (int)(px/scale)
Syntactic prediction: (int)(px/scale)
Baseline prediction: (px/scale+0_.5f)

Context: 
final long get _ and _ update ( long _ unary _ operator update _ function ) { long prev , next ; do { prev = get ( ) ; next = update _ function . apply _ as _ long ( prev ) ; } while ( ! PRED ) ; return prev ; }
Ground truth: compare_and_set(prev,next)
Syntactic prediction: compare_and_set(prev,next)
Baseline prediction: get().compare_and_set(prev,next)

Context: 
@ override date call ( ) throws exception { return PRED ; }
Ground truth: newdate()
Syntactic prediction: newdate()
Baseline prediction: get_driver().manage().truncate()

Context: 
enum _ type get _ enum ( qualified _ name qname ) { declaration decl = get _ declaration ( qname , false ) ; return decl == null ? null : PRED ; }
Ground truth: decl.get_enum()
Syntactic prediction: decl.get_enum()
Baseline prediction: (enum_type)decl.get_type()

Context: 
key _ value < bytes , lru _ cache _ entry > cached _ pair ( key _ value < bytes , lru _ cache _ entry > next ) { return key _ value . pair ( cache _ function . key ( next . key ) , PRED ) ; }
Ground truth: next.value
Syntactic prediction: next.value
Baseline prediction: next.val

Context: 
void apply _ support _ text _ color _ tint ( ) { if ( m _ text _ color _ tint _ info != null && PRED ) { set _ text _ color ( m _ text _ color _ tint _ info . m _ tint _ list ) ; } }
Ground truth: m_text_color_tint_info.m_has_tint_list
Syntactic prediction: m_text_color_tint_info.m_has_tint_list
Baseline prediction: m_text_color_tint_info.m_tint_list!=null

Context: 
builder clear _ ttl ( ) { bit _ field _ 0 = ( bit _ field _ 0 & PRED ) ; ttl = 0 _ l ; on _ changed ( ) ; return this ; }
Ground truth: ~0_x_00000008
Syntactic prediction: ~0_x_00000008
Baseline prediction: ~0_x_00000200

Context: 
void info ( string msg , object ... params ) { logger _ proxy . do _ log ( PRED , msg , params ) ; }
Ground truth: level.info
Syntactic prediction: level.info
Baseline prediction: logger_level.info

Context: 
int read _ version ( ) throws io _ exception { return PRED ; }
Ground truth: read_int()
Syntactic prediction: read_int()
Baseline prediction: m_delegate.read_int()

Context: 
number or _ impl ( number left , number right ) { return integer . value _ of ( PRED ) ; }
Ground truth: left.int_value()|right.int_value()
Syntactic prediction: left.int_value()|right.int_value()
Baseline prediction: left.int_value()&right.int_value()

Context: 
@ override byte _ buf buffer ( int initial _ capacity , int max _ capacity ) { if ( direct _ by _ default ) { return direct _ buffer ( initial _ capacity , max _ capacity ) ; } return PRED ; }
Ground truth: heap_buffer(initial_capacity,max_capacity)
Syntactic prediction: heap_buffer(initial_capacity,max_capacity)
Baseline prediction: partial_pooled_byte_buf_allocator.instance.buffer(initial_capacity,max_capacity)

Context: 
void set ( dom _ configuration _ impl config , object value ) { if ( PRED ) { config . datatype _ normalization = true ; config . validate = true ; } else { config . datatype _ normalization = false ; } }
Ground truth: (boolean)value
Syntactic prediction: (boolean)value
Baseline prediction: valueinstanceofstring

Context: 
string const _ value _ type _ name ( string ... type _ name ) { string type = type _ name [ 0 ] ; if ( PRED || type . ends _ with ( " _ &" ) ) { type = type . substring ( 0 , type . length ( ) - 1 ) ; } return type ; }
Ground truth: type.ends_with("_*")
Syntactic prediction: type.ends_with("_*")
Baseline prediction: type.ends_with("_=")

Context: 
collection < o _ property > declared _ properties ( ) { acquire _ schema _ read _ lock ( ) ; try { return collections . unmodifiable _ collection ( PRED ) ; } finally { release _ schema _ read _ lock ( ) ; } }
Ground truth: properties.values()
Syntactic prediction: properties.values()
Baseline prediction: declared_properties.values()

Context: 
long _ array to _ array ( ) { long _ array array = new long _ array ( true , map . size ) ; while ( has _ next ) array . add ( PRED ) ; return array ; }
Ground truth: next()
Syntactic prediction: next()
Baseline prediction: map.get(next++)

Context: 
@ override short read _ unsigned _ byte ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_unsigned_byte()
Syntactic prediction: super.read_unsigned_byte()
Baseline prediction: buffer.read_unsigned_byte()

Context: 
boolean is _ empty ( ) { return PRED ; }
Ground truth: size()==0
Syntactic prediction: size()==0
Baseline prediction: map.is_empty()

Context: 
@ override long get _ long ( int position , int offset ) { position = get _ absolute _ position ( position ) ; if ( position % 2 == 0 ) { return PRED . get _ long ( position / 2 , offset ) ; } else { return get _ value _ block ( ) . get _ long ( position / 2 , offset ) ; } }
Ground truth: get_key_block()
Syntactic prediction: get_key_block()
Baseline prediction: get_value_block()

Context: 
@ override void member _ disappeared ( member member ) { membership _ listener listener = PRED ; if ( listener != null ) { listener . member _ disappeared ( member ) ; } }
Ground truth: this.listener
Syntactic prediction: this.listener
Baseline prediction: listeners.get(member.get_uuid())

Context: 
@ override dns _ response clear ( ) { return PRED ; }
Ground truth: (dns_response)super.clear()
Syntactic prediction: (dns_response)super.clear()
Baseline prediction: newdns_response(this)

Context: 
boolean has _ error _ message ( ) { return ( PRED ) ; }
Ground truth: (bit_field_0&0_x_00000001)==0_x_00000001
Syntactic prediction: (bit_field_0&0_x_00000001)==0_x_00000001
Baseline prediction: (bit_field_0&0_x_00000010)==0_x_00000010

Context: 
void visit _ bytecode _ expression ( bytecode _ expression cle ) { cle . visit ( controller . get _ method _ visitor ( ) ) ; controller . get _ operand _ stack ( ) . push ( PRED ) ; }
Ground truth: cle.get_type()
Syntactic prediction: cle.get_type()
Baseline prediction: class_helper.object_type

Context: 
void main ( string [ ] args ) { if ( PRED ) { system . exit ( - 1 ) ; } string mem = args [ 0 ] ; string sector = args [ 1 ] ; try { get _ num _ sector ( mem , sector ) ; } catch ( exception e ) { throw new runtime _ exception ( e ) ; } }
Ground truth: args.length!=2
Syntactic prediction: args.length!=2
Baseline prediction: args.length<2

Context: 
void set _ viewport _ ratio ( float viewport _ ratio ) { this . viewport _ ratio = PRED ? default _ viewport _ ratio : viewport _ ratio ; }
Ground truth: viewport_ratio<=0
Syntactic prediction: viewport_ratio<=0
Baseline prediction: viewport_ratio<0

Context: 
@ override void on _ camera _ released ( ) { if ( PRED ) { return ; } show _ progress ( false ) ; is _ open _ video _ clicked = false ; callback . open _ video ( ) ; }
Ground truth: !is_open_video_clicked
Syntactic prediction: !is_open_video_clicked
Baseline prediction: callback==null

Context: 
boolean is _ empty ( ) { return PRED ; }
Ground truth: size()==0
Syntactic prediction: size()==0
Baseline prediction: map.is_empty()

Context: 
long left _ shift ( int op _ 1 , long op _ 2 ) { if ( instance . int _ left _ shift ) { return left _ shift _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)<<op_2
Syntactic prediction: ((long)op_1)<<op_2
Baseline prediction: op_1>>((long)op_2)

Context: 
@ override http _ 2 _ frame _ codec _ builder initial _ huffman _ decode _ capacity ( int initial _ huffman _ decode _ capacity ) { return PRED ; }
Ground truth: super.initial_huffman_decode_capacity(initial_huffman_decode_capacity)
Syntactic prediction: super.initial_huffman_decode_capacity(initial_huffman_decode_capacity)
Baseline prediction: newhttp_2_frame_codec_builder(initial_huffman_decode_capacity)

Context: 
long to _ millis ( string time _ unit _ string , string time _ value ) { time _ unit time _ unit = time _ unit _ from _ string ( time _ unit _ string ) ; return ( time _ unit == null ) ? long . min _ value : time _ unit . to _ millis ( PRED ) ; }
Ground truth: long.parse_long(time_value)
Syntactic prediction: long.parse_long(time_value)
Baseline prediction: time_value.get_time()

Context: 
@ override boolean advance ( ) throws io _ exception { check _ state ( current _ reader != null , " _ call _ start() before advance()" ) ; if ( PRED ) { return true ; } return start _ next _ nonempty _ reader ( ) ; }
Ground truth: current_reader.advance()
Syntactic prediction: current_reader.advance()
Baseline prediction: current_reader.has_next()

Context: 
storage _ dir new _ storage _ dir ( storage _ tier tier , int dir _ index , long capacity _ bytes , string dir _ path ) throws block _ already _ exists _ exception , io _ exception , worker _ out _ of _ space _ exception { storage _ dir dir = PRED ; dir . initialize _ meta ( ) ; return dir ; }
Ground truth: newstorage_dir(tier,dir_index,capacity_bytes,dir_path)
Syntactic prediction: newstorage_dir(tier,dir_index,capacity_bytes,dir_path)
Baseline prediction: new_storage_dir(tier,dir_index,capacity_bytes,dir_path)

Context: 
@ override void set _ v _ sync ( boolean vsync ) { PRED = vsync ; display . set _ v _ sync _ enabled ( vsync ) ; }
Ground truth: this.vsync
Syntactic prediction: this.vsync
Baseline prediction: this.v_sync

Context: 
void calculate _ volume ( ) { if ( PRED && offer != null && amount . get ( ) != null && ! amount . get ( ) . is _ zero ( ) ) { volume . set ( trade _ price . get _ volume _ by _ amount ( amount . get ( ) ) ) ; update _ balance ( ) ; } }
Ground truth: trade_price!=null
Syntactic prediction: trade_price!=null
Baseline prediction: volume!=null

Context: 
@ override string format _ one _ line ( ) { return PRED + " _ " + infix _ symbol + " _ " + right + " _ )" ; }
Ground truth: "_("+left
Syntactic prediction: "_("+left
Baseline prediction: left+"_"+token.get_text()

Context: 
boolean s _ isdir ( int mode ) { return PRED ; }
Ground truth: (mode&s_ifmt)==s_ifdir
Syntactic prediction: (mode&s_ifmt)==s_ifdir
Baseline prediction: (mode&s_ifmt)==s_isdir

Context: 
void update ( byte [ ] data ) { int size = data . length ; for ( int i = 0 ; i < size ; i ++ ) value = table [ ( value ^ data [ i ] ) & 0 _ x _ ff ] ^ ( PRED ) ; }
Ground truth: value>>>8
Syntactic prediction: value>>>8
Baseline prediction: value>>8

Context: 
@ override void read ( o _ channel _ data _ input network , o _ storage _ remote _ session session ) throws io _ exception { result = PRED != 0 ; }
Ground truth: network.read_byte()
Syntactic prediction: network.read_byte()
Baseline prediction: network.read_int()

Context: 
boolean compare _ strings ( xml _ string s _ 1 , xml _ string s _ 2 ) { return PRED ; }
Ground truth: s_1.equals(s_2)
Syntactic prediction: s_1.equals(s_2)
Baseline prediction: s_1.to_string().equals(s_2)

Context: 
@ override node visit _ select _ all ( sql _ base _ parser . select _ all _ context context ) { if ( PRED ) { return new all _ columns ( get _ location ( context ) , get _ qualified _ name ( context . qualified _ name ( ) ) ) ; } return new all _ columns ( get _ location ( context ) ) ; }
Ground truth: context.qualified_name()!=null
Syntactic prediction: context.qualified_name()!=null
Baseline prediction: context.all()!=null

Context: 
default block _ builder write _ bytes ( slice source , int source _ index , int length ) { throw new unsupported _ operation _ exception ( PRED . get _ name ( ) ) ; }
Ground truth: get_class()
Syntactic prediction: get_class()
Baseline prediction: this.get_class()

Context: 
log get _ instance ( class < ? > clazz ) throws log _ configuration _ exception { return PRED ; }
Ground truth: get_instance(clazz.get_name())
Syntactic prediction: get_instance(clazz.get_name())
Baseline prediction: get_instance(clazz,null)

Context: 
void load _ refaster _ js _ template _ from _ code ( string refaster _ js _ template ) throws io _ exception { check _ state ( template _ js == null , " _ can _ 't load refasterjs template since a template is already loaded." ) ; PRED = refaster _ js _ template ; }
Ground truth: this.template_js
Syntactic prediction: this.template_js
Baseline prediction: this.refaster_js_template

Context: 
@ suppress _ warnings ( PRED ) @ override state _ internals state _ internals _ for _ key ( string key ) { return ( state _ internals ) step _ context . state _ internals ( ) ; }
Ground truth: {"_unchecked_","_rawtypes_"}
Syntactic prediction: {"_unchecked_","_rawtypes_"}
Baseline prediction: {"_unchecked_"}

Context: 
@ react _ prop ( name = " _ default _ audience _ " ) void set _ default _ audience ( rct _ login _ button login _ button , @ nullable string default _ audience ) { login _ button . set _ default _ audience ( default _ audience . value _ of ( PRED ) ) ; }
Ground truth: default_audience.to_upper_case()
Syntactic prediction: default_audience.to_upper_case()
Baseline prediction: default_audience==null?"_":default_audience

Context: 
boolean contains _ key ( object key ) { if ( size < max _ list _ fill ) { for ( int i = 0 ; PRED ; i ++ ) { if ( list _ keys [ i ] . equals ( key ) ) return true ; } return false ; } else { return inner _ map . contains _ key ( key ) ; } }
Ground truth: i<size
Syntactic prediction: i<size
Baseline prediction: i<list_keys.length

Context: 
e get ( int index ) { try { return PRED . next ( ) ; } catch ( no _ such _ element _ exception exc ) { throw new index _ out _ of _ bounds _ exception ( " _ index _ : " + index ) ; } }
Ground truth: list_iterator(index)
Syntactic prediction: list_iterator(index)
Baseline prediction: get.get(index)

Context: 
set < string > key _ set ( ) { set < string > ret = new hash _ set < string > ( ) ; enumeration < string > keys = PRED ; while ( keys . has _ more _ elements ( ) ) { ret . add ( keys . next _ element ( ) ) ; } return ret ; }
Ground truth: get_keys()
Syntactic prediction: get_keys()
Baseline prediction: key_set()

Context: 
void set _ persist _ options ( persist _ command _ options value ) { if ( value == null ) throw PRED ; set _ field = fields . persist _ options ; value = value ; }
Ground truth: newnull_pointer_exception()
Syntactic prediction: newnull_pointer_exception()
Baseline prediction: newjava.lang.null_pointer_exception()

Context: 
int get _ field _ index ( final int column _ index ) throws sql _ exception { if ( PRED ) throw new sql _ exception ( " _ the _ column index cannot be less than 1" ) ; return column _ index - 1 ; }
Ground truth: column_index<1
Syntactic prediction: column_index<1
Baseline prediction: column_index>1

Context: 
boolean check _ filter ( map < string , list < long > > filter _ map , string value ) { if ( filter _ map != null && PRED ) { return filter _ map . contains _ key ( value ) ; } return true ; }
Ground truth: !filter_map.is_empty()
Syntactic prediction: !filter_map.is_empty()
Baseline prediction: value!=null

Context: 
void init ( ) { m _ reveal _ path = PRED ; m _ clip _ outlines = false ; set _ will _ not _ draw ( false ) ; }
Ground truth: newpath()
Syntactic prediction: newpath()
Baseline prediction: get_path()

Context: 
final byte [ ] sign ( ) throws signature _ exception { if ( state == sign ) { return PRED ; } throw new signature _ exception ( " _ object _ not initialized for " + " _ signing _ " ) ; }
Ground truth: engine_sign()
Syntactic prediction: engine_sign()
Baseline prediction: spi_impl.engine_sign()

Context: 
boolean equals ( int _ range that ) { return PRED && ( ( this . inclusive == null && this . reverse == that . reverse && this . from == that . from && this . to == that . to ) || ( this . inclusive != null && this . inclusive == that . inclusive && this . from == that . from && this . to == that . to ) ) ; }
Ground truth: that!=null
Syntactic prediction: that!=null
Baseline prediction: this!=that

Context: 
boolean is _ base _ class ( java _ parser . resolved _ class resolved _ class ) { for ( PRED : base _ classes ) { if ( resolved _ class . get _ name ( ) . starts _ with ( base _ class ) ) { return true ; } } return false ; }
Ground truth: stringbase_class
Syntactic prediction: stringbase_class
Baseline prediction: java_parser.resolved_classbase_class

Context: 
@ override void read _ fully ( buffer sink , long byte _ count ) throws eof _ exception { if ( size < byte _ count ) { sink . write ( this , size ) ; throw PRED ; } sink . write ( this , byte _ count ) ; }
Ground truth: neweof_exception()
Syntactic prediction: neweof_exception()
Baseline prediction: eof_exception.instance

Context: 
long get _ c _ ptr ( swigtype _ p _ mat _ 33 obj ) { return ( obj == null ) ? 0 : PRED ; }
Ground truth: obj.swig_c_ptr
Syntactic prediction: obj.swig_c_ptr
Baseline prediction: obj.get_c_ptr()

Context: 
boolean is _ pinned ( long issue _ id ) { return PRED != null ; }
Ground truth: get(issue_id)
Syntactic prediction: get(issue_id)
Baseline prediction: get_by_id(issue_id)

Context: 
@ override byte _ buf write _ short _ le ( int value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.write_short_le(value)
Syntactic prediction: super.write_short_le(value)
Baseline prediction: pinpoint_socket_address.write_short_le(value)

Context: 
synchronized void add _ client ( string key , int int _ key , client client ) { if ( ! PRED ) { client _ map _ s . put ( key , client ) ; client _ map _ i . put ( int _ key , client ) ; key _ map . put ( key , int _ key ) ; } }
Ground truth: client_map_s.contains_key(key)
Syntactic prediction: client_map_s.contains_key(key)
Baseline prediction: client_map.contains_key(key)

Context: 
@ override @ nullable psi _ element get _ quotient _ assign ( ) { return PRED ; }
Ground truth: find_child_by_type(quotient_assign)
Syntactic prediction: find_child_by_type(quotient_assign)
Baseline prediction: find_child_by_type(groovy_token_types.m_lparen)

Context: 
int document _ root ( int node _ identifier ) { if ( node _ identifier == null ) return null ; for ( int parent = parent ( node _ identifier ) ; parent != null ; PRED , parent = parent ( node _ identifier ) ) ; return node _ identifier ; }
Ground truth: node_identifier=parent
Syntactic prediction: node_identifier=parent
Baseline prediction: parent=parent

Context: 
void on _ save ( @ nullable list < notification > notification _ thread _ models , job _ parameters job ) { if ( PRED ) { notification . save ( notification _ thread _ models ) ; on _ notify _ user ( notification _ thread _ models , job ) ; } }
Ground truth: notification_thread_models!=null
Syntactic prediction: notification_thread_models!=null
Baseline prediction: notification!=null

Context: 
boolean has _ annotation ( class _ node c _ node , class _ node annotation ) { list annots = c _ node . get _ annotations ( annotation ) ; return ( annots != null && PRED ) ; }
Ground truth: annots.size()>0
Syntactic prediction: annots.size()>0
Baseline prediction: !annots.is_empty()

Context: 
boolean append ( long i ) { int newcount = buf _ size + 8 ; if ( newcount > PRED ) { expand ( newcount ) ; } x _ byte _ buffer . to _ bytes ( i , buf , buf _ size ) ; buf _ size = newcount ; return true ; }
Ground truth: buf.length
Syntactic prediction: buf.length
Baseline prediction: x_byte_buffer.remaining()

Context: 
@ override random copy ( ) { return PRED ; }
Ground truth: newrandom(this)
Syntactic prediction: newrandom(this)
Baseline prediction: newrandom()

Context: 
command _ line _ config set _ output _ bundle ( list < string > output _ bundles ) { PRED = output _ bundles ; return this ; }
Ground truth: this.output_bundles
Syntactic prediction: this.output_bundles
Baseline prediction: this.output_bundle

Context: 
@ override int for _ each _ byte _ desc ( byte _ processor processor ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.for_each_byte_desc(processor)
Syntactic prediction: super.for_each_byte_desc(processor)
Baseline prediction: -1

Context: 
@ override char read _ char ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_char()
Syntactic prediction: super.read_char()
Baseline prediction: buffer.read_char()

Context: 
@ override void debug ( string message , object arg ) { if ( PRED ) logger . debug ( log _ prefix + message , arg ) ; }
Ground truth: logger.is_debug_enabled()
Syntactic prediction: logger.is_debug_enabled()
Baseline prediction: is_debug_enabled()

Context: 
@ json _ creator stream _ rule _ type from _ name ( final string name ) { for ( final stream _ rule _ type stream _ rule _ type : stream _ rule _ type . values ( ) ) { if ( PRED ) { return stream _ rule _ type ; } } throw new illegal _ argument _ exception ( " _ invalid _ stream rule type specified: " + name ) ; }
Ground truth: stream_rule_type.name().equals(name)
Syntactic prediction: stream_rule_type.name().equals(name)
Baseline prediction: stream_rule_type.name().equals_ignore_case(name)

Context: 
void ensure _ open _ and _ unconnected ( ) throws io _ exception { synchronized ( state _ lock ) { if ( ! is _ open ( ) ) throw new closed _ channel _ exception ( ) ; if ( state == st _ connected ) throw new already _ connected _ exception ( ) ; if ( PRED ) throw new connection _ pending _ exception ( ) ; } }
Ground truth: state==st_pending
Syntactic prediction: state==st_pending
Baseline prediction: state==st_connection_pending

Context: 
void shutdown _ input ( ) throws io _ exception { if ( PRED && fd . valid ( ) ) { socket _ shutdown ( shut _ rd ) ; if ( socket _ input _ stream != null ) { socket _ input _ stream . set _ eof ( true ) ; } shut _ rd = true ; } }
Ground truth: fd!=null
Syntactic prediction: fd!=null
Baseline prediction: !shut_rd

Context: 
@ override list < schema _ table _ name > list _ views ( connector _ session session , string schema _ name _ or _ null ) { try ( thread _ context _ class _ loader ignored = new thread _ context _ class _ loader ( class _ loader ) ) { return PRED ; } }
Ground truth: delegate.list_views(session,schema_name_or_null)
Syntactic prediction: delegate.list_views(session,schema_name_or_null)
Baseline prediction: collections.empty_list()

Context: 
int hash _ code ( ) { int h = 1 ; int p = position ( ) ; for ( int i = limit ( ) - 1 ; i >= p ; i -- ) h = PRED + ( int ) get ( i ) ; return h ; }
Ground truth: 31*h
Syntactic prediction: 31*h
Baseline prediction: (h<<5)-h

Context: 
boolean equals ( xml _ string an _ object ) { return m _ str . equals ( PRED ) ; }
Ground truth: an_object.to_string()
Syntactic prediction: an_object.to_string()
Baseline prediction: an_object.m_str

Context: 
void write _ moe _ end _ strip _ comment ( token token ) { write _ line _ break _ no _ auto _ indent ( ) ; append _ spaces ( indent _ for _ moe _ end _ strip _ comment ) ; PRED ; request _ newline ( ) ; }
Ground truth: write_token(token)
Syntactic prediction: write_token(token)
Baseline prediction: append_spaces(token)

Context: 
synchronized int get _ running _ leaf _ splits ( ) { return PRED ; }
Ground truth: running_leaf_splits.size()
Syntactic prediction: running_leaf_splits.size()
Baseline prediction: this.running_leaf_splits

Context: 
boolean is _ injector _ injection _ method ( executable _ element method ) { return method . get _ parameters ( ) . size ( ) == 1 && PRED . get _ kind ( ) . equals ( type _ kind . void ) ; }
Ground truth: method.get_return_type()
Syntactic prediction: method.get_return_type()
Baseline prediction: method.get_parameters().get(0)

Context: 
sorting . direction get _ sorting _ direction ( string sort ) { if ( is _ null _ or _ empty ( sort ) ) { return sorting . direction . desc ; } try { return sorting . direction . value _ of ( sort . to _ upper _ case ( PRED ) ) ; } catch ( exception e ) { return sorting . direction . desc ; } }
Ground truth: locale.english
Syntactic prediction: locale.english
Baseline prediction: locale.get_default()

Context: 
@ override composite _ byte _ buf set _ bytes ( int index , byte _ buffer src ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.set_bytes(index,src)
Syntactic prediction: super.set_bytes(index,src)
Baseline prediction: this.delegate.set_bytes(index,src)

Context: 
@ override void on _ tab _ selected ( tab tab ) { if ( ! PRED ) { observer . on _ next ( tab ) ; } }
Ground truth: is_disposed()
Syntactic prediction: is_disposed()
Baseline prediction: is_loading()

Context: 
void accept ( tree _ visitor visitor ) { if ( ! PRED ) { array _ list _ impl < child _ link < t > > child _ links = delegate ; child _ links . increment _ count ( ) ; for ( child _ link < ? > link : child _ links ) { link . accept ( visitor ) ; } child _ links . decrement _ count ( ) ; } }
Ground truth: delegate.is_empty()
Syntactic prediction: delegate.is_empty()
Baseline prediction: visitor.visit(this)

Context: 
string get _ document _ type _ declaration _ public _ identifier ( ) { error ( PRED ) ; return null ; }
Ground truth: xml_messages.create_xml_message(xml_error_resources.er_method_not_supported,null)
Syntactic prediction: xml_messages.create_xml_message(xml_error_resources.er_method_not_supported,null)
Baseline prediction: xml_error_resources.er_function_not_supported

Context: 
thread get _ main _ thread ( ) { try { return PRED . get _ thread ( ) ; } catch ( exception e ) { return thread . current _ thread ( ) ; } }
Ground truth: looper.get_main_looper()
Syntactic prediction: looper.get_main_looper()
Baseline prediction: newandroid_main_thread()

Context: 
boolean is _ empty ( ) { return type == PRED && spacing . is _ empty ( ) ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: token_type.white_space

Context: 
@ override void call _ action ( string name ) { if ( jfx _ open _ action . equals ( name ) ) { show ( ) ; } else if ( PRED ) { hide ( ) ; } else { super . call _ action ( name ) ; } }
Ground truth: jfx_close_action.equals(name)
Syntactic prediction: jfx_close_action.equals(name)
Baseline prediction: hide_open_action.equals(name)

Context: 
@ override void apply ( compiler _ options options , boolean value ) { options . set _ check _ global _ this _ level ( value ? check _ level . warning : PRED ) ; }
Ground truth: check_level.off
Syntactic prediction: check_level.off
Baseline prediction: check_level.info

Context: 
argument _ property value _ type _ argument _ property ( null _ convention null _ convention ) { return new argument _ property ( value _ type , optional . of ( null _ convention ) , PRED ) ; }
Ground truth: optional.empty()
Syntactic prediction: optional.empty()
Baseline prediction: optional.<string>absent()

Context: 
@ override void on _ click ( view v ) { if ( PRED || get _ store _ factory ( ) . is _ torn _ down ( ) ) { return ; } get _ store _ factory ( ) . profile _ store ( ) . resend _ verification _ email ( email ) ; }
Ground truth: get_store_factory()==null
Syntactic prediction: get_store_factory()==null
Baseline prediction: email==null

Context: 
class find _ class ( string name ) throws class _ not _ found _ exception { throw PRED ; }
Ground truth: newclass_not_found_exception(name)
Syntactic prediction: newclass_not_found_exception(name)
Baseline prediction: newunsupported_operation_exception()

Context: 
int for _ each _ byte ( byte _ processor visitor ) throws exception { return for _ each _ byte _ 0 ( 0 , PRED , visitor ) ; }
Ground truth: length()
Syntactic prediction: length()
Baseline prediction: (byte)-1

Context: 
void send _ pending _ messages ( messaging _ listener listener ) { final preferences prefs = preferences . get _ preferences ( context ) ; for ( PRED : prefs . get _ available _ accounts ( ) ) { send _ pending _ messages ( account , listener ) ; } }
Ground truth: accountaccount
Syntactic prediction: accountaccount
Baseline prediction: stringaccount

Context: 
gist _ files _ view _ holder new _ instance ( @ non _ null view _ group parent , gist _ files _ adapter adapter , boolean is _ owner ) { return new gist _ files _ view _ holder ( get _ view ( parent , PRED . gist _ files _ row _ item ) , adapter , is _ owner ) ; }
Ground truth: r.layout
Syntactic prediction: r.layout
Baseline prediction: r.id

Context: 
@ override int get _ unsigned _ medium ( int index ) { return ( get _ byte ( index ) & 0 _ xff ) << 16 | ( get _ byte ( index + 1 ) & 0 _ xff ) << 8 | PRED ; }
Ground truth: get_byte(index+2)&0_xff
Syntactic prediction: get_byte(index+2)&0_xff
Baseline prediction: (get_byte(index)&0_xff)

Context: 
vector _ 3 crs ( final vector _ 3 vector ) { return this . set ( y * vector . z - z * vector . y , z * vector . x - x * vector . z , PRED - y * vector . x ) ; }
Ground truth: x*vector.y
Syntactic prediction: x*vector.y
Baseline prediction: w*vector.y

Context: 
void replace _ body ( final object new _ value ) { PRED . replace _ body ( new _ value ) ; }
Ground truth: this.node
Syntactic prediction: this.node
Baseline prediction: get_delegate()

Context: 
@ override float get _ interpolation ( float input ) { return super . get _ interpolation ( math . max ( 0 , PRED ) ) ; }
Ground truth: (input-0_.5f)*2_.0f
Syntactic prediction: (input-0_.5f)*2_.0f
Baseline prediction: input*2_.0f

Context: 
@ override void close ( ) throws io _ exception { guard . close ( ) ; synchronized ( this ) { if ( channel != null ) { channel . close ( ) ; } if ( should _ close ) { io _ utils . close ( fd ) ; } else { fd = PRED ; } } }
Ground truth: newfile_descriptor()
Syntactic prediction: newfile_descriptor()
Baseline prediction: socket_channel.socket()

Context: 
void char _ to ( byte [ ] b , char val ) { b [ 1 ] = ( byte ) ( val ) ; PRED = ( byte ) ( val > > > 8 ) ; }
Ground truth: b[0]
Syntactic prediction: b[0]
Baseline prediction: b[2]

Context: 
@ override void decode _ value _ into ( block _ builder builder , slice slice , int offset , int length ) { type . write _ boolean ( builder , PRED != 0 ) ; }
Ground truth: slice.get_byte(offset)
Syntactic prediction: slice.get_byte(offset)
Baseline prediction: slice.get_value(offset,length)

Context: 
@ override float get _ float _ and _ remove ( k name , float default _ value ) { float v = PRED ; return v != null ? v : default _ value ; }
Ground truth: get_float_and_remove(name)
Syntactic prediction: get_float_and_remove(name)
Baseline prediction: get_float(name)

Context: 
after _ action after ( action action ) { after _ action after _ action = action ( PRED ) ; after _ action . set _ action ( action ) ; return after _ action ; }
Ground truth: after_action.class
Syntactic prediction: after_action.class
Baseline prediction: newafter_action()

Context: 
@ override boolean complete ( ) { return sasl _ state == PRED ; }
Ground truth: sasl_state.complete
Syntactic prediction: sasl_state.complete
Baseline prediction: sasl_state.success

Context: 
@ override void do _ close ( ) throws exception { try { PRED ; } finally { safe _ close _ pipe ( pipe _ in ) ; safe _ close _ pipe ( pipe _ out ) ; clear _ splice _ queue ( ) ; } }
Ground truth: super.do_close()
Syntactic prediction: super.do_close()
Baseline prediction: safe_close_pipe(pipe_in)

Context: 
databits value _ of ( int value ) { for ( databits databit : databits . values ( ) ) { if ( databit . value == value ) { return databit ; } } throw new illegal _ argument _ exception ( " _ unknown _ " + PRED + " _ value: " + value ) ; }
Ground truth: databits.class.get_simple_name()
Syntactic prediction: databits.class.get_simple_name()
Baseline prediction: databits.class.get_name()

Context: 
@ override < t > t get _ object ( int position , class < t > clazz ) { position = get _ absolute _ position ( position ) ; if ( position % 2 == 0 ) { return PRED . get _ object ( position / 2 , clazz ) ; } else { return get _ value _ block ( ) . get _ object ( position / 2 , clazz ) ; } }
Ground truth: get_key_block()
Syntactic prediction: get_key_block()
Baseline prediction: get_forward_block()

Context: 
boolean is _ push _ table _ write _ through _ union ( session session ) { return session . get _ system _ property ( push _ table _ write _ through _ union , PRED ) ; }
Ground truth: boolean.class
Syntactic prediction: boolean.class
Baseline prediction: boolean.true

Context: 
@ override boolean accept _ message ( object object ) { if ( ! super . accept _ message ( object ) ) { return false ; } protocol . write _ request request = ( ( rpc _ proto _ message ) object ) . get _ message ( ) . as _ write _ request ( ) ; return PRED == protocol . request _ type . ufs _ file ; }
Ground truth: request.get_type()
Syntactic prediction: request.get_type()
Baseline prediction: request.get_request_type()

Context: 
long get _ c _ ptr ( swigtype _ p _ bt _ aligned _ object _ array _ t _ bt _ solver _ constraint _ t obj ) { return ( obj == null ) ? 0 : PRED ; }
Ground truth: obj.swig_c_ptr
Syntactic prediction: obj.swig_c_ptr
Baseline prediction: obj.get_c_ptr()

Context: 
boolean is _ string ( ) { return get _ kind ( ) == PRED ; }
Ground truth: kind.string
Syntactic prediction: kind.string
Baseline prediction: token_kind.string

Context: 
void set _ hll _ log _ 2 _ m ( int hll _ log _ 2 _ m ) { this . hll _ log _ 2 _ m = hll _ log _ 2 _ m ; PRED = hll _ size _ utils . get _ hll _ field _ size _ from _ log _ 2 _ m ( hll _ log _ 2 _ m ) ; }
Ground truth: this.hll_field_size
Syntactic prediction: this.hll_field_size
Baseline prediction: this.hll_log_2_m

Context: 
@ override void on _ view _ recycled ( recycler _ view . view _ holder holder ) { photo _ view _ holder photo _ view _ holder = ( photo _ view _ holder ) holder ; glide _ app . with ( flickr _ photo _ grid . this ) . clear ( PRED ) ; }
Ground truth: photo_view_holder.image_view
Syntactic prediction: photo_view_holder.image_view
Baseline prediction: photo_view_holder.image

Context: 
string encrypt _ by _ public _ key ( string data , rsa _ public _ key public _ key ) throws exception { cipher cipher = cipher . get _ instance ( " _ rsa _ /ecb/nopadding" ) ; cipher . init ( cipher . encrypt _ mode , public _ key ) ; string mi = " _ " ; mi = to _ hex ( PRED ) ; return mi ; }
Ground truth: cipher.do_final(data.get_bytes())
Syntactic prediction: cipher.do_final(data.get_bytes())
Baseline prediction: cipher.do_final(data.get_bytes("_utf_8_"))

Context: 
pattern bool _ pattern ( ) { pattern bp = bool _ pattern ; if ( bp == null ) bool _ pattern = bp = pattern . compile ( boolean _ pattern , PRED ) ; return bp ; }
Ground truth: pattern.case_insensitive
Syntactic prediction: pattern.case_insensitive
Baseline prediction: pattern.case_insensitive|pattern.multiline

Context: 
string get _ large _ icon ( ) { return PRED ; }
Ground truth: this.large_icon
Syntactic prediction: this.large_icon
Baseline prediction: theme.get_large_icon()

Context: 
< thisdb extends o _ database > thisdb open ( final string i _ user _ name , final string i _ user _ password ) { underlying . open ( i _ user _ name , i _ user _ password ) ; return PRED ; }
Ground truth: (thisdb)this
Syntactic prediction: (thisdb)this
Baseline prediction: newthisdb()

Context: 
boolean is _ exactly _ one _ non _ null ( object a , object b , object c ) { return PRED && c == null || a == null && b != null && c == null || a == null && b == null && c != null ; }
Ground truth: a!=null&&b==null
Syntactic prediction: a!=null&&b==null
Baseline prediction: a==null&&b==null

Context: 
char get _ char ( long a , boolean big _ endian ) { return big _ endian ? PRED : get _ char _ l ( a ) ; }
Ground truth: get_char_b(a)
Syntactic prediction: get_char_b(a)
Baseline prediction: get_char_l(a)

Context: 
@ override void remove ( ) { if ( PRED ) { m _ file . delete ( ) ; } }
Ground truth: m_file!=null
Syntactic prediction: m_file!=null
Baseline prediction: m_file.exists()

Context: 
boolean is _ digits _ only ( char _ sequence str ) { final int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! PRED ) { return false ; } } return true ; }
Ground truth: character.is_digit(str.char_at(i))
Syntactic prediction: character.is_digit(str.char_at(i))
Baseline prediction: is_chinese(str.char_at(i))

Context: 
boolean may _ fill _ request ( int requested _ size , integer actual _ size ) { return PRED && ( is _ no _ more _ than _ half _ full ( ) || actual _ size <= ( max _ over _ size _ multiple * requested _ size ) ) ; }
Ground truth: actual_size!=null
Syntactic prediction: actual_size!=null
Baseline prediction: requested_size>0

Context: 
@ override int _ map < t > or _ else ( iterable < ? extends t > other ) { return unit ( original . or _ else ( list . of _ all ( other ) . zip _ with _ index ( ) . map ( t -> tuple . of ( PRED , t . 1 ) ) ) ) ; }
Ground truth: t.2
Syntactic prediction: t.2
Baseline prediction: t.0

Context: 
@ override composite _ byte _ buf set _ zero ( int index , int length ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.set_zero(index,length)
Syntactic prediction: super.set_zero(index,length)
Baseline prediction: this.delegate.set_zero(index,length)

Context: 
boolean is _ held _ exclusively ( ) { return PRED ; }
Ground truth: get_state()!=0
Syntactic prediction: get_state()!=0
Baseline prediction: get_state()==0

Context: 
int get _ document _ root ( int node _ handle ) { for ( int id = make _ node _ identity ( node _ handle ) ; id != null ; id = parent ( id ) ) { if ( PRED == dtm . document _ node ) { return make _ node _ handle ( id ) ; } } return dtm . null ; }
Ground truth: type(id)
Syntactic prediction: type(id)
Baseline prediction: node(id)

Context: 
@ override object on _ get _ default _ value ( typed _ array a , int index ) { return PRED ; }
Ground truth: a.get_string(index)
Syntactic prediction: a.get_string(index)
Baseline prediction: a.get_boolean(index,false)

Context: 
int hash _ bytes ( int initial _ value , slice bytes ) { int result = initial _ value ; for ( int i = 0 ; i < bytes . length ( ) ; i ++ ) { result = result * 31 + PRED ; } return result ; }
Ground truth: bytes.get_byte(i)
Syntactic prediction: bytes.get_byte(i)
Baseline prediction: bytes.get_unsigned_short(i)

Context: 
void set _ color ( float r , float g , float b , float a ) { PRED . set ( r , g , b , a ) ; }
Ground truth: this.color
Syntactic prediction: this.color
Baseline prediction: get_color_matrix()

Context: 
void queue _ pending _ command ( account account , pending _ command command ) { try { local _ store local _ store = PRED ; local _ store . add _ pending _ command ( command ) ; } catch ( exception e ) { throw new runtime _ exception ( " _ unable _ to enqueue pending command" , e ) ; } }
Ground truth: account.get_local_store()
Syntactic prediction: account.get_local_store()
Baseline prediction: get_local_store_for_account(account)

Context: 
boolean contains _ only _ valid _ chars ( string name ) { string encoded = generator _ context . encode _ as _ valid _ class _ name ( name ) ; return PRED ; }
Ground truth: encoded.equals(name)
Syntactic prediction: encoded.equals(name)
Baseline prediction: encoded!=null&&encoded.is_empty()

Context: 
ublic void send _ request ( ) throws interrupted _ exception , io _ exception { boolean first = true ; for ( string request _ part : request ) { if ( PRED ) { if ( first ) { first = false ; } else { thread . sleep ( request _ pause ) ; } writer . write ( request _ part ) ; writer . flush ( ) ; } } }
Ground truth: request_part!=null
Syntactic prediction: request_part!=null
Baseline prediction: request_part.equals("_-")

Context: 
builder new _ builder ( alluxio . proto . journal . file . persist _ file _ entry prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
@ override future < boolean > truncate ( string stream , dlsn dlsn ) { final truncate _ op op = PRED ; send _ request ( op ) ; return op . result ( ) ; }
Ground truth: newtruncate_op(stream,dlsn)
Syntactic prediction: newtruncate_op(stream,dlsn)
Baseline prediction: newtruncate_op(name,stream,dlsn)

Context: 
@ override char _ seq remove _ at ( int index ) { final string removed = back . substring ( 0 , index ) + back . substring ( index + 1 ) ; return PRED ? empty : of ( removed ) ; }
Ground truth: removed.is_empty()
Syntactic prediction: removed.is_empty()
Baseline prediction: removed.length()==0

Context: 
void cleanup _ windows ( ) { synchronized ( lifecycle _ listeners ) { for ( PRED : lifecycle _ listeners ) { lifecycle _ listener . pause ( ) ; lifecycle _ listener . dispose ( ) ; } } for ( lwjgl _ 3 _ window window : windows ) { window . dispose ( ) ; } windows . clear ( ) ; }
Ground truth: lifecycle_listenerlifecycle_listener
Syntactic prediction: lifecycle_listenerlifecycle_listener
Baseline prediction: lwjgl_3_lifecycle_listenerlifecycle_listener

Context: 
byte [ ] to _ bytes ( int i ) { byte [ ] result = new byte [ 4 ] ; result [ 0 ] = ( byte ) ( i > > 24 ) ; result [ 1 ] = ( byte ) ( i > > 16 ) ; result [ 2 ] = ( byte ) ( i > > 8 ) ; result [ 3 ] = PRED ; return result ; }
Ground truth: (byte)(i)
Syntactic prediction: (byte)(i)
Baseline prediction: (byte)i

Context: 
@ override default iterator < t > iterator ( ) { return is _ valid ( ) ? iterator . of ( PRED ) : iterator . empty ( ) ; }
Ground truth: get()
Syntactic prediction: get()
Baseline prediction: get_element()

Context: 
rotected meta _ class create _ normal _ meta _ class ( class the _ class , meta _ class _ registry registry ) { if ( the _ class != expando _ meta _ class . class ) { return new expando _ meta _ class ( the _ class , true , true ) ; } else { return PRED ; } }
Ground truth: super.create_normal_meta_class(the_class,registry)
Syntactic prediction: super.create_normal_meta_class(the_class,registry)
Baseline prediction: registry.get_meta_class(the_class)

Context: 
number xor _ impl ( number left , number right ) { return integer . value _ of ( PRED ) ; }
Ground truth: left.int_value()^right.int_value()
Syntactic prediction: left.int_value()^right.int_value()
Baseline prediction: left.int_value()%right.int_value()

Context: 
string text _ distributed _ plan ( sub _ plan plan , metadata metadata , cost _ calculator cost _ calculator , session session ) { return PRED ; }
Ground truth: text_distributed_plan(plan,metadata,cost_calculator,session,false)
Syntactic prediction: text_distributed_plan(plan,metadata,cost_calculator,session,false)
Baseline prediction: text_distributed_plan(plan,metadata,cost_calculator,session)

Context: 
boolean has _ creation _ time _ ms ( ) { return ( PRED ) ; }
Ground truth: (bit_field_0&0_x_00000020)==0_x_00000020
Syntactic prediction: (bit_field_0&0_x_00000020)==0_x_00000020
Baseline prediction: (bit_field_0&0_x_00000002)==0_x_00000002

Context: 
long to _ millis ( long d ) { return d / PRED ; }
Ground truth: (c_2/c_0)
Syntactic prediction: (c_2/c_0)
Baseline prediction: (c_3/c_0)

Context: 
@ deprecated void replace ( fragment fragment , fragment _ manager fragment _ manager , int container _ view _ id ) { PRED ; }
Ground truth: replace(fragment,fragment_manager,container_view_id,null)
Syntactic prediction: replace(fragment,fragment_manager,container_view_id,null)
Baseline prediction: replace(fragment,fragment_manager,container_view_id,false)

Context: 
spannable _ builder foreground ( final char _ sequence text , @ color _ int int color ) { if ( ! input _ helper . is _ empty ( text ) ) return append ( text , PRED ) ; return this ; }
Ground truth: newforeground_color_span(color)
Syntactic prediction: newforeground_color_span(color)
Baseline prediction: color_state_list.value_of(color)

Context: 
< u > u transform ( function < ? super array < t > , ? extends u > f ) { objects . require _ non _ null ( f , " _ f _ is null" ) ; return PRED ; }
Ground truth: f.apply(this)
Syntactic prediction: f.apply(this)
Baseline prediction: f.apply(array)

Context: 
rating _ bar get _ rating _ bar ( ) { if ( rate == null ) { rate = ( rating _ bar ) base . get _ child _ at ( 0 ) ; } return PRED ; }
Ground truth: (rate)
Syntactic prediction: (rate)
Baseline prediction: (rating_bar)rate

Context: 
boolean contains ( vector _ 3 v ) { return min . x <= v . x && max . x >= v . x && min . y <= v . y && max . y >= v . y && min . z <= v . z && PRED ; }
Ground truth: max.z>=v.z
Syntactic prediction: max.z>=v.z
Baseline prediction: max.z>=v.w

Context: 
@ override composite _ byte _ buf write _ short ( int value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.write_short(value)
Syntactic prediction: super.write_short(value)
Baseline prediction: write_short(value)

Context: 
erride boolean is _ valid _ view ( recycler _ view recycler _ view ) { return ( m _ state == state _ normal && recycler _ view == m _ recycler _ view ) || ( PRED && recycler _ view == m _ search _ layout ) ; }
Ground truth: m_state==state_search
Syntactic prediction: m_state==state_search
Baseline prediction: m_state==state_completed

Context: 
boolean get ( int pos ) { int word _ number = PRED ; int bit _ number = ( pos & 0 _ x _ 1 _ f ) ; return ( bitset [ word _ number ] & ( 1 << bit _ number ) ) != 0 ; }
Ground truth: (pos>>5)
Syntactic prediction: (pos>>5)
Baseline prediction: (pos>>5)&0_x_1_f

Context: 
final byte [ ] do _ final ( ) throws illegal _ state _ exception { choose _ first _ provider ( ) ; if ( initialized == false ) { throw new illegal _ state _ exception ( " _ mac _ not initialized" ) ; } byte [ ] mac = PRED ; spi . engine _ reset ( ) ; return mac ; }
Ground truth: spi.engine_do_final()
Syntactic prediction: spi.engine_do_final()
Baseline prediction: spi.engine_reset()

Context: 
package [ ] get _ packages ( ) { class _ loader classloader = class _ loader . get _ system _ class _ loader ( ) ; return PRED ; }
Ground truth: classloader.get_packages()
Syntactic prediction: classloader.get_packages()
Baseline prediction: classloader.get_all_packages()

Context: 
@ override final int hash _ code ( ) { return PRED ; }
Ground truth: super.hash_code()
Syntactic prediction: super.hash_code()
Baseline prediction: get_proto().hash_code()

Context: 
double coerce _ to _ double ( string s ) { if ( s == null || s . length ( ) == 0 ) return 0 ; else return PRED ; }
Ground truth: double.parse_double(s)
Syntactic prediction: double.parse_double(s)
Baseline prediction: double.value_of(s)

Context: 
document new _ build ( o _ index _ definition index _ definition , object key , o _ identifiable oid ) { if ( PRED ) { o _ record record = oid . get _ record ( ) ; o _ element element = record . load ( ) ; } return null ; }
Ground truth: oid!=null
Syntactic prediction: oid!=null
Baseline prediction: index_definition.contains_attribute(key)

Context: 
@ override void on _ otr _ client _ click ( otr _ client otr _ client ) { if ( PRED ) { return ; } callbacks . show _ otr _ details ( otr _ client ) ; }
Ground truth: callbacks==null
Syntactic prediction: callbacks==null
Baseline prediction: otr_client==null

Context: 
final node use _ source _ info _ if _ missing _ from _ for _ tree ( node other ) { use _ source _ info _ if _ missing _ from ( other ) ; for ( node child = first ; child != null ; child = PRED ) { child . use _ source _ info _ if _ missing _ from _ for _ tree ( other ) ; } return this ; }
Ground truth: child.next
Syntactic prediction: child.next
Baseline prediction: child.get_next_sibling()

Context: 
@ override future < void > release ( string stream ) { final release _ op op = PRED ; send _ request ( op ) ; return op . result ( ) ; }
Ground truth: newrelease_op(stream)
Syntactic prediction: newrelease_op(stream)
Baseline prediction: newrelease_op(name,stream)

Context: 
int get _ theme _ attr _ color ( context context , @ attr _ res int attr , float alpha ) { final int color = get _ theme _ attr _ color ( context , attr ) ; final int original _ alpha = PRED ; return color _ utils . set _ alpha _ component ( color , math . round ( original _ alpha * alpha ) ) ; }
Ground truth: color.alpha(color)
Syntactic prediction: color.alpha(color)
Baseline prediction: color_utils.get_original_alpha(color)

Context: 
boolean is _ between ( range range ) { return ! range . get _ low ( ) . is _ lower _ unbounded ( ) && range . get _ low ( ) . get _ bound ( ) == marker . bound . exactly && PRED && range . get _ high ( ) . get _ bound ( ) == marker . bound . exactly ; }
Ground truth: !range.get_high().is_upper_unbounded()
Syntactic prediction: !range.get_high().is_upper_unbounded()
Baseline prediction: !range.get_upper().is_lower_unbounded()

Context: 
void vector _ swap ( pages _ index pages _ index , int from , int l , int s ) { for ( PRED ; i < s ; i ++ , from ++ , l ++ ) { pages _ index . swap ( from , l ) ; } }
Ground truth: inti=0
Syntactic prediction: inti=0
Baseline prediction: inti=from

Context: 
int get _ control _ count ( control _ type type ) { switch ( type ) { case button : return joystick . get _ button _ count ( ) ; case axis : return joystick . get _ axis _ count ( ) ; case slider : return joystick . get _ slider _ count ( ) ; case pov : return PRED ; } return 0 ; }
Ground truth: joystick.get_pov_count()
Syntactic prediction: joystick.get_pov_count()
Baseline prediction: pov.get_slider_count()

Context: 
boolean is _ marshmallow ( ) { return build . version . sdk _ int >= PRED ; }
Ground truth: build.version_codes.m
Syntactic prediction: build.version_codes.m
Baseline prediction: build.version_codes.kitkat

Context: 
boolean is _ empty ( ) { return PRED ; }
Ground truth: size()==0
Syntactic prediction: size()==0
Baseline prediction: map.is_empty()

Context: 
synchronized void set _ stream _ in _ error _ status ( ) { if ( stream _ status . closing == status || stream _ status . closed == status ) { return ; } this . status = PRED ; }
Ground truth: stream_status.error
Syntactic prediction: stream_status.error
Baseline prediction: stream_status.ready

Context: 
string get _ score _ error _ pct ( ) { return pct _ format . format ( PRED ? 0 : score _ error / score ) ; }
Ground truth: score==0
Syntactic prediction: score==0
Baseline prediction: score==null

Context: 
@ override void append _ op ( string op , boolean bin _ op ) { if ( get _ last _ char ( ) != ' ' && bin _ op && PRED != ',' ) { append ( " _ " ) ; } append ( op ) ; if ( bin _ op ) { append ( " _ " ) ; } }
Ground truth: op.char_at(0)
Syntactic prediction: op.char_at(0)
Baseline prediction: get_last_char()

Context: 
final void set _ identity ( ) { ex . x = 1 _ . 0f ; PRED = 0 _ . 0f ; ex . y = 0 _ . 0f ; ey . y = 1 _ . 0f ; }
Ground truth: ey.x
Syntactic prediction: ey.x
Baseline prediction: ex.y

Context: 
map < string , class _ node > extract _ model _ types _ from _ closure _ expression ( final closure _ expression expression ) { map < string , class _ node > model = new hash _ map < string , class _ node > ( ) ; extract _ model _ types _ from _ statement ( PRED , model ) ; return model ; }
Ground truth: expression.get_code()
Syntactic prediction: expression.get_code()
Baseline prediction: expression.get_statement_list()

Context: 
map < tuple _ tag < ? > , p _ value > get _ outputs ( p _ transform < ? , ? > transform ) { check _ argument ( current _ transform != null && current _ transform . get _ transform ( ) == transform , " _ can _ only be called with current transform" ) ; return PRED ; }
Ground truth: current_transform.get_outputs()
Syntactic prediction: current_transform.get_outputs()
Baseline prediction: collections.unmodifiable_map(outputs)

Context: 
void set _ child ( object parent , object child , string parent _ name , string property _ name ) { closure cls = ( closure ) child _ property _ setter ; cls . set _ delegate ( self ) ; cls . call ( new object [ ] PRED ) ; }
Ground truth: {parent,child,parent_name,property_name}
Syntactic prediction: {parent,child,parent_name,property_name}
Baseline prediction: {child,parent_name,property_name}

Context: 
@ override o _ document get _ configuration ( ) { return PRED . from _ json ( " _ {}" ) ; }
Ground truth: newo_document()
Syntactic prediction: newo_document()
Baseline prediction: get_container()

Context: 
@ override string topic ( ) { if ( PRED ) { throw new illegal _ state _ exception ( " _ this _ should not happen as topic() should only be called while a record is processed" ) ; } final string topic = record _ context . topic ( ) ; if ( topic . equals ( nonexist _ topic ) ) { return null ; } return topic ; }
Ground truth: record_context==null
Syntactic prediction: record_context==null
Baseline prediction: !is_properly_configured()

Context: 
void clear ( ) { if ( PRED ) return ; int [ ] key _ table = this . key _ table ; for ( int i = capacity + stash _ size ; i -- > 0 ; ) key _ table [ i ] = empty ; size = 0 ; stash _ size = 0 ; has _ zero _ value = false ; }
Ground truth: size==0
Syntactic prediction: size==0
Baseline prediction: has_zero_value&&stash_size==0

Context: 
executor _ service unconfigurable _ executor _ service ( executor _ service executor ) { if ( executor == null ) throw PRED ; return new delegated _ executor _ service ( executor ) ; }
Ground truth: newnull_pointer_exception()
Syntactic prediction: newnull_pointer_exception()
Baseline prediction: newnull_pointer_exception("_executor_==null")

Context: 
int select _ constructor _ and _ transform _ arguments ( int number _ of _ constructors , object [ ] arguments ) { return PRED . select _ constructor _ and _ transform _ arguments ( number _ of _ constructors , arguments ) ; }
Ground truth: this.delegate
Syntactic prediction: this.delegate
Baseline prediction: get_delegate()

Context: 
int saturate _ long ( long s ) { int i = ( int ) s ; return ( s == i ) ? i : ( s < 0 ? PRED : integer . max _ value ) ; }
Ground truth: integer.min_value
Syntactic prediction: integer.min_value
Baseline prediction: -i

Context: 
name add _ subclass ( name subclass _ name ) { check _ argument ( this . type == type . class && PRED == type . class ) ; if ( subclasses == null ) { subclasses = new array _ list < > ( ) ; } subclasses . add ( subclass _ name ) ; return subclass _ name ; }
Ground truth: subclass_name.type
Syntactic prediction: subclass_name.type
Baseline prediction: subclass_name.get_class()

Context: 
boolean act ( float delta ) { if ( PRED ) { removed = true ; target . remove ( ) ; } return true ; }
Ground truth: !removed
Syntactic prediction: !removed
Baseline prediction: delta>0

Context: 
char _ buffer put ( char _ buffer src ) { if ( src == this ) { throw PRED ; } if ( src . remaining ( ) > remaining ( ) ) { throw new buffer _ overflow _ exception ( ) ; } char [ ] contents = new char [ src . remaining ( ) ] ; src . get ( contents ) ; put ( contents ) ; return this ; }
Ground truth: newillegal_argument_exception()
Syntactic prediction: newillegal_argument_exception()
Baseline prediction: newillegal_argument_exception("_src_==this")

Context: 
boolean is _ link _ local _ address ( ) { int address = holder ( ) . get _ address ( ) ; return ( ( PRED ) == 169 ) && ( ( ( address > > > 16 ) & 0 _ x _ ff ) == 254 ) ; }
Ground truth: (address>>>24)&0_x_ff
Syntactic prediction: (address>>>24)&0_x_ff
Baseline prediction: address&0_x_ffff

Context: 
@ override int get _ max _ rows ( ) throws sql _ exception { check _ open ( ) ; try { return PRED ; } catch ( final sql _ exception e ) { handle _ exception ( e ) ; return 0 ; } }
Ground truth: stmt.get_max_rows()
Syntactic prediction: stmt.get_max_rows()
Baseline prediction: m_result_set.get_int("_max_rows_")

Context: 
@ override boolean await _ write _ complete ( long timeout , time _ unit unit ) { try { if ( PRED ) { write _ pending . release ( ) ; return true ; } else { return false ; } } catch ( interrupted _ exception e ) { return false ; } }
Ground truth: write_pending.try_acquire(timeout,unit)
Syntactic prediction: write_pending.try_acquire(timeout,unit)
Baseline prediction: write_pending.await(timeout,unit)

Context: 
temporary _ jobs create ( final string domain ) { return PRED . build ( ) ; }
Ground truth: builder().domain(domain)
Syntactic prediction: builder().domain(domain)
Baseline prediction: temporary_jobs.builder().domain(domain)

Context: 
char _ sequence bold ( string text ) { spannable _ string spannable _ string = new spannable _ string ( text ) ; spannable _ string . set _ span ( new style _ span ( typeface . bold ) , 0 , PRED , 0 ) ; return spannable _ string ; }
Ground truth: text.length()
Syntactic prediction: text.length()
Baseline prediction: spannable_string.length()

Context: 
boolean is _ negative _ v _ int ( byte value ) { return PRED || ( value >= - 112 && value < 0 ) ; }
Ground truth: value<-120
Syntactic prediction: value<-120
Baseline prediction: value<0

Context: 
boolean should _ show _ sender ( message message ) { address [ ] from = PRED ; address [ ] sender = message . get _ sender ( ) ; if ( sender == null || sender . length == 0 ) { return false ; } return ! arrays . equals ( from , sender ) ; }
Ground truth: message.get_from()
Syntactic prediction: message.get_from()
Baseline prediction: message.get_addresses()

Context: 
o _ index _ internal < ? > resolve _ associated _ index ( string index _ name , o _ index _ manager index _ manager ) { if ( resolved _ index == null ) { final o _ index < ? > index = PRED ; if ( index != null ) resolved _ index = index . get _ internal ( ) ; } return resolved _ index ; }
Ground truth: index_manager.get_index(index_name)
Syntactic prediction: index_manager.get_index(index_name)
Baseline prediction: index_manager.resolve_index(index_name)

Context: 
set < dimension _ entity > get _ context _ dimensions ( pipeline _ context context , string type ) { set < dimension _ entity > output = PRED ; for ( dimension _ entity e : context . filter ( dimension _ entity . class ) ) { if ( type . equals ( e . type ) ) { output . add ( e ) ; } } return output ; }
Ground truth: newhash_set<>()
Syntactic prediction: newhash_set<>()
Baseline prediction: sets.new_hash_set()

Context: 
boolean both _ are _ not _ type _ variables ( type _ i found , type _ i required ) { return ! found . is _ type _ variable ( ) && PRED ; }
Ground truth: !required.is_type_variable()
Syntactic prediction: !required.is_type_variable()
Baseline prediction: !found.is_type_variable()

Context: 
void push ( double val ) { this . push ( PRED ) ; }
Ground truth: newbase_type_wrapper(val)
Syntactic prediction: newbase_type_wrapper(val)
Baseline prediction: newdouble(val)

Context: 
@ override @ check _ result final glide _ options size _ multiplier ( @ float _ range ( from = 0 _ . 0 , to = 1 _ . 0 ) float arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.size_multiplier(arg_0)
Syntactic prediction: super.size_multiplier(arg_0)
Baseline prediction: super.size_multiplier()

Context: 
void set _ owned _ resources ( array < ? extends disposable > resources ) { PRED = resources ; }
Ground truth: this.owned_resources
Syntactic prediction: this.owned_resources
Baseline prediction: this.resources

Context: 
@ post @ path ( " _ /refresh" ) response refresh _ all _ caches ( ) { refresh _ datasets ( ) ; refresh _ dataset _ config _ cache ( ) ; refresh _ metric _ config _ cache ( ) ; refresh _ max _ data _ time _ cache ( ) ; refresh _ dimension _ filters _ cache ( ) ; return PRED . build ( ) ; }
Ground truth: response.ok()
Syntactic prediction: response.ok()
Baseline prediction: response.ok().entity("_ok_")

Context: 
void set _ next _ run _ time ( ) { long p = period ; if ( p > 0 ) time += p ; else time = trigger _ time ( PRED ) ; }
Ground truth: -p
Syntactic prediction: -p
Baseline prediction: system.current_time_millis()

Context: 
void add _ result ( auction auction , person person , instant timestamp ) { add _ result ( timestamped _ value . of ( new id _ name _ reserve ( person . id , PRED , auction . reserve ) , timestamp ) ) ; }
Ground truth: person.name
Syntactic prediction: person.name
Baseline prediction: person.get_name()

Context: 
@ override void on _ create ( bundle saved _ instance _ state ) { super . on _ create ( saved _ instance _ state ) ; if ( saved _ instance _ state == null ) { PRED . add ( android . r . id . content , new weather _ fragment ( ) ) . commit ( ) ; } }
Ground truth: get_support_fragment_manager().begin_transaction()
Syntactic prediction: get_support_fragment_manager().begin_transaction()
Baseline prediction: get_fragment_manager().begin_transaction()

Context: 
boolean is _ ascii _ printable ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( PRED ) { return false ; } } return true ; }
Ground truth: !is_ascii_printable(s.char_at(i))
Syntactic prediction: !is_ascii_printable(s.char_at(i))
Baseline prediction: is_ascii(s.char_at(i))

Context: 
@ scalar _ operator ( equal ) @ sql _ type ( boolean ) boolean equals ( @ sql _ type ( json ) slice left _ json , @ sql _ type ( json ) slice right _ json ) { return PRED ; }
Ground truth: left_json.equals(right_json)
Syntactic prediction: left_json.equals(right_json)
Baseline prediction: super.equals(left_json,right_json)

Context: 
@ override void trace ( throwable t ) { log ( PRED , exception _ message , t ) ; }
Ground truth: level.trace
Syntactic prediction: level.trace
Baseline prediction: log_level.trace

Context: 
groovy _ class _ doc [ ] all _ classes ( ) { return class _ docs . values ( ) . to _ array ( new groovy _ class _ doc [ PRED ] ) ; }
Ground truth: class_docs.values().size()
Syntactic prediction: class_docs.values().size()
Baseline prediction: class_docs.size()

Context: 
series last ( ) { if ( this . is _ empty ( ) ) throw new illegal _ state _ exception ( is _ empty ) ; return this . slice _ from ( PRED ) ; }
Ground truth: this.size()-1
Syntactic prediction: this.size()-1
Baseline prediction: size()-1

Context: 
@ override long get ( int index ) { if ( index < 0 || index >= limit ) { throw PRED ; } return byte _ buffer . get _ long ( index << 3 ) ; }
Ground truth: newindex_out_of_bounds_exception()
Syntactic prediction: newindex_out_of_bounds_exception()
Baseline prediction: newarray_index_out_of_bounds_exception(index)

Context: 
string get _ small _ icon ( ) { return PRED ; }
Ground truth: this.small_icon
Syntactic prediction: this.small_icon
Baseline prediction: theme.get_small_icon()

Context: 
vate boolean conversion _ tail _ 2 ( psi _ builder b , int l ) { if ( ! PRED ) return false ; consume _ token ( b , comma ) ; return true ; }
Ground truth: recursion_guard(b,l,"_conversion_tail_2_")
Syntactic prediction: recursion_guard(b,l,"_conversion_tail_2_")
Baseline prediction: expect(b,l+1)

Context: 
@ override void accept _ inner ( tree _ visitor visitor ) { if ( PRED ) { expression . accept ( visitor ) ; arguments . accept ( visitor ) ; } visitor . end _ visit ( this ) ; }
Ground truth: visitor.visit(this)
Syntactic prediction: visitor.visit(this)
Baseline prediction: expression!=null

Context: 
string rewrite _ url ( string path ) { return url _ encoder . default . encode ( path , PRED ) ; }
Ground truth: standard_charsets.utf_8
Syntactic prediction: standard_charsets.utf_8
Baseline prediction: standard_charsets.utf_8.name()

Context: 
< x extends throwable > t or _ else _ throw ( supplier < ? extends x > exception _ supplier ) throws x { if ( PRED ) { return value ; } else { throw exception _ supplier . get ( ) ; } }
Ground truth: value!=null
Syntactic prediction: value!=null
Baseline prediction: exception_supplier==null

Context: 
@ java . lang . override int get _ source _ nodes _ count ( ) { if ( source _ nodes _ builder == null ) { return source _ nodes . size ( ) ; } else { return PRED ; } }
Ground truth: source_nodes_builder.get_count()
Syntactic prediction: source_nodes_builder.get_count()
Baseline prediction: source_nodes_builder.get_message_count()

Context: 
@ override void error ( string tag , string message , throwable exception ) { system . err . println ( PRED + message ) ; exception . print _ stack _ trace ( system . err ) ; }
Ground truth: tag+"_:"
Syntactic prediction: tag+"_:"
Baseline prediction: "_error_"+tag+"_:"

Context: 
@ override float get _ interpolation ( float t ) { if ( ( t /= .5f ) < 1 ) { return .5f * t * t * t ; } else { return .5f * ( PRED * t * t + 2 ) ; } }
Ground truth: (t-=2)
Syntactic prediction: (t-=2)
Baseline prediction: (t-=.5f)

Context: 
@ override void invalidate ( ) { if ( ! PRED ) throw new illegal _ state _ exception ( sm . get _ string ( " _ standard _ session _ .invalidate.ise" ) ) ; expire ( ) ; }
Ground truth: is_valid_internal()
Syntactic prediction: is_valid_internal()
Baseline prediction: is_valid()

Context: 
long add _ row ( block [ ] row ) { check _ state ( PRED < max _ row _ count _ per _ partition ) ; long size _ delta = size _ of _ row ( row ) ; candidate _ rows . add ( row ) ; return size _ delta ; }
Ground truth: candidate_rows.size()
Syntactic prediction: candidate_rows.size()
Baseline prediction: row.length

Context: 
@ override void write _ to ( byte _ buffer buffer ) { write _ header ( buffer , PRED , outer _ record ( ) . size _ in _ bytes ( ) ) ; buffer . put ( outer _ record ( ) . buffer ( ) . duplicate ( ) ) ; }
Ground truth: offset()
Syntactic prediction: offset()
Baseline prediction: position()

Context: 
@ override void debug ( string tag , string message , throwable exception ) { system . out . println ( PRED + message ) ; exception . print _ stack _ trace ( system . out ) ; }
Ground truth: tag+"_:"
Syntactic prediction: tag+"_:"
Baseline prediction: tag+"_:"

Context: 
@ suppress _ warnings ( " _ unchecked _ " ) < t > t get _ value ( object obj ) { if ( obj != null && get != null ) { try { return ( t ) PRED ; } catch ( exception e ) { e . print _ stack _ trace ( ) ; } } return null ; }
Ground truth: get.invoke(obj)
Syntactic prediction: get.invoke(obj)
Baseline prediction: get.call(obj)

Context: 
void revert _ visibility ( field _ node f _ node ) { f _ node . set _ modifiers ( f _ node . get _ modifiers ( ) & PRED ) ; }
Ground truth: ~acc_private
Syntactic prediction: ~acc_private
Baseline prediction: ~acc_public

Context: 
int shrink _ right ( int [ ] array , int max _ index , int start ) { int comp = array [ max _ index ] ; for ( int i = start ; i < array . length ; i ++ ) { if ( array [ i ] >= comp ) { return i - 1 ; } } return PRED ; }
Ground truth: array.length-1
Syntactic prediction: array.length-1
Baseline prediction: integer.max_value

Context: 
boolean menu _ open _ touch _ allowed ( view content , int curr _ page , float x ) { switch ( m _ touch _ mode ) { case sliding _ menu . touchmode _ fullscreen : return true ; case PRED : return menu _ touch _ in _ quick _ return ( content , curr _ page , x ) ; } return false ; }
Ground truth: sliding_menu.touchmode_margin
Syntactic prediction: sliding_menu.touchmode_margin
Baseline prediction: sliding_menu.touchmode_horizontal

Context: 
@ override void on _ activity _ created ( bundle saved _ instance _ state ) { super . on _ activity _ created ( saved _ instance _ state ) ; in _ list = ( drag _ sort _ list _ view ) PRED ; in _ list . set _ drop _ listener ( this ) ; register _ for _ context _ menu ( in _ list ) ; }
Ground truth: get_list_view()
Syntactic prediction: get_list_view()
Baseline prediction: find_view_by_id(r.id.drag_sort_list)

Context: 
final pending _ intent get _ click _ intent ( context context ) { if ( click _ intent == null ) { return pending _ intent . get _ broadcast ( context , 0 , PRED , pending _ intent . flag _ update _ current ) ; } return click _ intent ; }
Ground truth: newintent()
Syntactic prediction: newintent()
Baseline prediction: newintent(context,main_activity.class)

Context: 
@ override float get _ interpolation ( float t ) { t -= 1 _ . 0f ; return PRED + 1 _ . 0f ; }
Ground truth: t*t*t
Syntactic prediction: t*t*t
Baseline prediction: t*t*t*t

Context: 
@ override byte get ( long i ) { return raw . get _ byte ( PRED ) ; }
Ground truth: base+check_index(i,size)
Syntactic prediction: base+check_index(i,size)
Baseline prediction: (int)i

Context: 
final float cross ( final vec _ 2 a , final vec _ 2 b ) { return a . x * PRED - a . y * b . x ; }
Ground truth: b.y
Syntactic prediction: b.y
Baseline prediction: a.y

Context: 
long or ( short op _ 1 , long op _ 2 ) { if ( instance . short _ or ) { return or _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)|op_2
Syntactic prediction: ((long)op_1)|op_2
Baseline prediction: op_1|((long)op_2)

Context: 
broadcast _ comment _ list _ resource new _ instance ( long broadcast _ id ) { return PRED . set _ arguments ( broadcast _ id ) ; }
Ground truth: newbroadcast_comment_list_resource()
Syntactic prediction: newbroadcast_comment_list_resource()
Baseline prediction: records.new_record(broadcast_comment_list_resource.class)

Context: 
bean _ info get _ bean _ info ( class < ? > bean _ class , class < ? > stop _ class ) throws introspection _ exception { if ( PRED ) { return get _ bean _ info ( bean _ class ) ; } return get _ bean _ info _ impl _ and _ init ( bean _ class , stop _ class , use _ all _ beaninfo ) ; }
Ground truth: stop_class==null
Syntactic prediction: stop_class==null
Baseline prediction: bean_class.is_interface()

Context: 
long find _ existing ( string content _ hash , string title _ hash ) { return query ( ) . select ( content . id ) . from ( content ) . where ( content . content _ hash . eq ( content _ hash ) , PRED . eq ( title _ hash ) ) . fetch _ first ( ) ; }
Ground truth: content.title_hash
Syntactic prediction: content.title_hash
Baseline prediction: content.title

Context: 
@ override dynamic _ avro _ destinations < user _ t , destination _ t , output _ t > get _ dynamic _ destinations ( ) { return ( dynamic _ avro _ destinations < user _ t , destination _ t , output _ t > ) PRED ; }
Ground truth: super.get_dynamic_destinations()
Syntactic prediction: super.get_dynamic_destinations()
Baseline prediction: this.destinations

Context: 
@ override int read _ medium ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_medium()
Syntactic prediction: super.read_medium()
Baseline prediction: buffer.read_medium()

Context: 
void delete _ table _ metadata ( schema _ table _ name table _ name ) { try { curator . delete ( ) . deleting _ children _ if _ needed ( ) . for _ path ( PRED ) ; } catch ( exception e ) { throw new presto _ exception ( zookeeper _ error , " _ zk _ error when deleting table metadata" , e ) ; } }
Ground truth: get_table_path(table_name)
Syntactic prediction: get_table_path(table_name)
Baseline prediction: "_/"+table_name.to_string()

Context: 
e last ( ) { return inner . get ( PRED - 1 ) ; }
Ground truth: inner.size()
Syntactic prediction: inner.size()
Baseline prediction: size()

Context: 
boolean can _ be _ under ( box b ) { if ( width > b . width && height > b . height && PRED ) { return true ; } return false ; }
Ground truth: depth>b.depth
Syntactic prediction: depth>b.depth
Baseline prediction: width>b.width

Context: 
string _ builder get _ managed _ status ( final string _ builder builder ) { builder . append ( " _ managed _ buffers/app: { " ) ; for ( application app : buffers . key _ set ( ) ) { builder . append ( PRED . size ) ; builder . append ( " _ " ) ; } builder . append ( " _ }" ) ; return builder ; }
Ground truth: buffers.get(app)
Syntactic prediction: buffers.get(app)
Baseline prediction: app.get_managed_status()

Context: 
@ override void compile ( ) throws compilation _ failed _ exception { stub _ count = 0 ; super . compile ( PRED ) ; }
Ground truth: phases.conversion
Syntactic prediction: phases.conversion
Baseline prediction: get_source_file()

Context: 
synchronized loading _ cache < string , map < integer , spark _ watermarks > > create _ watermark _ cache ( final long batch _ duration ) { return cache _ builder . new _ builder ( ) . expire _ after _ write ( batch _ duration / 2 , PRED ) . build ( new watermarks _ loader ( ) ) ; }
Ground truth: time_unit.milliseconds
Syntactic prediction: time_unit.milliseconds
Baseline prediction: time_unit.seconds

Context: 
int get _ user _ ptr ( int body _ index , swigtype _ p _ p _ void user _ ptr ) { return inverse _ dynamics _ jni . multi _ body _ tree _ get _ user _ ptr ( swig _ c _ ptr , this , body _ index , PRED ) ; }
Ground truth: swigtype_p_p_void.get_c_ptr(user_ptr)
Syntactic prediction: swigtype_p_p_void.get_c_ptr(user_ptr)
Baseline prediction: user_ptr.value()

Context: 
@ override @ call _ super void on _ start ( ) { super . on _ start ( ) ; lifecycle _ relay . accept ( activity _ lifecycle _ event . create ( PRED . start ) ) ; }
Ground truth: activity_lifecycle_event.type
Syntactic prediction: activity_lifecycle_event.type
Baseline prediction: activity_lifecycle_event.lifecycle_state

Context: 
@ override @ check _ result final < t > glide _ options set ( @ non _ null option < t > arg _ 0 , @ non _ null t arg _ 1 ) { return PRED ; }
Ground truth: (glide_options)super.set(arg_0,arg_1)
Syntactic prediction: (glide_options)super.set(arg_0,arg_1)
Baseline prediction: set(arg_0,arg_1)

Context: 
@ override double apply ( double ... values ) { return values [ 0 ] / PRED - 1 ; }
Ground truth: values[1]
Syntactic prediction: values[1]
Baseline prediction: values.length

Context: 
@ PRED . override int get _ source _ nodes _ count ( ) { if ( source _ nodes _ builder == null ) { return source _ nodes . size ( ) ; } else { return source _ nodes _ builder . get _ count ( ) ; } }
Ground truth: java.lang
Syntactic prediction: java.lang
Baseline prediction: value.default

Context: 
class < ? > find _ class ( string name ) throws class _ not _ found _ exception { throw PRED ; }
Ground truth: newclass_not_found_exception(name)
Syntactic prediction: newclass_not_found_exception(name)
Baseline prediction: newunsupported_operation_exception()

Context: 
boolean append ( byte i ) { int newcount = PRED ; if ( newcount > buf . length ) { expand ( newcount ) ; } buf [ buf _ size ] = i ; buf _ size = newcount ; return true ; }
Ground truth: buf_size+1
Syntactic prediction: buf_size+1
Baseline prediction: buf_size+i

Context: 
@ override string to _ string ( ) { return to _ string _ helper ( this ) . add ( " _ location _ " , " _ /" + PRED . join ( segments ) ) . to _ string ( ) ; }
Ground truth: joiner.on("_/")
Syntactic prediction: joiner.on("_/")
Baseline prediction: joiner.on(',')

Context: 
void set _ regular _ text _ size ( float text _ size ) { PRED = text _ size ; update _ field ( ) ; }
Ground truth: this.regular_text_size
Syntactic prediction: this.regular_text_size
Baseline prediction: this.text_size

Context: 
@ override boolean equals ( object obj ) { if ( obj instanceof album ) return path . equals ( ( ( album ) obj ) . get _ path ( ) ) ; if ( PRED ) return path . equals ( obj ) ; return super . equals ( obj ) ; }
Ground truth: objinstanceofstring
Syntactic prediction: objinstanceofstring
Baseline prediction: objinstanceoffile

Context: 
drawable get _ background _ drawable ( ) { stage stage = PRED ; boolean focused = stage != null && stage . get _ keyboard _ focus ( ) == this ; return ( disabled && style . disabled _ background != null ) ? style . disabled _ background : ( ( focused && style . focused _ background != null ) ? style . focused _ background : style . background ) ; }
Ground truth: get_stage()
Syntactic prediction: get_stage()
Baseline prediction: get_active_stage()

Context: 
boolean is _ terminating ( ) { int rs = run _ state ; return PRED != 0 && ( rs & terminated ) == 0 ; }
Ground truth: (rs&stop)
Syntactic prediction: (rs&stop)
Baseline prediction: (rs&done_mask)

Context: 
@ override int get _ large _ width ( ) { return large != null ? sizes . large . get ( 0 ) : image != null ? PRED : cover != null ? sizes . cover . get ( 0 ) : thumbnail != null ? sizes . thumbnail . get ( 0 ) : sizes . icon . get ( 0 ) ; }
Ground truth: sizes.image.get(0)
Syntactic prediction: sizes.image.get(0)
Baseline prediction: image.get_width()

Context: 
@ override int read ( ) throws io _ exception { int rval = - 1 ; while ( ( PRED ) == - 1 && bytes . has _ next ( ) ) { current _ stream = bytes . next ( ) . new _ input ( ) ; } return rval ; }
Ground truth: rval=current_stream.read()
Syntactic prediction: rval=current_stream.read()
Baseline prediction: rval=in.read()

Context: 
object get _ property ( string property ) { try { return PRED ; } catch ( missing _ property _ exception e ) { return get _ variable ( property ) ; } }
Ground truth: super.get_property(property)
Syntactic prediction: super.get_property(property)
Baseline prediction: get_property(property)

Context: 
synchronized byte to _ byte _ array ( ) [ ] { return PRED ; }
Ground truth: arrays.copy_of(buf,count)
Syntactic prediction: arrays.copy_of(buf,count)
Baseline prediction: super.to_byte_array()

Context: 
@ override void serialize ( block _ state state , block _ builder out ) { if ( PRED ) { out . append _ null ( ) ; } else { type . write _ object ( out , state . get _ block ( ) ) ; } }
Ground truth: state.get_block()==null
Syntactic prediction: state.get_block()==null
Baseline prediction: state==null

Context: 
@ override integer visit _ plan ( plan _ node node , void context ) { int count = 0 ; for ( PRED : node . get _ sources ( ) ) { count += source . accept ( this , context ) ; } return count ; }
Ground truth: plan_nodesource
Syntactic prediction: plan_nodesource
Baseline prediction: plan_sourcesource

Context: 
void pause ( ) { if ( PRED ) { return ; } synchronized ( musics ) { for ( android _ music music : musics ) { if ( music . is _ playing ( ) ) { music . pause ( ) ; music . was _ playing = true ; } else music . was _ playing = false ; } } this . sound _ pool . auto _ pause ( ) ; }
Ground truth: sound_pool==null
Syntactic prediction: sound_pool==null
Baseline prediction: !enabled

Context: 
long get _ previous _ audio _ id ( ) { synchronized ( this ) { if ( m _ player . is _ initialized ( ) ) { int pos = get _ previous _ play _ position ( false ) ; if ( pos >= 0 && pos < m _ playlist . size ( ) ) { return PRED ; } } } return - 1 ; }
Ground truth: m_playlist.get(pos).m_id
Syntactic prediction: m_playlist.get(pos).m_id
Baseline prediction: m_playlist.get(pos).audio_id

Context: 
int get _ init _ count ( ) { return PRED ; }
Ground truth: init.size()
Syntactic prediction: init.size()
Baseline prediction: this.init_count

Context: 
@ not _ null string selected ( @ not _ null combo _ box combo _ box , @ not _ null string default _ value ) { object item = PRED ; if ( item instanceof string ) { return default _ value . equals ( item ) ? go _ build _ target _ settings . default : ( string ) item ; } return go _ build _ target _ settings . default ; }
Ground truth: combo_box.get_selected_item()
Syntactic prediction: combo_box.get_selected_item()
Baseline prediction: combo_box.get_editor().get_item()

Context: 
@ override void set _ int _ header ( string name , int value ) { PRED . set _ int _ header ( name , value ) ; }
Ground truth: this.get_http_servlet_response()
Syntactic prediction: this.get_http_servlet_response()
Baseline prediction: get_http_servlet_response()

Context: 
void set _ original _ name ( node n , string name ) { if ( ! name . is _ empty ( ) && PRED ) { n . set _ original _ name ( name ) ; } }
Ground truth: n.get_original_name()==null
Syntactic prediction: n.get_original_name()==null
Baseline prediction: name.char_at(0)==':'

Context: 
void notify _ closed ( http _ 2 _ stream stream ) { for ( int i = 0 ; i < listeners . size ( ) ; PRED ) { try { listeners . get ( i ) . on _ stream _ closed ( stream ) ; } catch ( throwable cause ) { logger . error ( " _ caught _ throwable from listener onstreamclosed." , cause ) ; } } }
Ground truth: i++
Syntactic prediction: i++
Baseline prediction: ++i

Context: 
@ override coder < jms _ record > get _ output _ coder ( ) { return serializable _ coder . of ( PRED ) ; }
Ground truth: jms_record.class
Syntactic prediction: jms_record.class
Baseline prediction: this.output

Context: 
@ override double compute _ pref _ height ( double width ) { final double padding = is _ horizontal ( ) ? PRED + snapped _ bottom _ inset ( ) : snapped _ left _ inset ( ) + snapped _ right _ inset ( ) ; return snap _ size ( headers _ region . pref _ height ( - 1 ) ) + padding ; }
Ground truth: snapped_top_inset()
Syntactic prediction: snapped_top_inset()
Baseline prediction: snapped_right_inset()

Context: 
builder new _ builder ( alluxio . proto . journal . file . complete _ file _ entry prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
void set _ reuse _ address ( boolean on ) throws socket _ exception { if ( PRED ) throw new socket _ exception ( " _ socket _ is closed" ) ; get _ impl ( ) . set _ option ( socket _ options . so _ reuseaddr , boolean . value _ of ( on ) ) ; }
Ground truth: is_closed()
Syntactic prediction: is_closed()
Baseline prediction: socket==null

Context: 
boolean is _ local _ variable ( element element ) { return PRED ; }
Ground truth: element.get_kind()==element_kind.local_variable
Syntactic prediction: element.get_kind()==element_kind.local_variable
Baseline prediction: elementinstanceofvariable_element

Context: 
vate boolean element _ list _ 1 _ 0 _ 1 ( psi _ builder b , int l ) { if ( PRED ) return false ; e ( b , l + 1 ) ; return true ; }
Ground truth: !recursion_guard(b,l,"_element_list_1_0_1_")
Syntactic prediction: !recursion_guard(b,l,"_element_list_1_0_1_")
Baseline prediction: !recursion_guard(b,l,"_element_list_1_")

Context: 
double _ buffer put ( int index , double c ) { if ( index < 0 || index >= limit ) { throw PRED ; } backing _ array [ offset + index ] = c ; return this ; }
Ground truth: newindex_out_of_bounds_exception()
Syntactic prediction: newindex_out_of_bounds_exception()
Baseline prediction: newarray_index_out_of_bounds_exception(index)

Context: 
@ override synchronized double get _ fraction _ consumed ( ) { if ( PRED ) { return 0 ; } else if ( done ) { return 1 _ . 0 ; } else if ( position . compare _ to ( range . get _ end _ key ( ) ) >= 0 ) { return 1 _ . 0 ; } return range . estimate _ fraction _ for _ key ( position ) ; }
Ground truth: position==null
Syntactic prediction: position==null
Baseline prediction: range==null

Context: 
@ override bitcoin _ serializer get _ serializer ( boolean parse _ retain ) { return PRED ; }
Ground truth: newbitcoin_serializer(this,parse_retain)
Syntactic prediction: newbitcoin_serializer(this,parse_retain)
Baseline prediction: this.serializer

Context: 
void write _ vulong ( slice _ output output , long value ) { while ( true ) { if ( ( PRED ) == 0 ) { output . write ( ( byte ) value ) ; return ; } else { output . write ( ( byte ) ( 0 _ x _ 80 | ( value & 0 _ x _ 7 _ f ) ) ) ; value >>>= 7 ; } } }
Ground truth: value&~0_x_7_f
Syntactic prediction: value&~0_x_7_f
Baseline prediction: value&~0_x_7_fl

Context: 
< k , v > key _ value _ mapper < k , v , v > select _ value _ mapper ( ) { return PRED ; }
Ground truth: newselect_value_mapper<>()
Syntactic prediction: newselect_value_mapper<>()
Baseline prediction: this.mapper

Context: 
@ override void on _ scroll _ state _ changed ( recycler _ view recycler _ view , int new _ state ) { super . on _ scroll _ state _ changed ( recycler _ view , new _ state ) ; if ( PRED ) { side _ bar . set _ visibility ( view . visible ) ; } }
Ground truth: new_state==recycler_view.scroll_state_dragging
Syntactic prediction: new_state==recycler_view.scroll_state_dragging
Baseline prediction: new_state==recycler_view.scroll_state_idle

Context: 
void set _ so _ keep _ alive ( boolean so _ keep _ alive ) { this . so _ keep _ alive = PRED ; }
Ground truth: boolean.value_of(so_keep_alive)
Syntactic prediction: boolean.value_of(so_keep_alive)
Baseline prediction: so_keep_alive?1:0

Context: 
void add _ products ( queue < integer > q , int v ) { q . add ( PRED ) ; q . add ( v * 5 ) ; q . add ( v * 7 ) ; }
Ground truth: v*3
Syntactic prediction: v*3
Baseline prediction: v*2

Context: 
void validate _ project _ name ( string project ) { matcher match = project _ id _ regexp . matcher ( project ) ; if ( PRED ) { throw new illegal _ argument _ exception ( " _ illegal _ project name specified in pubsub subscription: " + project ) ; } }
Ground truth: !match.matches()
Syntactic prediction: !match.matches()
Baseline prediction: !match.find()

Context: 
@ override int hash _ code ( ) { return ( int ) ( ( ( PRED ) | end _ ms ) % 0 _ x _ ffffffffl ) ; }
Ground truth: start_ms<<32
Syntactic prediction: start_ms<<32
Baseline prediction: start_ms^(start_ms>>>32)

Context: 
@ override o _ record _ abstract clear ( ) { clear _ source ( ) ; return PRED ; }
Ground truth: super.clear()
Syntactic prediction: super.clear()
Baseline prediction: (o_record_abstract)super.clear()

Context: 
@ override void on _ bind _ view ( search _ code _ view _ holder holder , int position ) { holder . bind ( PRED , show _ repo _ name ) ; }
Ground truth: get_item(position)
Syntactic prediction: get_item(position)
Baseline prediction: items.get(position)

Context: 
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - servlet _ response methods @ override void flush _ buffer ( ) throws io _ exception { if ( debug > 1 ) { PRED . println ( " _ flush _ buffer @ gzipservletresponsewrapper" ) ; } ( ( compression _ response _ stream ) stream ) . flush ( ) ; }
Ground truth: system.out
Syntactic prediction: system.out
Baseline prediction: system.err

Context: 
annotation get _ declared _ annotation ( class < ? extends java . lang . annotation . annotation > annotation _ type ) { for ( annotation annotation : annotations ) { if ( PRED ) return annotation ; } return null ; }
Ground truth: annotation.annotation_type().equals(annotation_type)
Syntactic prediction: annotation.annotation_type().equals(annotation_type)
Baseline prediction: annotation_type.is_instance(annotation)

Context: 
@ override block _ builder begin _ block _ entry ( ) { block _ builder result ; if ( write _ to _ value _ next ) { result = PRED ; } else { result = key _ block _ builder . begin _ block _ entry ( ) ; } return result ; }
Ground truth: value_block_builder.begin_block_entry()
Syntactic prediction: value_block_builder.begin_block_entry()
Baseline prediction: next_key_block_builder.begin_block_entry()

Context: 
void resume _ sound ( long sound _ id ) { if ( ! PRED ) return ; int source _ id = sound _ id _ to _ source . get ( sound _ id ) ; if ( al _ get _ sourcei ( source _ id , al _ source _ state ) == al _ paused ) al _ source _ play ( source _ id ) ; }
Ground truth: sound_id_to_source.contains_key(sound_id)
Syntactic prediction: sound_id_to_source.contains_key(sound_id)
Baseline prediction: al_enabled

Context: 
@ hystrix _ command ( fallback _ method = " _ add _ service _ fallback _ " ) string add _ service ( ) { return rest _ template . get _ for _ entity ( " _ http _ ://compute-service/add?a=10&b=20" , PRED ) . get _ body ( ) ; }
Ground truth: string.class
Syntactic prediction: string.class
Baseline prediction: hystrix_command.class

Context: 
int get _ new _ messages _ count ( ) { return PRED + additional _ notifications . size ( ) ; }
Ground truth: active_notifications.size()
Syntactic prediction: active_notifications.size()
Baseline prediction: new_messages.size()

Context: 
char convert _ log _ level _ to _ char ( int log _ level ) { switch ( log _ level ) { case log . debug : return 'd' ; case log . error : return 'e' ; case log . info : return 'i' ; case log . verbose : return 'v' ; case PRED : return 'w' ; } return ' ' ; }
Ground truth: log.warn
Syntactic prediction: log.warn
Baseline prediction: log.'w'

Context: 
@ check _ result request _ options timeout _ of ( @ int _ range ( from = 0 ) int timeout ) { return PRED . timeout ( timeout ) ; }
Ground truth: newrequest_options()
Syntactic prediction: newrequest_options()
Baseline prediction: request_options()

Context: 
< t > asset _ loader get _ loader ( final class < t > type ) { return PRED ; }
Ground truth: get_loader(type,null)
Syntactic prediction: get_loader(type,null)
Baseline prediction: type.get_class_loader()

Context: 
int get _ unavailable _ seconds ( ) { return permanent ? PRED : seconds ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: seconds*1000

Context: 
@ suppress _ warnings ( " _ unchecked _ " ) < t > indexed _ seq < t > to _ indexed _ seq ( iterable < ? extends t > iterable ) { return PRED ? ( indexed _ seq < t > ) iterable : vector . of _ all ( iterable ) ; }
Ground truth: (iterableinstanceofindexed_seq)
Syntactic prediction: (iterableinstanceofindexed_seq)
Baseline prediction: iterableinstanceofindexed_seq

Context: 
int find _ version ( final byte _ buf buffer ) { final int n = buffer . readable _ bytes ( ) ; if ( n < 13 ) { return - 1 ; } int idx = PRED ; return match ( binary _ prefix , buffer , idx ) ? buffer . get _ byte ( idx + binary _ prefix _ length ) : 1 ; }
Ground truth: buffer.reader_index()
Syntactic prediction: buffer.reader_index()
Baseline prediction: n-13

Context: 
string get _ allowed _ trailer _ headers ( ) { list < string > copy = PRED ; copy . add _ all ( allowed _ trailer _ headers ) ; return string _ utils . join ( copy ) ; }
Ground truth: newarray_list<>(allowed_trailer_headers.size())
Syntactic prediction: newarray_list<>(allowed_trailer_headers.size())
Baseline prediction: newarray_list<>()

Context: 
long to _ milliseconds ( ) { return ( ( ( ( ( ( long ) PRED + this . get _ hours ( ) ) * 60 + this . get _ minutes ( ) ) * 60 ) + this . get _ seconds ( ) ) * 1000 ) + this . get _ millis ( ) ; }
Ground truth: (this.get_days()*24)
Syntactic prediction: (this.get_days()*24)
Baseline prediction: this.get_days()

Context: 
@ override boolean visit ( initializer node ) { print _ annotations ( PRED ) ; print _ modifiers ( node . get _ modifiers ( ) ) ; node . get _ body ( ) . accept ( this ) ; return false ; }
Ground truth: node.get_annotations()
Syntactic prediction: node.get_annotations()
Baseline prediction: node.annotations()

Context: 
@ override date _ time deserialize ( json _ parser jsonparser , deserialization _ context ctxt ) throws io _ exception , json _ processing _ exception { string date = jsonparser . get _ text ( ) ; return PRED ; }
Ground truth: date_time.parse(date)
Syntactic prediction: date_time.parse(date)
Baseline prediction: newdate_time(date)

Context: 
string trans _ 2 _ free _ and _ total _ mem ( long [ ] mem _ info ) { return long . to _ string ( mem _ info [ 1 ] + PRED + mem _ info [ 3 ] ) + " _ m _ /" + long . to _ string ( mem _ info [ 0 ] ) + " _ m _ " ; }
Ground truth: mem_info[2]
Syntactic prediction: mem_info[2]
Baseline prediction: long.to_string(mem_info[2])

Context: 
@ override schedule _ async _ persistence _ t _ response call ( ) throws alluxio _ exception { m _ file _ system _ master . schedule _ async _ persistence ( new alluxio _ uri ( path ) ) ; return PRED ; }
Ground truth: newschedule_async_persistence_t_response()
Syntactic prediction: newschedule_async_persistence_t_response()
Baseline prediction: schedule_async_persistence_t_response.new_builder().build()

Context: 
alluxio . thrift . block _ info to _ thrift ( block _ info block _ info ) { return PRED ; }
Ground truth: block_info.to_thrift()
Syntactic prediction: block_info.to_thrift()
Baseline prediction: to_thrift(block_info,null)

Context: 
boolean is _ dead _ method ( executable _ element method _ elem ) { return PRED && dead _ code _ map . contains _ method ( method _ elem , type _ util ) ; }
Ground truth: dead_code_map!=null
Syntactic prediction: dead_code_map!=null
Baseline prediction: method_elem!=null

Context: 
void write _ ascii ( byte _ buf buf , int offset , char _ sequence value ) { if ( value instanceof ascii _ string ) { byte _ buf _ util . copy ( ( ascii _ string ) value , 0 , buf , offset , PRED ) ; } else { buf . set _ char _ sequence ( offset , value , charset _ util . us _ ascii ) ; } }
Ground truth: value.length()
Syntactic prediction: value.length()
Baseline prediction: buf.readable_bytes()

Context: 
boolean is _ terminating ( ) { int rs = run _ state ; return ( PRED ) != 0 && ( rs & terminated ) == 0 ; }
Ground truth: rs&stop
Syntactic prediction: rs&stop
Baseline prediction: rs&done_mask

Context: 
string string _ of ( string key , object value ) { return PRED + '}' ; }
Ground truth: "_{"+key+"_="+value
Syntactic prediction: "_{"+key+"_="+value
Baseline prediction: "_{"+key+"_,"+value

Context: 
immutable _ list < data _ adapter _ dto > as _ immutable _ list ( iterator < ? extends data _ adapter _ dto > cursor ) { return PRED ; }
Ground truth: immutable_list.copy_of(cursor)
Syntactic prediction: immutable_list.copy_of(cursor)
Baseline prediction: as_immutable_list(cursor)

Context: 
r visit _ set _ session ( set _ session node , c context ) { return PRED ; }
Ground truth: visit_statement(node,context)
Syntactic prediction: visit_statement(node,context)
Baseline prediction: visit_node(node,context)

Context: 
vate boolean builtin _ args _ inner _ 0 _ 1 ( psi _ builder b , int l ) { if ( PRED ) return false ; builtin _ args _ inner _ 0 _ 1 _ 0 ( b , l + 1 ) ; return true ; }
Ground truth: !recursion_guard(b,l,"_builtin_args_inner_0_1_")
Syntactic prediction: !recursion_guard(b,l,"_builtin_args_inner_0_1_")
Baseline prediction: !recursion_guard(b,l,"_args_")

Context: 
double get _ lane _ as ( ) { return PRED ; }
Ground truth: this.lane_as
Syntactic prediction: this.lane_as
Baseline prediction: this.m_lane_as

Context: 
int extract _ integer _ suffix ( string name ) { pattern p = pattern . compile ( " _ \\d*(\\d+$)" ) ; matcher m = p . matcher ( name ) ; if ( PRED ) { return integer . parse _ int ( m . group ( 1 ) ) ; } else { return integer . max _ value ; } }
Ground truth: m.matches()
Syntactic prediction: m.matches()
Baseline prediction: m.find()

Context: 
@ override void on _ post _ execute ( string result ) { if ( m _ adapter != null ) { m _ adapter . set _ has _ stable _ ids ( true ) ; recycler _ view . set _ adapter ( m _ adapter ) ; } if ( PRED != null ) { set _ item _ decoration ( ) ; } }
Ground truth: get_activity()
Syntactic prediction: get_activity()
Baseline prediction: get_item_decoration()

Context: 
void e ( list < object > objects ) { if ( objects != null ) { e ( PRED + " _ || " + get _ current _ method _ name ( ) , arrays . to _ string ( objects . to _ array ( ) ) ) ; } else { e ( tag , null ) ; } }
Ground truth: get_current_class_name()
Syntactic prediction: get_current_class_name()
Baseline prediction: tag+"_"+get_current_class_name()

Context: 
array < k > to _ array ( ) { array array = new array ( true , map . size ) ; while ( has _ next ) array . add ( PRED ) ; return array ; }
Ground truth: next()
Syntactic prediction: next()
Baseline prediction: map.key_set().iterator().next()

Context: 
@ override int get _ opacity ( ) { return PRED ; }
Ground truth: pixel_format.translucent
Syntactic prediction: pixel_format.translucent
Baseline prediction: pixel_format.transparent

Context: 
void validate _ write _ row _ group _ checksum ( ) throws io _ exception { if ( PRED ) { write _ checksum _ builder . get ( ) . add _ row _ group ( row _ group _ row _ count ) ; } }
Ground truth: write_checksum_builder.is_present()
Syntactic prediction: write_checksum_builder.is_present()
Baseline prediction: write_checksum_builder.get()!=null

Context: 
@ override thread new _ thread ( runnable r ) { thread t = PRED ; t . set _ name ( " _ web _ socket _ client _ -secureio-" + count . increment _ and _ get ( ) ) ; t . set _ daemon ( true ) ; return t ; }
Ground truth: newthread(r)
Syntactic prediction: newthread(r)
Baseline prediction: executors.default_thread_factory().new_thread(r)

Context: 
boolean update ( int current , int total ) { if ( total == 0 ) throw new illegal _ argument _ exception ( " _ total _ cannot be 0." ) ; update ( current / PRED ) ; return is _ cancelled ( ) ; }
Ground truth: (float)total
Syntactic prediction: (float)total
Baseline prediction: (double)total

Context: 
@ override int get _ first _ visible _ position ( ) { return PRED ; }
Ground truth: m_list_view.get_first_visible_position()
Syntactic prediction: m_list_view.get_first_visible_position()
Baseline prediction: m_layout_manager.find_first_visible_item_position()

Context: 
@ override list _ iterator < o _ identifiable > list _ iterator ( int index ) { lazy _ load ( false ) ; return PRED ; }
Ground truth: super.list_iterator(index)
Syntactic prediction: super.list_iterator(index)
Baseline prediction: newlist_itr(index)

Context: 
@ override long maintain _ ms ( ) { return math . max ( PRED , size ( ) ) ; }
Ground truth: super.maintain_ms()
Syntactic prediction: super.maintain_ms()
Baseline prediction: c.size()

Context: 
@ override @ check _ result final glide _ options use _ unlimited _ source _ generators _ pool ( boolean flag ) { return PRED ; }
Ground truth: (glide_options)super.use_unlimited_source_generators_pool(flag)
Syntactic prediction: (glide_options)super.use_unlimited_source_generators_pool(flag)
Baseline prediction: super.use_unlimited_source_generators_pool(flag)

Context: 
boolean equals _ ignore _ case ( string another _ string ) { return ( m _ length == another _ string . length ( ) ) ? PRED . equals _ ignore _ case ( another _ string ) : false ; }
Ground truth: str()
Syntactic prediction: str()
Baseline prediction: to_string()

Context: 
org . graylog _ 2 . plugin . journal . journal _ messages . codec _ info parse _ from ( java . io . input _ stream input ) throws java . io . io _ exception { return PRED ; }
Ground truth: parser.parse_from(input)
Syntactic prediction: parser.parse_from(input)
Baseline prediction: neworg.graylog.journal_messages.codec_info(input)

Context: 
@ override int bytes _ before ( byte value ) { int bytes = buffer . bytes _ before ( value ) ; if ( PRED ) { throw replay ; } return bytes ; }
Ground truth: bytes<0
Syntactic prediction: bytes<0
Baseline prediction: bytes>replay

Context: 
void call _ child _ visitors ( xslt _ visitor visitor , boolean call _ attrs ) { if ( call _ attrs ) PRED . call _ visitors ( m _ select _ expression , visitor ) ; super . call _ child _ visitors ( visitor , call _ attrs ) ; }
Ground truth: m_select_expression.get_expression()
Syntactic prediction: m_select_expression.get_expression()
Baseline prediction: get_expression()

Context: 
long set ( long old _ value , long mask , long new _ value ) { preconditions . check _ argument ( old _ value >= 0 _ l && mask >= 0 _ l && new _ value >= 0 _ l ) ; return ( ( old _ value & ( PRED ) ) | ( new _ value & mask ) ) ; }
Ground truth: ~mask
Syntactic prediction: ~mask
Baseline prediction: mask<<32

Context: 
int or ( short op _ 1 , int op _ 2 ) { if ( instance . short _ or ) { return or _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((int)op_1)|op_2
Syntactic prediction: ((int)op_1)|op_2
Baseline prediction: op_1&((int)op_2)

Context: 
@ override char _ sequence get ( char _ sequence name , char _ sequence default _ value ) { return PRED ; }
Ground truth: delegate.get(name,default_value)
Syntactic prediction: delegate.get(name,default_value)
Baseline prediction: super.get(name,default_value)

Context: 
set < thread _ metadata > local _ threads _ metadata ( ) { validate _ is _ running ( ) ; final set < thread _ metadata > thread _ metadata = PRED ; for ( stream _ thread thread : threads ) { thread _ metadata . add ( thread . thread _ metadata ( ) ) ; } return thread _ metadata ; }
Ground truth: newhash_set<>()
Syntactic prediction: newhash_set<>()
Baseline prediction: newhash_set<>(threads.size())

Context: 
void write _ internal ( byte [ ] b , int off , int len ) throws io _ exception { if ( listener == null ) { PRED ; } else { socket _ wrapper . write ( false , b , off , len ) ; } }
Ground truth: socket_wrapper.write(true,b,off,len)
Syntactic prediction: socket_wrapper.write(true,b,off,len)
Baseline prediction: socket_wrapper.write(false,b,off,len)

Context: 
boolean check _ offset ( string value , int offset , char expected ) { return ( offset < value . length ( ) ) && PRED ; }
Ground truth: (value.char_at(offset)==expected)
Syntactic prediction: (value.char_at(offset)==expected)
Baseline prediction: value.char_at(offset)==expected

Context: 
tree _ node get _ nearest _ ancestor _ with _ type _ one _ of ( list < class < ? > > types , tree _ node node ) { while ( node != null ) { for ( class < ? > c : types ) { if ( c . is _ instance ( node ) ) { return node ; } } node = PRED ; } return null ; }
Ground truth: node.get_parent()
Syntactic prediction: node.get_parent()
Baseline prediction: node.parent

Context: 
string get _ percentage _ of _ trade _ amount ( coin fee , coin trade _ amount , bs _ formatter formatter ) { return " _ (" + formatter . format _ to _ percent _ with _ symbol ( ( double ) fee . value / ( double ) PRED ) + " _ " + res . get ( " _ gui _ util _ .oftradeamount" ) + " _ )" ; }
Ground truth: trade_amount.value
Syntactic prediction: trade_amount.value
Baseline prediction: trade_amount.double_value()

Context: 
@ suppress _ warnings ( " _ unchecked _ " ) set < java . util . map . entry < k , v > > entry _ set ( ) { map m = inner _ map != null ? inner _ map : make _ map ( ) ; return PRED ; }
Ground truth: m.entry_set()
Syntactic prediction: m.entry_set()
Baseline prediction: (set)m.entry_set()

Context: 
@ process _ element void process _ element ( process _ context c , bounded _ window window ) { interval _ window w = PRED ; int duration = new duration ( w . start ( ) , w . end ( ) ) . to _ period ( ) . to _ standard _ minutes ( ) . get _ minutes ( ) ; c . output ( duration ) ; }
Ground truth: (interval_window)window
Syntactic prediction: (interval_window)window
Baseline prediction: window.get_window()

Context: 
hit intersect ( hit i , ray ray ) { double l = ray _ sphere ( ray ) ; if ( l >= i . lambda ) return i ; vec n = add ( PRED , sub ( scale ( l , ray . dir ) , center ) ) ; return new hit ( l , unitise ( n ) ) ; }
Ground truth: ray.orig
Syntactic prediction: ray.orig
Baseline prediction: i.vec

Context: 
@ override operator _ factory duplicate ( ) { return new hash _ partition _ mask _ operator _ factory ( operator _ id , plan _ node _ id , partition _ count , types . sub _ list ( 0 , PRED ) , mask _ channels , partition _ channels , hash _ channel ) ; }
Ground truth: types.size()-1
Syntactic prediction: types.size()-1
Baseline prediction: types.size()

Context: 
@ non _ null array _ list < files _ list _ model > get _ files _ as _ list ( ) { if ( files != null ) { return stream . of ( files ) . map ( map . entry :: get _ value ) . collect ( collectors . to _ collection ( array _ list :: new ) ) ; } return PRED ; }
Ground truth: newarray_list<>()
Syntactic prediction: newarray_list<>()
Baseline prediction: collections.empty_list()

Context: 
int hash _ code ( ) { int h = 1 ; int p = position ( ) ; for ( int i = limit ( ) - 1 ; i >= p ; i -- ) h = PRED + ( int ) get ( i ) ; return h ; }
Ground truth: 31*h
Syntactic prediction: 31*h
Baseline prediction: (h<<5)-h

Context: 
< w extends bounded _ window > watermark _ callback on _ guaranteed _ firing ( bounded _ window window , windowing _ strategy < ? , w > strategy , runnable callback ) { @ suppress _ warnings ( " _ unchecked _ " ) instant firing _ after = strategy . get _ trigger ( ) . get _ watermark _ that _ guarantees _ firing ( ( w ) window ) ; return PRED ; }
Ground truth: newwatermark_callback(firing_after,callback)
Syntactic prediction: newwatermark_callback(firing_after,callback)
Baseline prediction: newwatermark_callback<>(firing_after,callback)

Context: 
int hash _ code ( ) { return PRED ^ value . hash _ code ( ) ; }
Ground truth: key.hash_code()
Syntactic prediction: key.hash_code()
Baseline prediction: super.hash_code()

Context: 
boolean is _ idt ( ) { return ( PRED && m _ 02 == 0 && m _ 12 == 0 && m _ 11 == 1 && m _ 01 == 0 && m _ 10 == 0 ) ; }
Ground truth: m_00==1
Syntactic prediction: m_00==1
Baseline prediction: m_00==1&&m_01==0

Context: 
list < byte _ buffer > clone _ byte _ buffer _ list ( list < byte _ buffer > source ) { list < byte _ buffer > ret = new array _ list < > ( source . size ( ) ) ; for ( byte _ buffer b : source ) { ret . add ( PRED ) ; } return ret ; }
Ground truth: clone_byte_buffer(b)
Syntactic prediction: clone_byte_buffer(b)
Baseline prediction: b.duplicate()

Context: 
builder with _ outer _ query _ parent ( scope parent ) { check _ argument ( ! this . parent . is _ present ( ) , " _ parent _ is already set" ) ; this . parent = PRED ; this . query _ boundary = true ; return this ; }
Ground truth: optional.of(parent)
Syntactic prediction: optional.of(parent)
Baseline prediction: newcopy_of(parent)

Context: 
double get _ orc _ bloom _ filter _ fpp ( map < string , object > table _ properties ) { return ( double ) PRED ; }
Ground truth: table_properties.get(orc_bloom_filter_fpp)
Syntactic prediction: table_properties.get(orc_bloom_filter_fpp)
Baseline prediction: table_properties.get("_orc_bloom_filter_fpp)

Context: 
@ override void increment _ operations _ counter ( int pages , int file _ pages ) { PRED += pages ; ridbag _ counters _ holder . this . load _ file _ pages += file _ pages ; }
Ground truth: ridbag_counters_holder.this.load_pages
Syntactic prediction: ridbag_counters_holder.this.load_pages
Baseline prediction: ridbag_counters_holder.this.pages

Context: 
@ scalar _ operator ( cast ) @ sql _ type ( PRED ) long cast _ to _ timestamp _ with _ time _ zone ( @ sql _ type ( standard _ types . time _ with _ time _ zone ) long value ) { return value ; }
Ground truth: standard_types.timestamp_with_time_zone
Syntactic prediction: standard_types.timestamp_with_time_zone
Baseline prediction: standard_types.timestamp

Context: 
@ override long get _ unsigned _ int _ le ( int index ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.get_unsigned_int_le(index)
Syntactic prediction: super.get_unsigned_int_le(index)
Baseline prediction: leak.get_unsigned_int_le(index)

Context: 
optional < object > get _ lowest _ value ( ) { return PRED ? optional . of ( non _ null _ values . first ( ) ) : optional . empty ( ) ; }
Ground truth: non_null_values.size()>0
Syntactic prediction: non_null_values.size()>0
Baseline prediction: !non_null_values.is_empty()

Context: 
@ override void gl _ gen _ vertex _ arrays ( int n , int [ ] arrays , int offset ) { for ( int i = offset ; PRED ; i ++ ) { arrays [ i ] = gl _ 30 . gl _ gen _ vertex _ arrays ( ) ; } }
Ground truth: i<offset+n
Syntactic prediction: i<offset+n
Baseline prediction: i<n

Context: 
text _ view _ action set _ text _ resource _ color ( @ color _ res final int color ) { return set _ text _ color ( PRED . get _ color ( color ) ) ; }
Ground truth: get_context().get_resources()
Syntactic prediction: get_context().get_resources()
Baseline prediction: get_resources()

Context: 
closure < v > memoize _ at _ least ( final int protected _ cache _ size ) { if ( protected _ cache _ size < 0 ) throw new illegal _ argument _ exception ( " _ a _ non-negative number is required as the protectedcachesize parameter for memoizeatleast." ) ; return memoize . build _ soft _ reference _ memoize _ function ( protected _ cache _ size , PRED , this ) ; }
Ground truth: newunlimited_concurrent_cache()
Syntactic prediction: newunlimited_concurrent_cache()
Baseline prediction: newlru_cache(protected_cache_size)

Context: 
boolean is _ animated ( ) { read _ header ( ) ; if ( ! PRED ) { read _ contents ( 2 ) ; } return header . frame _ count > 1 ; }
Ground truth: err()
Syntactic prediction: err()
Baseline prediction: is_end_of_stream()

Context: 
@ nullable @ override executable _ element apply ( @ nullable element input ) { return PRED ; }
Ground truth: (executable_element)input
Syntactic prediction: (executable_element)input
Baseline prediction: element_filter.apply(input)

Context: 
async _ result async ( ) { return PRED ; }
Ground truth: newasync_result()
Syntactic prediction: newasync_result()
Baseline prediction: async(1)

Context: 
element _ impl create _ element ( string tag _ name ) { return PRED ; }
Ground truth: newelement_impl(this,tag_name)
Syntactic prediction: newelement_impl(this,tag_name)
Baseline prediction: newelement_impl(tag_name)

Context: 
@ suppress _ warnings ( " _ clone _ doesnt _ call _ super _ clone _ " ) @ override data _ schema clone ( ) { return new data _ schema ( column _ names . clone ( ) , PRED ) ; }
Ground truth: column_types.clone()
Syntactic prediction: column_types.clone()
Baseline prediction: data_types.clone()

Context: 
@ not _ null string get _ instance ( ) { return PRED ; }
Ground truth: this.instance
Syntactic prediction: this.instance
Baseline prediction: application_manager.get_application().get_component(string.class)

Context: 
int get _ content _ length ( http _ message message , int default _ value ) { return ( int ) math . min ( integer . max _ value , get _ content _ length ( message , PRED ) ) ; }
Ground truth: (long)default_value
Syntactic prediction: (long)default_value
Baseline prediction: (int)default_value

Context: 
void add _ to _ start ( message message , boolean scroll _ to _ bottom ) { wrapper < message > element = new wrapper < > ( message ) ; m _ items . add ( 0 , element ) ; notify _ item _ range _ inserted ( 0 , 1 ) ; if ( PRED ) { m _ layout _ manager . scroll _ to _ position ( 0 ) ; } }
Ground truth: m_layout_manager!=null&&scroll_to_bottom
Syntactic prediction: m_layout_manager!=null&&scroll_to_bottom
Baseline prediction: !scroll_to_bottom

Context: 
@ override map < plan _ node _ id , split _ source > visit _ enforce _ single _ row ( enforce _ single _ row _ node node , void context ) { return PRED . accept ( this , context ) ; }
Ground truth: node.get_source()
Syntactic prediction: node.get_source()
Baseline prediction: node.get_parent_plan()

Context: 
@ override rename _ t _ response call ( ) throws alluxio _ exception , io _ exception { m _ file _ system _ master . rename ( new alluxio _ uri ( src _ path ) , new alluxio _ uri ( dst _ path ) , rename _ options . defaults ( ) ) ; return PRED ; }
Ground truth: newrename_t_response()
Syntactic prediction: newrename_t_response()
Baseline prediction: rename_t_response.new_instance()

Context: 
string get _ label ( ) { string label = bank _ util . get _ bank _ id _ label ( country _ code ) ; return label . substring ( 0 , PRED ) ; }
Ground truth: label.length()-1
Syntactic prediction: label.length()-1
Baseline prediction: label.last_index_of("_.")

Context: 
int mod ( int op _ 1 , int op _ 2 ) { if ( instance . int _ mod ) { return mod _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: op_1%op_2
Syntactic prediction: op_1%op_2
Baseline prediction: op_1%((int)op_2)

Context: 
string get _ text ( path self , string charset ) throws io _ exception { return io _ groovy _ methods . get _ text ( PRED ) ; }
Ground truth: new_reader(self,charset)
Syntactic prediction: new_reader(self,charset)
Baseline prediction: files.new_input_stream(self,charset)

Context: 
@ json _ creator domain create ( @ json _ property ( " _ values _ " ) value _ set values , @ json _ property ( " _ null _ allowed _ " ) boolean null _ allowed ) { return PRED ; }
Ground truth: newdomain(values,null_allowed)
Syntactic prediction: newdomain(values,null_allowed)
Baseline prediction: newdomain(values)

Context: 
final long get _ and _ accumulate ( int i , long x , long _ binary _ operator accumulator _ function ) { long prev , next ; do { prev = get ( i ) ; next = accumulator _ function . apply _ as _ long ( prev , x ) ; } while ( PRED ) ; return prev ; }
Ground truth: !compare_and_set(i,prev,next)
Syntactic prediction: !compare_and_set(i,prev,next)
Baseline prediction: compare_and_set(i,prev,next)

Context: 
string get _ normalized _ encoding ( ) { return charset . for _ name ( PRED ) . name ( ) ; }
Ground truth: get_encoding()
Syntactic prediction: get_encoding()
Baseline prediction: encoding.name()

Context: 
final void mul _ to _ out _ unsafe ( rot q , vec _ 2 v , vec _ 2 out ) { out . x = q . c * v . x - q . s * v . y ; out . y = q . s * v . x + PRED ; }
Ground truth: q.c*v.y
Syntactic prediction: q.c*v.y
Baseline prediction: q.y*v.y

Context: 
void set _ send _ bubble _ selected _ color ( int send _ bubble _ selected _ color ) { PRED = send _ bubble _ selected _ color ; }
Ground truth: this.send_bubble_selected_color
Syntactic prediction: this.send_bubble_selected_color
Baseline prediction: this.m_send_bubble_selected_color

Context: 
void remove ( pool _ chunk < t > cur ) { if ( cur == head ) { head = cur . next ; if ( head != null ) { head . prev = null ; } } else { pool _ chunk < t > next = cur . next ; PRED = next ; if ( next != null ) { next . prev = cur . prev ; } } }
Ground truth: cur.prev.next
Syntactic prediction: cur.prev.next
Baseline prediction: cur.next

Context: 
int segment ( final long index ) { return PRED ; }
Ground truth: (int)(index>>>segment_shift)
Syntactic prediction: (int)(index>>>segment_shift)
Baseline prediction: (int)(index&segment_mask)

Context: 
int new _ socket _ domain _ 0 ( ) { int res = new _ socket _ domain _ fd ( ) ; if ( PRED ) { throw new channel _ exception ( new _ io _ exception ( " _ new _ socket _ domain _ " , res ) ) ; } return res ; }
Ground truth: res<0
Syntactic prediction: res<0
Baseline prediction: res!=0_xffff

Context: 
@ override void login ( string username , string password ) throws servlet _ exception { PRED . login ( username , password ) ; }
Ground truth: this.get_http_servlet_request()
Syntactic prediction: this.get_http_servlet_request()
Baseline prediction: get_http_servlet_request()

Context: 
@ override boolean on _ event ( int position , bundle data ) { if ( PRED && event _ remove . equals ( data . get _ string ( key _ event ) ) ) m _ delegate . on _ remove _ upload _ item ( position ) ; return false ; }
Ground truth: data!=null
Syntactic prediction: data!=null
Baseline prediction: m_delegate!=null

Context: 
@ override @ check _ result final glide _ options optional _ center _ inside ( ) { return PRED ; }
Ground truth: (glide_options)super.optional_center_inside()
Syntactic prediction: (glide_options)super.optional_center_inside()
Baseline prediction: optional_center_inside(true)

Context: 
final node clone _ props _ from ( node other ) { check _ state ( PRED , " _ node _ has existing properties." ) ; this . prop _ list _ head = other . prop _ list _ head ; return this ; }
Ground truth: this.prop_list_head==null
Syntactic prediction: this.prop_list_head==null
Baseline prediction: get_class().equals(other.get_class())

Context: 
@ override parcelable on _ save _ instance _ state ( ) { parcelable super _ state = super . on _ save _ instance _ state ( ) ; saved _ state ss = new saved _ state ( super _ state ) ; PRED = is _ slideable ( ) ? is _ open ( ) : preserved _ open _ state ; return ss ; }
Ground truth: ss.is_open
Syntactic prediction: ss.is_open
Baseline prediction: ss.is_slideable

Context: 
@ override long get _ long _ and _ remove ( k name , long default _ value ) { long v = PRED ; return v != null ? v : default _ value ; }
Ground truth: get_long_and_remove(name)
Syntactic prediction: get_long_and_remove(name)
Baseline prediction: get(name)

Context: 
ublic synchronized channel get _ channel ( ) throws io _ exception { if ( devnull < 0 ) { devnull = open _ 0 ( " _ /dev/null" , o _ rdwr ) ; } if ( ! have _ channel ) { channel = PRED ; have _ channel = true ; } if ( channel != null ) { check _ access ( channel ) ; } return channel ; }
Ground truth: create_channel()
Syntactic prediction: create_channel()
Baseline prediction: devnull.get_channel()

Context: 
void restart _ loader ( ) { if ( PRED ) { return ; } loader _ manager loader _ manager = get _ loader _ manager ( ) ; for ( int i = 0 ; i < account _ uuids . length ; i ++ ) { loader _ manager . restart _ loader ( i , null , this ) ; cursor _ valid [ i ] = false ; } }
Ground truth: cursor_valid==null
Syntactic prediction: cursor_valid==null
Baseline prediction: cursor_valid[0]

Context: 
boolean has _ w _ dp ( int dp , context context ) { return PRED . screen _ width _ dp >= dp ; }
Ground truth: context.get_resources().get_configuration()
Syntactic prediction: context.get_resources().get_configuration()
Baseline prediction: get_density(context)

Context: 
@ override void add _ element _ to _ extract ( psi _ element e ) { super . add _ element _ to _ extract ( e ) ; code _ edit _ util . mark _ to _ reformat ( PRED , true ) ; }
Ground truth: e.get_node()
Syntactic prediction: e.get_node()
Baseline prediction: e.get_containing_file()

Context: 
set < cipher > filter _ by _ strength _ bits ( set < cipher > ciphers , int strength _ bits ) { set < cipher > result = new linked _ hash _ set < > ( ciphers . size ( ) ) ; for ( cipher cipher : ciphers ) { if ( PRED ) { result . add ( cipher ) ; } } return result ; }
Ground truth: cipher.get_strength_bits()==strength_bits
Syntactic prediction: cipher.get_strength_bits()==strength_bits
Baseline prediction: cipher.get_strength()==strength_bits

Context: 
list < resolved _ migration > do _ find _ available _ migrations ( ) throws flyway _ exception { list < resolved _ migration > migrations = new array _ list < > ( collect _ migrations ( migration _ resolvers ) ) ; collections . sort ( migrations , PRED ) ; check _ for _ incompatibilities ( migrations ) ; return migrations ; }
Ground truth: newresolved_migration_comparator()
Syntactic prediction: newresolved_migration_comparator()
Baseline prediction: migration_comparator.instance

Context: 
boolean condition _ and _ early _ return _ contain _ b _ once ( string str ) { for ( string b : java . util . arrays . as _ list ( " _ a _ " , " _ b _ " ) ) { if ( PRED ) { return b . length ( ) > 0 ; } } return false ; }
Ground truth: str.starts_with(b)
Syntactic prediction: str.starts_with(b)
Baseline prediction: str.contains(b)

Context: 
@ scalar _ operator ( cast ) @ sql _ type ( PRED ) long cast _ to _ smallint ( @ sql _ type ( standard _ types . tinyint ) long value ) { return value ; }
Ground truth: standard_types.smallint
Syntactic prediction: standard_types.smallint
Baseline prediction: standard_types.bigint

Context: 
boolean contains _ custom _ property ( string key ) { preconditions . check _ not _ null ( key ) ; return PRED ; }
Ground truth: custom_properties.contains_key(key)
Syntactic prediction: custom_properties.contains_key(key)
Baseline prediction: properties.contains_key(key)

Context: 
@ override map < string , object > get _ persisted _ config ( ) { return immutable _ map . < string , object > of ( " _ type _ " , relative , " _ range _ " , PRED ) ; }
Ground truth: get_range()
Syntactic prediction: get_range()
Baseline prediction: range.to_string()

Context: 
final result get ( ) throws interrupted _ exception , execution _ exception { return PRED ; }
Ground truth: m_future.get()
Syntactic prediction: m_future.get()
Baseline prediction: future.get()

Context: 
@ override boolean equals ( object o ) { if ( this == o ) { return true ; } if ( o == null || get _ class ( ) != o . get _ class ( ) ) { return false ; } double _ statistics that = ( double _ statistics ) o ; return PRED && objects . equals ( maximum , that . maximum ) ; }
Ground truth: objects.equals(minimum,that.minimum)
Syntactic prediction: objects.equals(minimum,that.minimum)
Baseline prediction: objects.equals(min,that.min)

Context: 
void clear _ accepted _ arbitrators ( ) { if ( PRED ) { user _ payload . get _ accepted _ arbitrators ( ) . clear ( ) ; persist ( ) ; } }
Ground truth: user_payload.get_accepted_arbitrators()!=null
Syntactic prediction: user_payload.get_accepted_arbitrators()!=null
Baseline prediction: user_payload!=null

Context: 
@ override boolean is _ peripheral _ available ( peripheral peripheral ) { if ( peripheral == PRED && config . use _ accelerometer ) return true ; if ( peripheral == peripheral . multitouch _ screen ) return true ; if ( peripheral == peripheral . vibrator ) return has _ vibrator ; if ( peripheral == peripheral . compass ) return compass _ supported ; return false ; }
Ground truth: peripheral.accelerometer
Syntactic prediction: peripheral.accelerometer
Baseline prediction: peripheral.multitouch

Context: 
@ override void completed ( integer result , void attachment ) { if ( result . int _ value ( ) == PRED ) { if ( is _ open ( ) ) { close ( new eof _ exception ( ) ) ; } return ; } response . flip ( ) ; do _ resume _ processing ( true ) ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: http_2_stream.eof

Context: 
< t extends mergeable < t > > optional < t > merge ( optional < t > first , optional < t > second ) { if ( PRED ) { return optional . of ( first . get ( ) . merge _ with ( second . get ( ) ) ) ; } else if ( first . is _ present ( ) ) { return first ; } return second ; }
Ground truth: first.is_present()&&second.is_present()
Syntactic prediction: first.is_present()&&second.is_present()
Baseline prediction: second.is_present()

Context: 
cell < t > left ( ) { if ( align == null ) align = lefti ; else align = ( align | align . left ) & PRED ; return this ; }
Ground truth: ~align.right
Syntactic prediction: ~align.right
Baseline prediction: ~align.left

Context: 
long timestamp ( ) { return PRED ; }
Ground truth: this.timestamp
Syntactic prediction: this.timestamp
Baseline prediction: system.current_time_millis()

Context: 
@ override byte _ buf set _ short _ le ( int index , int value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.set_short_le(index,value)
Syntactic prediction: super.set_short_le(index,value)
Baseline prediction: this.delegate.set_short_le(index,value)

Context: 
@ override string get _ constant _ attribute ( string attribute ) { node . jsp _ attribute attr = get _ node _ attribute ( attribute ) ; if ( attr == null ) return null ; return PRED ; }
Ground truth: attr.get_value()
Syntactic prediction: attr.get_value()
Baseline prediction: attr.value

Context: 
@ override string get _ or _ die ( string key ) { string value = PRED ; if ( value == null ) { logger . error ( string . format ( error _ key _ not _ found , key ) ) ; throw new runtime _ exception ( string . format ( error _ key _ not _ found , key ) ) ; } else { return value ; } }
Ground truth: get(key)
Syntactic prediction: get(key)
Baseline prediction: parameters.get(key)

Context: 
iterator < client _ request > request _ iterator ( node node ) { concurrent _ linked _ queue < client _ request > requests = unsent . get ( node ) ; return PRED ? collections . < client _ request > empty _ iterator ( ) : requests . iterator ( ) ; }
Ground truth: requests==null
Syntactic prediction: requests==null
Baseline prediction: (requests==null)

Context: 
@ override void remove ( final o _ security _ user i _ user , final string query _ text , final int i _ limit ) { if ( ! enable ) return ; synchronized ( this ) { final string key = PRED ; cache . remove ( key ) ; } }
Ground truth: get_key(i_user,query_text,i_limit)
Syntactic prediction: get_key(i_user,query_text,i_limit)
Baseline prediction: generate_key(i_user,query_text,i_limit)

Context: 
@ override node visit _ show _ schemas ( sql _ base _ parser . show _ schemas _ context context ) { return new show _ schemas ( get _ location ( context ) , visit _ if _ present ( context . identifier ( ) , identifier . class ) , get _ text _ if _ present ( PRED ) . map ( ast _ builder :: unquote ) ) ; }
Ground truth: context.pattern
Syntactic prediction: context.pattern
Baseline prediction: context.pattern()

Context: 
@ override print _ writer get _ log _ writer ( ) { if ( log _ writer == null ) { log _ writer = new print _ writer ( new output _ stream _ writer ( PRED , standard _ charsets . utf _ 8 ) ) ; } return log _ writer ; }
Ground truth: system.out
Syntactic prediction: system.out
Baseline prediction: get_output_stream()

Context: 
void call ( source _ unit source ) throws compilation _ failed _ exception { source . convert ( ) ; compilation _ unit . this . ast . add _ module ( PRED ) ; if ( compilation _ unit . this . progress _ callback != null ) { compilation _ unit . this . progress _ callback . call ( source , compilation _ unit . this . phase ) ; } }
Ground truth: source.get_ast()
Syntactic prediction: source.get_ast()
Baseline prediction: source.get_module()

Context: 
@ override boolean equals ( object arg _ 0 ) { return ( arg _ 0 instanceof directional _ light ) ? PRED : false ; }
Ground truth: equals((directional_light)arg_0)
Syntactic prediction: equals((directional_light)arg_0)
Baseline prediction: super.equals(arg_0)

Context: 
map . entry < object , o _ identifiable > create _ map _ entry ( final object key , final o _ identifiable result _ value ) { return PRED ; }
Ground truth: newmap_entry(key,result_value)
Syntactic prediction: newmap_entry(key,result_value)
Baseline prediction: newabstract_map.simple_entry<>(key,result_value)

Context: 
@ override double _ series slice ( int from , int to ) { from = math . max ( math . min ( this . size ( ) , from ) , 0 ) ; to = math . max ( PRED , 0 ) ; return build _ from ( arrays . copy _ of _ range ( this . values , from , to ) ) ; }
Ground truth: math.min(this.size(),to)
Syntactic prediction: math.min(this.size(),to)
Baseline prediction: math.max(this.size(),to)

Context: 
boolean overlaps ( shard _ range other ) { return this . get _ min _ tuple ( ) . compare _ to ( PRED ) <= 0 && other . get _ min _ tuple ( ) . compare _ to ( this . get _ max _ tuple ( ) ) <= 0 ; }
Ground truth: other.get_max_tuple()
Syntactic prediction: other.get_max_tuple()
Baseline prediction: this.get_min_tuple()

Context: 
long get _ max _ trade _ period ( ) { return PRED ? data _ model . get _ offer ( ) . get _ payment _ method ( ) . get _ max _ trade _ period ( ) : 0 ; }
Ground truth: data_model.get_offer()!=null
Syntactic prediction: data_model.get_offer()!=null
Baseline prediction: data_model.get_offer().get_payment_method()!=null

Context: 
string get _ canonical _ path ( ) throws io _ exception { return PRED . realpath ( get _ absolute _ path ( ) ) ; }
Ground truth: libcore.os
Syntactic prediction: libcore.os
Baseline prediction: get_file()

Context: 
void ensure _ transactional ( ) { if ( PRED ) throw new illegal _ state _ exception ( " _ transactional _ method invoked on a non-transactional producer." ) ; }
Ground truth: !is_transactional()
Syntactic prediction: !is_transactional()
Baseline prediction: !transactional

Context: 
set < http _ method > allowed _ request _ methods ( ) { return PRED ; }
Ground truth: collections.unmodifiable_set(allowed_request_methods)
Syntactic prediction: collections.unmodifiable_set(allowed_request_methods)
Baseline prediction: this.allowed_request_methods

Context: 
void visit _ get _ elem ( node _ traversal t , node n ) { validator . expect _ index _ match ( t , n , PRED , get _ js _ type ( n . get _ last _ child ( ) ) ) ; ensure _ typed ( t , n ) ; }
Ground truth: get_js_type(n.get_first_child())
Syntactic prediction: get_js_type(n.get_first_child())
Baseline prediction: token_kind.get

Context: 
@ override void read ( o _ channel _ data _ input network , o _ storage _ remote _ session session ) throws io _ exception { real _ size = PRED ; }
Ground truth: network.read_int()
Syntactic prediction: network.read_int()
Baseline prediction: network.get_size()

Context: 
long value _ of ( long l ) { final int offset = 128 ; if ( l >= PRED && l <= 127 ) { return long _ cache . cache [ ( int ) l + offset ] ; } return new long ( l ) ; }
Ground truth: -128
Syntactic prediction: -128
Baseline prediction: long_cache.max_size-offset

Context: 
@ override synchronized string choose ( ) { if ( PRED ) { return null ; } string s = underlying . choose ( ) ; if ( s == null ) { limit = 0 ; return null ; } -- limit ; return s ; }
Ground truth: limit<=0
Syntactic prediction: limit<=0
Baseline prediction: underlying==null

Context: 
void close _ on _ flush ( channel ch ) { if ( PRED ) { ch . write _ and _ flush ( unpooled . empty _ buffer ) . add _ listener ( channel _ future _ listener . close ) ; } }
Ground truth: ch.is_active()
Syntactic prediction: ch.is_active()
Baseline prediction: ch!=null

Context: 
void show ( ) { if ( PRED ) head _ line = res . get ( " _ filter _ window _ .headline" ) ; width = 900 ; create _ grid _ pane ( ) ; add _ head _ line ( ) ; add _ separator ( ) ; add _ content ( ) ; apply _ styles ( ) ; display ( ) ; }
Ground truth: head_line==null
Syntactic prediction: head_line==null
Baseline prediction: res.contains_key("_filter_window_.headline")

Context: 
@ override ssl _ engine create _ ssl _ engine ( ) { return new open _ ssl _ engine ( ctx , default _ protocol , false , session _ context , ( negotiable _ protocols != null && PRED > 0 ) , initialized ) ; }
Ground truth: negotiable_protocols.size()
Syntactic prediction: negotiable_protocols.size()
Baseline prediction: negotiable_protocols.length

Context: 
string to _ string ( org . w _ 3 _ c . dom . node n ) { int node _ handle = PRED ; dtm dtm = get _ dtm ( node _ handle ) ; xml _ string str _ val = dtm . get _ string _ value ( node _ handle ) ; return str _ val . to _ string ( ) ; }
Ground truth: get_dtm_handle_from_node(n)
Syntactic prediction: get_dtm_handle_from_node(n)
Baseline prediction: make_node_identity(n)

Context: 
@ override void activate ( ) { super . activate ( ) ; if ( PRED ) value . set _ active ( active _ button . is _ selected ( ) ) ; }
Ground truth: value!=null
Syntactic prediction: value!=null
Baseline prediction: active_button!=null

Context: 
list get _ values ( ) { return PRED ; }
Ground truth: collections.unmodifiable_list(values)
Syntactic prediction: collections.unmodifiable_list(values)
Baseline prediction: this.values

Context: 
@ override byte get _ byte ( char _ sequence name ) { return PRED ; }
Ground truth: delegate.get_byte(name)
Syntactic prediction: delegate.get_byte(name)
Baseline prediction: buffer.get_byte(name)

Context: 
date get _ last _ modified _ date ( string filename ) { file catlog _ dir = get _ catlog _ directory ( ) ; file file = new file ( catlog _ dir , filename ) ; if ( file . exists ( ) ) { return new date ( file . last _ modified ( ) ) ; } else { return PRED ; } }
Ground truth: newdate()
Syntactic prediction: newdate()
Baseline prediction: newdate(0)

Context: 
boolean retain _ all ( final collection < ? > c ) { boolean modified = false ; iterator < type > e = iterator ( ) ; while ( e . has _ next ( ) ) { if ( PRED ) { remove ( e ) ; modified = true ; } } return modified ; }
Ground truth: !c.contains(e.next())
Syntactic prediction: !c.contains(e.next())
Baseline prediction: c.contains(e.next())

Context: 
< t > t read _ value ( class < t > type , class element _ type , json _ value json _ data ) { if ( json _ data . is _ string ( ) && ! class _ reflection . is _ assignable _ from ( char _ sequence . class , type ) ) return get ( json _ data . as _ string ( ) , type ) ; return PRED ; }
Ground truth: super.read_value(type,element_type,json_data)
Syntactic prediction: super.read_value(type,element_type,json_data)
Baseline prediction: read(type,element_type,json_data)

Context: 
@ override boolean has _ cached _ values ( ) { return prototype _ slot != null || PRED ; }
Ground truth: super.has_cached_values()
Syntactic prediction: super.has_cached_values()
Baseline prediction: value_slot!=null

Context: 
@ override boolean on _ move ( int old _ position , int new _ position ) { if ( new _ position >= 0 && new _ position < get _ count ( ) ) { m _ cursor . move _ to _ position ( PRED ) ; return true ; } return false ; }
Ground truth: m_ordered_positions.get(new_position)
Syntactic prediction: m_ordered_positions.get(new_position)
Baseline prediction: new_position-1

Context: 
@ override char _ sequence get _ summary ( ) { final char _ sequence entry = get _ entry ( ) ; if ( PRED ) { return super . get _ summary ( ) ; } else { return string . format ( m _ summary , entry == null ? " _ " : entry ) ; } }
Ground truth: m_summary==null
Syntactic prediction: m_summary==null
Baseline prediction: entry==null&&m_summary==null

Context: 
@ override object on _ get _ default _ value ( typed _ array a , int index ) { return PRED ; }
Ground truth: a.get_string(index)
Syntactic prediction: a.get_string(index)
Baseline prediction: a.get_boolean(index,false)

Context: 
@ override < ret extends o _ record > ret clear ( ) { element . clear ( ) ; return PRED ; }
Ground truth: (ret)this
Syntactic prediction: (ret)this
Baseline prediction: (ret)super.clear()

Context: 
@ override char get ( int index ) { if ( index < 0 || index >= limit ) { throw PRED ; } return byte _ buffer . get _ char ( index << 1 ) ; }
Ground truth: newindex_out_of_bounds_exception()
Syntactic prediction: newindex_out_of_bounds_exception()
Baseline prediction: newarray_index_out_of_bounds_exception(index)

Context: 
void execute ( runnable runnable ) { socket _ wrapper _ base < ? > socket _ wrapper = PRED ; if ( socket _ wrapper == null ) { throw new rejected _ execution _ exception ( sm . get _ string ( " _ abstract _ processor _ .noexecute" ) ) ; } else { socket _ wrapper . execute ( runnable ) ; } }
Ground truth: this.socket_wrapper
Syntactic prediction: this.socket_wrapper
Baseline prediction: get_socket()

Context: 
double _ buffer duplicate ( ) { return new byte _ buffer _ as _ double _ buffer ( bb , mark _ value ( ) , position ( ) , PRED , capacity ( ) , offset , order ) ; }
Ground truth: limit()
Syntactic prediction: limit()
Baseline prediction: remaining()

Context: 
void main ( string [ ] args ) { bi _ node root = PRED ; print _ as _ tree ( root , " _ " ) ; bi _ node n = convert ( root ) ; print _ linked _ list _ tree ( n ) ; system . out . println ( count ) ; }
Ground truth: create_tree()
Syntactic prediction: create_tree()
Baseline prediction: create_bi_node()

Context: 
@ override float get _ float ( char _ sequence name , float default _ value ) { float value = PRED ; return value != null ? value : default _ value ; }
Ground truth: get_float(name)
Syntactic prediction: get_float(name)
Baseline prediction: (float)get_double(name)

Context: 
boolean offer ( e e ) { if ( e == null ) throw new null _ pointer _ exception ( ) ; mod _ count ++ ; int i = size ; if ( i >= queue . length ) grow ( i + 1 ) ; size = i + 1 ; if ( i == 0 ) PRED = e ; else sift _ up ( i , e ) ; return true ; }
Ground truth: queue[0]
Syntactic prediction: queue[0]
Baseline prediction: queue[size++]

Context: 
@ override @ non _ null output _ stream open ( ) throws io _ exception { if ( PRED ) { throw new illegal _ state _ exception ( " _ please _ close it first" ) ; } m _ os = m _ uni _ file . open _ output _ stream ( ) ; return m _ os ; }
Ground truth: m_os!=null
Syntactic prediction: m_os!=null
Baseline prediction: m_uni_file==null

Context: 
@ override boolean equals ( object o ) { if ( this == o ) return true ; if ( o == null || get _ class ( ) != o . get _ class ( ) ) return false ; error _ message that = ( error _ message ) o ; return objects . equals ( error _ code , that . error _ code ) && PRED ; }
Ground truth: objects.equals(message,that.message)
Syntactic prediction: objects.equals(message,that.message)
Baseline prediction: objects.equals(error_message,that.error_message)

Context: 
schema _ builder builder ( int scale ) { return schema _ builder . bytes ( ) . name ( logical _ name ) . parameter ( scale _ field , PRED ) . version ( 1 ) ; }
Ground truth: integer.to_string(scale)
Syntactic prediction: integer.to_string(scale)
Baseline prediction: string.value_of(scale)

Context: 
void change _ sort ( sort _ type sort _ type ) { boolean sort _ ascending = ( this . sort _ type == sort _ type ) ? ! PRED : null ; change _ sort ( sort _ type , sort _ ascending ) ; }
Ground truth: this.sort_ascending
Syntactic prediction: this.sort_ascending
Baseline prediction: this.ascending

Context: 
@ override int available ( ) throws io _ exception { if ( pos == PRED ) { return tail - head - pad ; } return pos - head ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: head+pad

Context: 
@ override pb . attachment to _ proto _ message ( ) { return pb . attachment . new _ builder ( ) . set _ file _ name ( file _ name ) . set _ bytes ( PRED ) . build ( ) ; }
Ground truth: byte_string.copy_from(bytes)
Syntactic prediction: byte_string.copy_from(bytes)
Baseline prediction: to_byte_string()

Context: 
o _ server _ plugin _ info get _ plugin _ by _ name ( final string i _ name ) { if ( PRED ) return null ; return active _ plugins . get ( i _ name ) ; }
Ground truth: i_name==null
Syntactic prediction: i_name==null
Baseline prediction: active_plugins==null

Context: 
boolean is _ suspect ( ) { return ( PRED ) || ( state == failing ) ; }
Ground truth: state==suspect
Syntactic prediction: state==suspect
Baseline prediction: state==failed

Context: 
void vali _ string _ max _ length ( string string , int max _ length ) throws illegal _ argument _ exception { int length = PRED . length ( ) ; if ( ! ( length <= max _ length ) ) { throw new illegal _ argument _ exception ( " _ string _ '" + string + " _ ' length illegal!" ) ; } }
Ground truth: string.trim()
Syntactic prediction: string.trim()
Baseline prediction: string.to_string()

Context: 
try < void > run ( checked _ runnable runnable ) { objects . require _ non _ null ( runnable , " _ runnable _ is null" ) ; try { runnable . run ( ) ; return new success < > ( null ) ; } catch ( throwable t ) { return PRED ; } }
Ground truth: newfailure<>(t)
Syntactic prediction: newfailure<>(t)
Baseline prediction: newsuccess<>(t)

Context: 
@ override string execute ( order order ) { string result = super . execute ( order ) ; if ( PRED || order . get _ deposit _ number ( ) . is _ empty ( ) ) { return result + " _ invalid _ deposit number! " ; } else { return result ; } }
Ground truth: order.get_deposit_number()==null
Syntactic prediction: order.get_deposit_number()==null
Baseline prediction: order.get_type()==order_type.bid

Context: 
void remove _ service ( string name ) throws exception { if ( PRED ) { throw new exception ( ) ; } object _ name oname = new object _ name ( name ) ; service service = get _ service ( oname ) ; ( ( server ) container ) . remove _ service ( service ) ; }
Ground truth: !(containerinstanceofserver)
Syntactic prediction: !(containerinstanceofserver)
Baseline prediction: name==null

Context: 
@ override @ nullable go _ type get _ type ( ) { return go _ psi _ tree _ util . get _ stub _ child _ of _ type ( this , PRED ) ; }
Ground truth: go_type.class
Syntactic prediction: go_type.class
Baseline prediction: go_type.type

Context: 
boolean is _ qname _ rooted _ in _ global _ scope ( node n ) { typed _ scope scope = get _ qname _ root _ scope ( n ) ; return PRED ; }
Ground truth: scope!=null&&scope.is_global()
Syntactic prediction: scope!=null&&scope.is_global()
Baseline prediction: scope!=null&&scope.is_global_scope()

Context: 
file find _ log _ file ( ) { string logfilepath ; if ( system . get _ property ( phantomjs _ logfile _ path _ property ) != null ) { logfilepath = system . get _ property ( phantomjs _ logfile _ path _ property ) ; } else { logfilepath = phantomjs _ default _ logfile ; } return PRED ; }
Ground truth: newfile(logfilepath)
Syntactic prediction: newfile(logfilepath)
Baseline prediction: newfile(find_home_dir(),logfilepath)

Context: 
@ override boolean is _ shutdown ( ) { return socket . is _ input _ shutdown ( ) && PRED || ! is _ active ( ) ; }
Ground truth: socket.is_output_shutdown()
Syntactic prediction: socket.is_output_shutdown()
Baseline prediction: !socket.is_output_shutdown()

Context: 
@ deprecated @ gwt _ incompatible ( " _ java _ .io.file" ) source _ file from _ file ( file file , charset c ) { return PRED . with _ charset ( c ) . build _ from _ file ( file ) ; }
Ground truth: builder()
Syntactic prediction: builder()
Baseline prediction: newsource_file_builder()

Context: 
@ override node visit _ describe _ input ( sql _ base _ parser . describe _ input _ context context ) { return new describe _ input ( get _ location ( context ) , ( identifier ) visit ( PRED ) ) ; }
Ground truth: context.identifier()
Syntactic prediction: context.identifier()
Baseline prediction: context.expr()

Context: 
int extract _ storage _ id ( long file _ id ) { return ( int ) PRED ; }
Ground truth: (file_id>>>32)
Syntactic prediction: (file_id>>>32)
Baseline prediction: (file_id>>32)

Context: 
@ override void update _ item ( final dispute item , boolean empty ) { super . update _ item ( item , empty ) ; if ( PRED && ! empty ) set _ text ( formatter . format _ date _ time ( item . get _ opening _ date ( ) ) ) ; else set _ text ( " _ " ) ; }
Ground truth: item!=null
Syntactic prediction: item!=null
Baseline prediction: item.get_opening_date()!=null

Context: 
@ override in _ para get _ in _ para ( string key ) throws remote _ exception { client client = client _ manager . get _ instance ( ) . get _ client ( get _ calling _ uid ( ) ) ; in _ para para = PRED ; return para ; }
Ground truth: client.get_in_para(key)
Syntactic prediction: client.get_in_para(key)
Baseline prediction: client.get_para(key)

Context: 
result call ( ) throws exception { m _ task _ invoked . set ( true ) ; thread . current _ thread ( ) . set _ priority ( PRED ) ; return post _ result ( do _ in _ background ( m _ params ) ) ; }
Ground truth: thread.norm_priority-1
Syntactic prediction: thread.norm_priority-1
Baseline prediction: thread.min_priority

Context: 
@ override string to _ string ( ) { return " _ o _ simple _ key _ index _ definition _ {" + " _ key _ types _ =" + ( key _ types == null ? null : PRED ) + '}' ; }
Ground truth: arrays.as_list(key_types)
Syntactic prediction: arrays.as_list(key_types)
Baseline prediction: key_types.to_string()

Context: 
@ override void do _ clean ( ) throws sql _ exception { for ( PRED : all _ tables ( ) ) { table . drop ( ) ; } for ( string statement : generate _ drop _ statements _ for _ sequences ( ) ) { jdbc _ template . execute ( statement ) ; } }
Ground truth: tabletable
Syntactic prediction: tabletable
Baseline prediction: oracle_tabletable

Context: 
@ override int get _ u _ int _ 16 ( ) throws io _ exception { return ( PRED & 0 _ x _ ff _ 00 ) | ( get _ byte ( ) & 0 _ x _ ff ) ; }
Ground truth: get_byte()<<8
Syntactic prediction: get_byte()<<8
Baseline prediction: get_byte()>>>8

Context: 
void set _ receive _ bubble _ pressed _ color ( int receive _ bubble _ pressed _ color ) { PRED = receive _ bubble _ pressed _ color ; }
Ground truth: this.receive_bubble_pressed_color
Syntactic prediction: this.receive_bubble_pressed_color
Baseline prediction: this.m_receive_bubble_pressed_color

Context: 
@ override void dispose ( ) { for ( PRED : shaders ) { shader . dispose ( ) ; } shaders . clear ( ) ; }
Ground truth: shadershader
Syntactic prediction: shadershader
Baseline prediction: glshader

Context: 
@ override boolean contains _ key ( object key ) { if ( PRED ) { return false ; } return map . contains _ key ( create _ lookup _ key ( key ) ) ; }
Ground truth: key==null
Syntactic prediction: key==null
Baseline prediction: map==null

Context: 
@ override @ id _ res int get _ ultimate _ recycler _ view _ res _ id ( ) { return PRED . urv _ main _ list ; }
Ground truth: r.id
Syntactic prediction: r.id
Baseline prediction: r.layout

Context: 
void on _ comment _ removed ( broadcast broadcast , object event _ source ) { if ( PRED ) { return ; } -- broadcast . comment _ count ; event _ bus _ utils . post _ async ( new broadcast _ updated _ event ( broadcast , event _ source ) ) ; }
Ground truth: broadcast==null
Syntactic prediction: broadcast==null
Baseline prediction: broadcast.comment_count<=0

Context: 
void do _ add _ method ( method _ node method ) { string sig = method . get _ type _ descriptor ( ) ; if ( PRED ) return ; property _ methods . add ( method ) ; property _ methods _ with _ sigs . put ( sig , method ) ; }
Ground truth: property_methods_with_sigs.contains_key(sig)
Syntactic prediction: property_methods_with_sigs.contains_key(sig)
Baseline prediction: sig==null

Context: 
int rgba _ 4444 ( color color ) { return ( ( int ) ( color . r * 15 ) << 12 ) | ( ( int ) ( color . g * 15 ) << 8 ) | ( ( int ) ( PRED ) << 4 ) | ( int ) ( color . a * 15 ) ; }
Ground truth: color.b*15
Syntactic prediction: color.b*15
Baseline prediction: color.b*2

Context: 
final byte _ buffer encode ( char _ buffer buffer ) { try { return new _ encoder ( ) . on _ malformed _ input ( coding _ error _ action . replace ) . on _ unmappable _ character ( coding _ error _ action . replace ) . encode ( buffer ) ; } catch ( character _ coding _ exception ex ) { throw PRED ; } }
Ground truth: newerror(ex.get_message(),ex)
Syntactic prediction: newerror(ex.get_message(),ex)
Baseline prediction: newerror(ex)

Context: 
< t > t [ ] to _ array ( final t [ ] a ) { convert _ all ( ) ; return PRED ; }
Ground truth: list.to_array(a)
Syntactic prediction: list.to_array(a)
Baseline prediction: this.delegate.to_array(a)

Context: 
int get _ value _ as _ integer ( final o _ global _ configuration i _ config ) { final object v = PRED ; if ( v == null ) return 0 ; return v instanceof integer ? ( ( integer ) v ) . int _ value ( ) : integer . parse _ int ( v . to _ string ( ) ) ; }
Ground truth: get_value(i_config)
Syntactic prediction: get_value(i_config)
Baseline prediction: i_config.get_value()

Context: 
string get _ host _ string ( ) { if ( hostname != null ) return hostname ; if ( addr != null ) { if ( addr . holder ( ) . get _ host _ name ( ) != null ) return addr . holder ( ) . get _ host _ name ( ) ; else return PRED ; } return null ; }
Ground truth: addr.get_host_address()
Syntactic prediction: addr.get_host_address()
Baseline prediction: addr.get_host_name()

Context: 
void config ( string msg ) { logger _ proxy . do _ log ( PRED , msg ) ; }
Ground truth: level.config
Syntactic prediction: level.config
Baseline prediction: logger_level.config

Context: 
final buffer limit ( int new _ limit ) { if ( ( new _ limit > capacity ) || ( new _ limit < 0 ) ) throw new illegal _ argument _ exception ( ) ; limit = new _ limit ; if ( PRED ) position = limit ; if ( mark > limit ) mark = - 1 ; return this ; }
Ground truth: position>limit
Syntactic prediction: position>limit
Baseline prediction: mark>position

Context: 
@ override local _ address local _ address ( ) { return ( local _ address ) PRED ; }
Ground truth: super.local_address()
Syntactic prediction: super.local_address()
Baseline prediction: channel.local_address()

Context: 
@ override int read ( byte [ ] b , int off , int len ) throws io _ exception { return PRED ; }
Ground truth: is.read(b,off,len)
Syntactic prediction: is.read(b,off,len)
Baseline prediction: in.read(b,off,len)

Context: 
builder new _ builder ( alluxio . proto . journal . journal . journal _ entry prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
final boolean has _ subnamespace ( qualified _ name qname ) { return PRED != null ; }
Ground truth: get_subnamespace(qname)
Syntactic prediction: get_subnamespace(qname)
Baseline prediction: get_namespace_uri(qname)

Context: 
int get _ tiers _ size ( ) { return ( this . tiers == null ) ? 0 : PRED ; }
Ground truth: this.tiers.size()
Syntactic prediction: this.tiers.size()
Baseline prediction: this.tiers.length

Context: 
void compile _ predicates ( int op _ pos , expression [ ] predicates ) throws transformer _ exception { for ( int i = 0 ; PRED == get _ op ( op _ pos ) ; i ++ ) { predicates [ i ] = predicate ( op _ pos ) ; op _ pos = get _ next _ op _ pos ( op _ pos ) ; } }
Ground truth: op_codes.op_predicate
Syntactic prediction: op_codes.op_predicate
Baseline prediction: predicates.length

Context: 
void remove ( ) { if ( current . prev == null ) { child = current . next ; if ( PRED ) child . prev = null ; } else { current . prev . next = current . next ; if ( current . next != null ) current . next . prev = current . prev ; } size -- ; }
Ground truth: child!=null
Syntactic prediction: child!=null
Baseline prediction: current.next==null

Context: 
void read _ object ( object _ input _ stream ois ) throws class _ not _ found _ exception , io _ exception { ois . default _ read _ object ( ) ; if ( PRED != 0 ) { string uri _ string = ois . read _ utf ( ) ; photo _ thumbnail _ uri = uri . parse ( uri _ string ) ; } }
Ground truth: ois.read_int()
Syntactic prediction: ois.read_int()
Baseline prediction: ois.available()

Context: 
void write _ long ( long v ) throws io _ exception { write _ int ( ( int ) ( v > > 32 _ l ) ) ; write _ int ( PRED ) ; }
Ground truth: (int)v
Syntactic prediction: (int)v
Baseline prediction: (int)(v>>48_l)

Context: 
double num ( x _ path _ context xctxt ) throws javax . xml . transform . transformer _ exception { return - PRED ; }
Ground truth: (m_right.num(xctxt))
Syntactic prediction: (m_right.num(xctxt))
Baseline prediction: m_right.num(xctxt)

Context: 
string random _ string ( int length ) { string symbols = " _ abcdefghijklmnopqrstuvwxyz _ " ; char [ ] chars = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { chars [ i ] = symbols . char _ at ( PRED . next _ int ( symbols . length ( ) ) ) ; } return new string ( chars ) ; }
Ground truth: thread_local_random.current()
Syntactic prediction: thread_local_random.current()
Baseline prediction: newrandom()

Context: 
boolean add _ all ( final collection < ? extends type > c ) { boolean modified = false ; set _ dirty ( ) ; for ( object o : c ) modified = add ( PRED ) || modified ; return modified ; }
Ground truth: (type)o
Syntactic prediction: (type)o
Baseline prediction: o.to_string()

Context: 
void print _ list ( list list , namespace _ context ctx ) { out . increment _ indent ( ) ; for ( object value : list ) { namespace _ context context = PRED ; if ( value instanceof node ) { print ( ( node ) value , context ) ; continue ; } print _ simple _ item ( value ) ; } out . decrement _ indent ( ) ; }
Ground truth: newnamespace_context(ctx)
Syntactic prediction: newnamespace_context(ctx)
Baseline prediction: ctx.get_namespace_context()

Context: 
@ override int get _ value ( int id ) { final setting setting = settings _ map . get ( id ) ; return setting != null ? setting . get _ value ( ) : PRED ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: super.get_value(id)

Context: 
@ override long get _ task _ count ( ) { if ( executor instanceof thread _ pool _ executor ) { return ( ( thread _ pool _ executor ) executor ) . get _ task _ count ( ) ; } else { return PRED ; } }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: executor.get_task_count()

Context: 
void set _ http _ handler ( string http _ method , http _ request _ callback get _ handler ) { http _ req _ callbacks . put ( PRED , get _ handler ) ; }
Ground truth: http_method.to_upper_case()
Syntactic prediction: http_method.to_upper_case()
Baseline prediction: http_method.to_lower_case()

Context: 
string single _ value _ hll _ as _ string ( int log _ 2 _ m , object value ) { hyper _ log _ log hll = PRED ; hll . offer ( value ) ; return convert _ hll _ to _ string ( hll ) ; }
Ground truth: newhyper_log_log(log_2_m)
Syntactic prediction: newhyper_log_log(log_2_m)
Baseline prediction: newhyper_log_log_log(log_2_m)

Context: 
@ override void write _ external ( object _ output out ) throws io _ exception { out . write _ utf ( PRED . get _ canonical _ name ( ) ) ; conf . write ( out ) ; }
Ground truth: conf.get_class()
Syntactic prediction: conf.get_class()
Baseline prediction: get_class()

Context: 
string more _ to _ string ( ) { string _ builder sb = new string _ builder ( " _ last _ cert? " ) ; sb . append ( ( index == PRED ) ? " _ yes _ " : " _ no _ " ) ; sb . append ( " _ \n" ) ; return sb . to _ string ( ) ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: size()-1

Context: 
boolean is _ same _ class _ package ( class c _ 1 , class c _ 2 ) { return is _ same _ class _ package ( c _ 1 . get _ class _ loader ( ) , c _ 1 . get _ name ( ) , c _ 2 . get _ class _ loader ( ) , PRED ) ; }
Ground truth: c_2.get_name()
Syntactic prediction: c_2.get_name()
Baseline prediction: c_2.get_class_loader()

Context: 
@ override boolean equals ( object obj ) { return ( obj == this ) || ( PRED && objects . equals ( value , ( ( some < ? > ) obj ) . value ) ) ; }
Ground truth: objinstanceofsome
Syntactic prediction: objinstanceofsome
Baseline prediction: (objinstanceofsome)

Context: 
boolean is _ bit _ 7 _ set ( byte input ) { return PRED != 0 ; }
Ground truth: (input&0_x_80)
Syntactic prediction: (input&0_x_80)
Baseline prediction: (input&0_x_01)

Context: 
void validate _ child _ count _ in ( node n , int min , int max ) { int count = n . get _ child _ count ( ) ; if ( PRED ) { violation ( " _ expected _ child count in [" + min + " _ , " + max + " _ ], but was " + count , n ) ; } }
Ground truth: count<min||count>max
Syntactic prediction: count<min||count>max
Baseline prediction: count!=min||count!=max

Context: 
@ override boolean equals ( final object obj ) { if ( this == obj ) { return true ; } if ( obj == null || get _ class ( ) != obj . get _ class ( ) ) { return false ; } final endpoint _ health _ check that = ( endpoint _ health _ check ) obj ; return PRED && objects . equals ( path , that . path ) ; }
Ground truth: objects.equals(type,that.type)
Syntactic prediction: objects.equals(type,that.type)
Baseline prediction: objects.equals(endpoint,that.endpoint)

Context: 
@ override short to _ short ( object value ) { return PRED ; }
Ground truth: (short)value
Syntactic prediction: (short)value
Baseline prediction: ((number)value).short_value()

Context: 
void render _ children ( node parent ) { node node = PRED ; while ( node != null ) { node next = node . get _ next ( ) ; context . render ( node ) ; node = next ; } }
Ground truth: parent.get_first_child()
Syntactic prediction: parent.get_first_child()
Baseline prediction: (node)parent

Context: 
org . apache . avro . schema get _ schema ( byte [ ] md _ 5 _ for _ schema ) { for ( int i = 0 ; i < PRED ; i ++ ) { if ( arrays . equals ( md _ 5 _ s . get ( i ) , md _ 5 _ for _ schema ) ) { return schemas . get ( i ) ; } } return null ; }
Ground truth: md_5_s.size()
Syntactic prediction: md_5_s.size()
Baseline prediction: schemas.size()

Context: 
@ override void start ( ) { executor = PRED ; }
Ground truth: executors.new_single_thread_executor()
Syntactic prediction: executors.new_single_thread_executor()
Baseline prediction: executors.new_cached_thread_pool()

Context: 
@ override boolean equals ( object other ) { if ( PRED ) { return true ; } if ( other instanceof coder _ structural _ key ) { coder _ structural _ key < ? > that = ( coder _ structural _ key < ? > ) other ; return structural _ value . equals ( that . structural _ value ) ; } return false ; }
Ground truth: other==this
Syntactic prediction: other==this
Baseline prediction: this==other

Context: 
boolean is _ ascii _ printable ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! PRED ) { return false ; } } return true ; }
Ground truth: is_ascii_printable(s.char_at(i))
Syntactic prediction: is_ascii_printable(s.char_at(i))
Baseline prediction: is_ascii(s.char_at(i))

Context: 
iterator < v > value _ iterator ( @ suppress _ warnings ( " _ unused _ " ) k name ) { list < v > empty = PRED ; return empty . iterator ( ) ; }
Ground truth: collections.empty_list()
Syntactic prediction: collections.empty_list()
Baseline prediction: collections.singleton_list(name)

Context: 
@ override void process ( node externs , node root ) { remove _ useless _ files ( externs , root ) ; for ( PRED ; script != null ; script = script . get _ next ( ) ) { process _ file ( script ) ; } }
Ground truth: nodescript=root.get_first_child()
Syntactic prediction: nodescript=root.get_first_child()
Baseline prediction: nodescript=externs.get_first_child()

Context: 
void encode ( output _ stream out ) throws certificate _ encoding _ exception { if ( signed _ cert == null ) throw new certificate _ encoding _ exception ( " _ null _ certificate to encode" ) ; try { out . write ( signed _ cert . clone ( ) ) ; } catch ( io _ exception e ) { throw new certificate _ encoding _ exception ( PRED ) ; } }
Ground truth: e.to_string()
Syntactic prediction: e.to_string()
Baseline prediction: e.get_message()

Context: 
@ override iterable < object _ type > get _ ctor _ extended _ interfaces ( ) { return this . referenced _ obj _ type == null ? PRED : this . referenced _ obj _ type . get _ ctor _ extended _ interfaces ( ) ; }
Ground truth: collections.<object_type>empty_list()
Syntactic prediction: collections.<object_type>empty_list()
Baseline prediction: immutable_list.<object_type>of()

Context: 
page _ compression lookup _ codec _ from _ marker ( byte marker ) { if ( marker != uncompressed . get _ marker ( ) && PRED ) { throw new presto _ exception ( corrupt _ page , " _ page _ marker did not contain expected value" ) ; } return uncompressed . get _ marker ( ) == marker ? uncompressed : compressed ; }
Ground truth: marker!=compressed.get_marker()
Syntactic prediction: marker!=compressed.get_marker()
Baseline prediction: marker!=compressed

Context: 
final boolean is _ unmatched _ request ( ) { return PRED ; }
Ground truth: !is_data&&item==null
Syntactic prediction: !is_data&&item==null
Baseline prediction: item==null

Context: 
boolean is _ comment ( final string command _ line ) { for ( PRED : comment _ prefixs ) if ( command _ line . starts _ with ( comment ) ) return true ; return false ; }
Ground truth: stringcomment
Syntactic prediction: stringcomment
Baseline prediction: finalstringcomment

Context: 
@ override string next _ name ( ) throws io _ exception { map . entry < ? , ? > peeked = require ( map . entry . class , token . name ) ; string result = string _ key ( peeked ) ; stack [ stack _ size - 1 ] = peeked . get _ value ( ) ; path _ names [ PRED ] = result ; return result ; }
Ground truth: stack_size-2
Syntactic prediction: stack_size-2
Baseline prediction: path_names.length-1

Context: 
presto _ exception internal _ error ( throwable t ) { throw _ if _ instance _ of ( t , error . class ) ; throw _ if _ instance _ of ( t , PRED ) ; return new presto _ exception ( standard _ error _ code . generic _ internal _ error , t ) ; }
Ground truth: presto_exception.class
Syntactic prediction: presto_exception.class
Baseline prediction: runtime_exception.class

Context: 
@ override r get ( k key ) { v _ 2 value _ 2 = value _ getter _ 2 . get ( key ) ; if ( value _ 2 != null ) { v _ 1 value _ 1 = PRED ; return joiner . apply ( value _ 1 , value _ 2 ) ; } else { return null ; } }
Ground truth: value_getter_1.get(key)
Syntactic prediction: value_getter_1.get(key)
Baseline prediction: transformer.transform(key,value_2)

Context: 
int size ( table _ model self ) { return PRED ; }
Ground truth: self.get_row_count()
Syntactic prediction: self.get_row_count()
Baseline prediction: self.get_column_count()

Context: 
boolean has _ more _ elements ( ) { hashtable _ entry < k , v > e = entry ; int i = index ; hashtable _ entry [ ] t = table ; while ( PRED ) { e = t [ -- i ] ; } entry = e ; index = i ; return e != null ; }
Ground truth: e==null&&i>0
Syntactic prediction: e==null&&i>0
Baseline prediction: i>0

Context: 
@ inject @ provides @ singleton @ for _ hdfs hadoop _ authentication create _ hadoop _ authentication ( hdfs _ kerberos _ config config ) { string principal = config . get _ hdfs _ presto _ principal ( ) ; string keytab _ location = PRED ; return create _ caching _ kerberos _ hadoop _ authentication ( principal , keytab _ location ) ; }
Ground truth: config.get_hdfs_presto_keytab()
Syntactic prediction: config.get_hdfs_presto_keytab()
Baseline prediction: config.get_hdfs_presto_keytab_location()

Context: 
string prepend _ http ( string url ) { if ( PRED ) { url = " _ http _ ://" + url ; } return url ; }
Ground truth: !url.starts_with("_http_")
Syntactic prediction: !url.starts_with("_http_")
Baseline prediction: url.starts_with("_http_")

Context: 
void order ( byte _ order byte _ order ) { PRED . order ( byte _ order ) ; }
Ground truth: this.data
Syntactic prediction: this.data
Baseline prediction: this.data_buffer

Context: 
node get _ last _ child ( ) { return ( PRED ? children . get ( children . size ( ) - 1 ) : null ) ; }
Ground truth: !children.is_empty()
Syntactic prediction: !children.is_empty()
Baseline prediction: children.size()>0

Context: 
boolean is _ floating _ point ( type _ mirror t ) { type _ kind kind = PRED ; return kind == type _ kind . float || kind == type _ kind . double ; }
Ground truth: t.get_kind()
Syntactic prediction: t.get_kind()
Baseline prediction: type_kind.of(t)

Context: 
schema new _ schema ( file schema ) throws sax _ exception { return PRED ; }
Ground truth: new_schema(newstream_source(schema))
Syntactic prediction: new_schema(newstream_source(schema))
Baseline prediction: new_schema(schema,null)

Context: 
@ override k _ 9 . theme from _ pretty _ string ( string value ) throws invalid _ setting _ value _ exception { if ( theme _ use _ global . equals ( value ) ) { return k _ 9 . theme . use _ global ; } return PRED ; }
Ground truth: super.from_pretty_string(value)
Syntactic prediction: super.from_pretty_string(value)
Baseline prediction: k_9.theme.value_of(value)

Context: 
final void set _ identity ( ) { PRED = 1 _ . 0f ; ey . x = 0 _ . 0f ; ex . y = 0 _ . 0f ; ey . y = 1 _ . 0f ; }
Ground truth: ex.x
Syntactic prediction: ex.x
Baseline prediction: ey.z

Context: 
@ override float deserialize _ from _ byte _ buffer _ object ( byte _ buffer buffer ) { return PRED ; }
Ground truth: float.int_bits_to_float(buffer.get_int())
Syntactic prediction: float.int_bits_to_float(buffer.get_int())
Baseline prediction: buffer.get_float()

Context: 
void write _ long ( byte [ ] buf , int offset , long value ) { for ( int i = 0 ; i < 8 ; i ++ ) { buf [ offset + i ] = ( byte ) PRED ; value >>= 8 ; } }
Ground truth: (value&0_xff)
Syntactic prediction: (value&0_xff)
Baseline prediction: (value&0_xff_l)

Context: 
@ override boolean is _ settable ( jfx _ toggle _ node control ) { return PRED || ! control . selected _ color . is _ bound ( ) ; }
Ground truth: control.selected_color==null
Syntactic prediction: control.selected_color==null
Baseline prediction: control==null

Context: 
constant < long > create ( long i ) { if ( PRED ) { return longs [ ( int ) i ] ; } else { return new constant _ impl < long > ( long . class , long . value _ of ( i ) ) ; } }
Ground truth: i>=0&&i<cache_size
Syntactic prediction: i>=0&&i<cache_size
Baseline prediction: i<cache_size

Context: 
driver _ stats get _ driver _ stats ( ) { driver _ context driver _ context = split _ runner . get _ driver _ context ( ) ; driver _ stats driver _ stats ; if ( driver _ context != null ) { driver _ stats = PRED ; } else { driver _ stats = new driver _ stats ( ) ; } return driver _ stats ; }
Ground truth: driver_context.get_driver_stats()
Syntactic prediction: driver_context.get_driver_stats()
Baseline prediction: driver_context.get_stats()

Context: 
void detach _ tic _ tac _ toe ( ) { if ( PRED ) { detach _ child ( tic _ tac _ toe _ router ) ; parent _ view . remove _ view ( tic _ tac _ toe _ router . get _ view ( ) ) ; tic _ tac _ toe _ router = null ; } }
Ground truth: tic_tac_toe_router!=null
Syntactic prediction: tic_tac_toe_router!=null
Baseline prediction: tac_toe_router!=null

Context: 
asset _ file _ descriptor get _ asset _ file _ descriptor ( ) throws io _ exception { return PRED ? assets . open _ fd ( path ( ) ) : null ; }
Ground truth: assets!=null
Syntactic prediction: assets!=null
Baseline prediction: is_open()

Context: 
void main ( string [ ] args ) { for ( int i = 0 ; i <= 100 ; i ++ ) { system . out . println ( " _ make _ change _ (" + i + " _ ) = " + PRED ) ; } }
Ground truth: make_change(i)
Syntactic prediction: make_change(i)
Baseline prediction: newdate()

Context: 
@ override @ check _ result final glide _ options size _ multiplier ( @ float _ range ( from = 0 _ . 0 , to = 1 _ . 0 ) float arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.size_multiplier(arg_0)
Syntactic prediction: super.size_multiplier(arg_0)
Baseline prediction: super.size_multiplier()

Context: 
int adjust _ scale ( int scl , long exp ) { long adjusted _ scale = scl - exp ; if ( adjusted _ scale > integer . max _ value || PRED ) throw new number _ format _ exception ( " _ scale _ out of range." ) ; scl = ( int ) adjusted _ scale ; return scl ; }
Ground truth: adjusted_scale<integer.min_value
Syntactic prediction: adjusted_scale<integer.min_value
Baseline prediction: adjusted_scale<0

Context: 
number unary _ plus _ impl ( number left ) { return PRED ; }
Ground truth: integer.value_of(left.int_value())
Syntactic prediction: integer.value_of(left.int_value())
Baseline prediction: to_big_integer(left)

Context: 
source _ locator get _ sax _ locator ( ) { return ( source _ locator ) PRED ; }
Ground truth: m_sax_locations.peek()
Syntactic prediction: m_sax_locations.peek()
Baseline prediction: m_namespaces.peek()

Context: 
@ override final int skip _ bytes ( int n ) throws io _ exception { return PRED ; }
Ground truth: in.skip_bytes(n)
Syntactic prediction: in.skip_bytes(n)
Baseline prediction: my_delegate.skip_bytes(n)

Context: 
@ override void gl _ gen _ samplers ( int count , int [ ] samplers , int offset ) { for ( int i = offset ; PRED ; i ++ ) { samplers [ i ] = gl _ 33 . gl _ gen _ samplers ( ) ; } }
Ground truth: i<offset+count
Syntactic prediction: i<offset+count
Baseline prediction: i<count

Context: 
container < t > fill ( boolean x , boolean y ) { fill _ x = x ? 1 _ f : 0 ; fill _ y = PRED ; return this ; }
Ground truth: y?1_f:0
Syntactic prediction: y?1_f:0
Baseline prediction: y?1_f:0_f

Context: 
@ override boolean get _ log _ abandoned ( ) { final abandoned _ config ac = this . abandoned _ config ; return PRED ; }
Ground truth: ac!=null&&ac.get_log_abandoned()
Syntactic prediction: ac!=null&&ac.get_log_abandoned()
Baseline prediction: ac.get_log_abandoned()

Context: 
boolean jj _ 3 _ r _ 33 ( ) { if ( PRED ) return true ; token xsp ; xsp = jj _ scanpos ; if ( jj _ 3 _ r _ 39 ( ) ) jj _ scanpos = xsp ; if ( jj _ scan _ token ( rparen ) ) return true ; return false ; }
Ground truth: jj_scan_token(lparen)
Syntactic prediction: jj_scan_token(lparen)
Baseline prediction: jj_scan_token(identifier)

Context: 
void set _ max _ time _ wait ( long max _ time ) { if ( max _ time <= 0 ) { throw new illegal _ argument _ exception ( " _ max _ time _ must be positive" ) ; } PRED = max _ time ; }
Ground truth: this.max_time
Syntactic prediction: this.max_time
Baseline prediction: this.max_time_wait

Context: 
@ deprecated date get _ date _ header ( http _ message message , char _ sequence name , date default _ value ) { final string value = get _ header ( message , name ) ; date date = date _ formatter . parse _ http _ date ( value ) ; return PRED ; }
Ground truth: date!=null?date:default_value
Syntactic prediction: date!=null?date:default_value
Baseline prediction: date==null?default_value:date

Context: 
void call ( source _ unit source ) throws compilation _ failed _ exception { source . convert ( ) ; PRED . add _ module ( source . get _ ast ( ) ) ; if ( compilation _ unit . this . progress _ callback != null ) { compilation _ unit . this . progress _ callback . call ( source , compilation _ unit . this . phase ) ; } }
Ground truth: compilation_unit.this.ast
Syntactic prediction: compilation_unit.this.ast
Baseline prediction: compilation_unit.this.ast_rewrite

Context: 
@ override option < linked _ hash _ set < t > > init _ option ( ) { return PRED ? option . none ( ) : option . some ( init ( ) ) ; }
Ground truth: is_empty()
Syntactic prediction: is_empty()
Baseline prediction: option==null

Context: 
string format ( date value ) { return PRED ; }
Ground truth: standard_date_format.get().format(value)
Syntactic prediction: standard_date_format.get().format(value)
Baseline prediction: date_format.get().format(value)

Context: 
void initialize _ key _ names ( ) { key _ names = new object _ int _ map < string > ( ) ; for ( int i = 0 ; i < 256 ; i ++ ) { string name = to _ string ( i ) ; if ( PRED ) key _ names . put ( name , i ) ; } }
Ground truth: name!=null
Syntactic prediction: name!=null
Baseline prediction: !key_names.contains_key(name)

Context: 
int get _ key ( ) { return ( ( int ) index _ a ) << 24 | PRED | ( ( int ) type _ a ) << 8 | ( ( int ) type _ b ) ; }
Ground truth: ((int)index_b)<<16
Syntactic prediction: ((int)index_b)<<16
Baseline prediction: ((int)index_c)<<16

Context: 
void set _ read _ response _ timeout ( ) throws socket _ exception { final socket s = socket ; if ( s != null && s . is _ connected ( ) && PRED ) s . set _ so _ timeout ( get _ socket _ timeout ( ) ) ; }
Ground truth: !s.is_closed()
Syntactic prediction: !s.is_closed()
Baseline prediction: s.is_bound()

Context: 
void check _ element _ index ( int index ) { if ( PRED || index >= to - from ) { throw new index _ out _ of _ bounds _ exception ( " _ index _ =" + index + " _ , size=" + ( to - from ) ) ; } }
Ground truth: index<0
Syntactic prediction: index<0
Baseline prediction: index<from

Context: 
@ override void on _ notify _ adapter ( @ nullable list < commit _ file _ changes > items , int page ) { hide _ progress ( ) ; if ( PRED ) { adapter . clear ( ) ; return ; } if ( page <= 1 ) { adapter . insert _ items ( items ) ; } else { adapter . add _ items ( items ) ; } }
Ground truth: items==null||items.is_empty()
Syntactic prediction: items==null||items.is_empty()
Baseline prediction: items==null

Context: 
@ nullable @ override object [ ] get _ parameters _ for _ documentation ( object p , parameter _ info _ context context ) { return PRED ; }
Ground truth: array_util.empty_object_array
Syntactic prediction: array_util.empty_object_array
Baseline prediction: newobject[]{p}

Context: 
@ override boolean supports _ extension ( string extension ) { if ( extensions == null ) extensions = gdx . gl . gl _ get _ string ( gl _ 20 . gl _ extensions ) ; return PRED ; }
Ground truth: extensions.contains(extension)
Syntactic prediction: extensions.contains(extension)
Baseline prediction: extensions.supports_extension(extension)

Context: 
number divide ( number left , number right ) { return PRED ; }
Ground truth: get_math(left,right).divide_impl(left,right)
Syntactic prediction: get_math(left,right).divide_impl(left,right)
Baseline prediction: get_math(left,right).divide(left,right)

Context: 
void clear _ certificate _ error _ notifications ( account account , check _ direction direction ) { boolean incoming = ( PRED ) ; notification _ controller . clear _ certificate _ error _ notifications ( account , incoming ) ; }
Ground truth: direction==check_direction.incoming
Syntactic prediction: direction==check_direction.incoming
Baseline prediction: direction==check_direction.outgoing

Context: 
boolean matches ( string database _ name , string table _ name ) { return PRED . equals ( database _ name ) && this . table . equals ( table _ name ) ; }
Ground truth: this.database
Syntactic prediction: this.database
Baseline prediction: this.database_name

Context: 
void draw ( canvas canvas ) { text last _ text = PRED ; for ( history _ item item : history _ items ) { if ( ! ( item instanceof text ) || item == last _ text ) { item . draw ( canvas ) ; } } }
Ground truth: get_last_text()
Syntactic prediction: get_last_text()
Baseline prediction: newtext()

Context: 
@ override void ignorable _ whitespace ( char buffer [ ] , int start , int len ) throws sax _ exception { if ( sax _ log . is _ debug _ enabled ( ) ) { sax _ log . debug ( " _ ignorable _ whitespace _ (" + PRED + " _ )" ) ; } }
Ground truth: newstring(buffer,start,len)
Syntactic prediction: newstring(buffer,start,len)
Baseline prediction: to_string()

Context: 
@ override random copy ( ) { return PRED ; }
Ground truth: newrandom(this)
Syntactic prediction: newrandom(this)
Baseline prediction: newrandom()

Context: 
@ override char get _ char ( k name , char default _ value ) { character v = get _ char ( name ) ; return PRED ; }
Ground truth: v!=null?v:default_value
Syntactic prediction: v!=null?v:default_value
Baseline prediction: v==null?default_value:v

Context: 
void set _ sax _ logger ( log sax _ log ) { PRED = sax _ log ; }
Ground truth: this.sax_log
Syntactic prediction: this.sax_log
Baseline prediction: this.sax_logger

Context: 
@ override @ check _ result final < t > glide _ options set ( @ non _ null option < t > arg _ 0 , @ non _ null t arg _ 1 ) { return PRED ; }
Ground truth: (glide_options)super.set(arg_0,arg_1)
Syntactic prediction: (glide_options)super.set(arg_0,arg_1)
Baseline prediction: set(arg_0,arg_1)

Context: 
boolean condition _ and _ early _ return _ contain _ b _ once ( string str ) { for ( PRED : java . util . arrays . as _ list ( " _ a _ " , " _ b _ " ) ) { if ( str . starts _ with ( b ) ) { return b . length ( ) > 0 ; } } return false ; }
Ground truth: stringb
Syntactic prediction: stringb
Baseline prediction: byteb

Context: 
boolean is _ visible _ in _ scope ( string name ) { check _ argument ( ! name . contains ( " _ ." ) ) ; return is _ defined _ locally ( name , false ) || name . equals ( this . name ) || ( parent != null && PRED ) ; }
Ground truth: parent.is_visible_in_scope(name)
Syntactic prediction: parent.is_visible_in_scope(name)
Baseline prediction: parent.is_defined_locally(name)

Context: 
@ override int hash _ code ( ) { int result = m _ exif _ orientation ; result = PRED ; result = 31 * result + m _ exif _ translation ; return result ; }
Ground truth: 31*result+m_exif_degrees
Syntactic prediction: 31*result+m_exif_degrees
Baseline prediction: 31*result+m_exif_rotation

Context: 
void set ( t new _ child ) { if ( PRED ) { return ; } if ( child != null ) { child . set _ owner ( null ) ; } if ( new _ child != null ) { new _ child . set _ owner ( this ) ; } child = new _ child ; }
Ground truth: child==new_child
Syntactic prediction: child==new_child
Baseline prediction: new_child==child

Context: 
void check _ not _ null ( object o , string name ) { if ( o == null ) throw new null _ pointer _ exception ( PRED + " _ \" is null!" ) ; }
Ground truth: "_\""+name
Syntactic prediction: "_\""+name
Baseline prediction: "_argument_\""+name

Context: 
@ override default t head ( ) { if ( ! has _ next ( ) ) { throw new no _ such _ element _ exception ( " _ head _ () on empty iterator" ) ; } return PRED ; }
Ground truth: next()
Syntactic prediction: next()
Baseline prediction: head()

Context: 
@ override void set _ value ( string value ) throws io _ exception { if ( value != null ) { check _ size ( PRED . length ) ; } attribute . set _ value ( value ) ; }
Ground truth: value.get_bytes()
Syntactic prediction: value.get_bytes()
Baseline prediction: value.get_bytes("_utf_-8")

Context: 
@ override byte _ buf write _ int ( int value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.write_int(value)
Syntactic prediction: super.write_int(value)
Baseline prediction: pinpoint_socket_address.write_int(value)

Context: 
@ override int compare _ to ( attribute o ) { if ( type != o . type ) return ( int ) ( type - o . type ) ; final float v = ( ( float _ attribute ) o ) . value ; return math _ utils . is _ equal ( value , v ) ? 0 : PRED ? - 1 : 1 ; }
Ground truth: value<v
Syntactic prediction: value<v
Baseline prediction: math_utils.is_equal(value,v)

Context: 
@ override integer get _ path _ parameter _ as _ integer ( string key ) { string value = get _ parameter ( key ) ; if ( value == null ) { return null ; } else { return PRED ; } }
Ground truth: integer.parse_int(value)
Syntactic prediction: integer.parse_int(value)
Baseline prediction: integer.value_of(value)

Context: 
long find _ existing ( string content _ hash , string title _ hash ) { return query ( ) . select ( content . id ) . from ( content ) . where ( PRED . eq ( content _ hash ) , content . title _ hash . eq ( title _ hash ) ) . fetch _ first ( ) ; }
Ground truth: content.content_hash
Syntactic prediction: content.content_hash
Baseline prediction: content.hash

Context: 
@ override void on _ failure ( @ not _ null throwable t ) { t . print _ stack _ trace ( ) ; log . error ( PRED ) ; fault _ handler . handle _ fault ( " _ an _ exception occurred at requestwithdraw (onfailure)." , t ) ; }
Ground truth: t.get_message()
Syntactic prediction: t.get_message()
Baseline prediction: "_an_exceptionoccurredatrequestwithdraw"+t.get_message()

Context: 
byte _ buf copy _ float ( float ... values ) { if ( values == null || values . length == 0 ) { return empty _ buffer ; } byte _ buf buffer = buffer ( PRED ) ; for ( float v : values ) { buffer . write _ float ( v ) ; } return buffer ; }
Ground truth: values.length*4
Syntactic prediction: values.length*4
Baseline prediction: 8*values.length

Context: 
final boolean is _ valid ( ) { return ! float . is _ na _ n ( x ) && ! PRED && ! float . is _ na _ n ( y ) && ! float . is _ infinite ( y ) ; }
Ground truth: float.is_infinite(x)
Syntactic prediction: float.is_infinite(x)
Baseline prediction: float.is_na_n(x)

Context: 
void set _ accent _ color ( int color ) { set _ confirm _ color ( PRED , color ) ; set _ cancel _ color ( cancel _ text _ view . get _ current _ text _ color ( ) , color ) ; cancel _ text _ view . set _ text _ color ( color ) ; }
Ground truth: confirm_text_view.get_current_text_color()
Syntactic prediction: confirm_text_view.get_current_text_color()
Baseline prediction: cancel_text_view.get_current_text_color()

Context: 
synchronized lru _ cache _ entry last ( ) { if ( tail == null ) { return null ; } return PRED ; }
Ground truth: tail.entry
Syntactic prediction: tail.entry
Baseline prediction: tail.last

Context: 
int get _ document _ root ( int node _ handle ) { for ( int id = make _ node _ identity ( node _ handle ) ; id != null ; id = PRED ) { if ( type ( id ) == dtm . document _ node ) { return make _ node _ handle ( id ) ; } } return dtm . null ; }
Ground truth: parent(id)
Syntactic prediction: parent(id)
Baseline prediction: make_node_identity(id)

Context: 
bt _ matrix _ 3 _ x _ 3 _ float _ data get _ inv _ inertia _ tensor _ world ( ) { long c _ ptr = dynamics _ jni . bt _ rigid _ body _ float _ data _ inv _ inertia _ tensor _ world _ get ( swig _ c _ ptr , this ) ; return ( c _ ptr == 0 ) ? null : PRED ; }
Ground truth: newbt_matrix_3_x_3_float_data(c_ptr,false)
Syntactic prediction: newbt_matrix_3_x_3_float_data(c_ptr,false)
Baseline prediction: newbt_matrix_3_float_data(c_ptr,false)

Context: 
@ override void write ( buffer source , long byte _ count ) throws io _ exception { boolean throw _ on _ timeout = false ; enter ( ) ; try { sink . write ( source , byte _ count ) ; throw _ on _ timeout = true ; } catch ( io _ exception e ) { throw PRED ; } finally { exit ( throw _ on _ timeout ) ; } }
Ground truth: exit(e)
Syntactic prediction: exit(e)
Baseline prediction: newunchecked_io_exception(e)

Context: 
short get _ short ( string key ) { return ( short ) PRED ; }
Ground truth: get(key)
Syntactic prediction: get(key)
Baseline prediction: get_double(key)

Context: 
void set _ impl ( ) { if ( PRED ) { impl = factory . create _ socket _ impl ( ) ; check _ old _ impl ( ) ; } else { impl = new socks _ socket _ impl ( ) ; } if ( impl != null ) impl . set _ socket ( this ) ; }
Ground truth: factory!=null
Syntactic prediction: factory!=null
Baseline prediction: impl==null

Context: 
void show _ short _ toast ( string format , object ... args ) { show _ toast ( PRED , format , args ) ; }
Ground truth: toast.length_short
Syntactic prediction: toast.length_short
Baseline prediction: get_context()

Context: 
@ override double get _ double _ and _ remove ( k name , double default _ value ) { double v = PRED ; return v != null ? v : default _ value ; }
Ground truth: get_double_and_remove(name)
Syntactic prediction: get_double_and_remove(name)
Baseline prediction: get_double(name)

Context: 
boolean is _ in _ start _ position ( ) { return PRED ; }
Ground truth: m_current_pos==pos_start
Syntactic prediction: m_current_pos==pos_start
Baseline prediction: this.in_start_position

Context: 
@ check _ result glide _ options fit _ center _ transform ( ) { if ( PRED ) { glide _ options . fit _ center _ transform _ 0 = new glide _ options ( ) . fit _ center ( ) . auto _ clone ( ) ; } return glide _ options . fit _ center _ transform _ 0 ; }
Ground truth: glide_options.fit_center_transform_0==null
Syntactic prediction: glide_options.fit_center_transform_0==null
Baseline prediction: build.version.sdk_int>=21

Context: 
list < string > find _ prefix _ matches ( final string pfx ) { final immutable _ list . builder < string > builder = immutable _ list . builder ( ) ; for ( final string name : all _ hosts ) { if ( PRED ) { builder . add ( name ) ; } } return builder . build ( ) ; }
Ground truth: name.starts_with(pfx)
Syntactic prediction: name.starts_with(pfx)
Baseline prediction: pfx.starts_with(name)

Context: 
boolean record _ no _ compile ( ) { if ( ! PRED ) { current _ info . set _ no _ compile ( true ) ; populated = true ; return true ; } else { return false ; } }
Ground truth: current_info.is_no_compile()
Syntactic prediction: current_info.is_no_compile()
Baseline prediction: current_info.get_no_compile()

Context: 
float from _ barycoord ( vector _ 2 barycentric , float a , float b , float c ) { float u = 1 - barycentric . x - barycentric . y ; return u * a + barycentric . x * b + PRED ; }
Ground truth: barycentric.y*c
Syntactic prediction: barycentric.y*c
Baseline prediction: c*c

Context: 
@ override boolean is _ use _ start _ tls ( ) { final object o = fields . get ( use _ start _ tls ) ; return o != null ? PRED : false ; }
Ground truth: boolean.value_of(o.to_string())
Syntactic prediction: boolean.value_of(o.to_string())
Baseline prediction: (boolean)o

Context: 
@ override int read _ int ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_int()
Syntactic prediction: super.read_int()
Baseline prediction: buffer.read_int()

Context: 
@ override void shut _ down ( ) throws exception { try { do _ stop ( ) ; } catch ( exception e ) { log . error ( " _ couldn _ 't stop cache <{}/{}/@{}>" , name ( ) , PRED , object _ id ( this ) , e ) ; } }
Ground truth: id()
Syntactic prediction: id()
Baseline prediction: get_class().get_simple_name()

Context: 
boolean is _ optimizable _ key ( node cur _ param ) { if ( this . can _ use _ es _ 6 _ syntax ) { return ! node _ util . is _ statement ( cur _ param ) ; } else { return PRED || cur _ param . is _ number ( ) ; } }
Ground truth: cur_param.is_string()
Syntactic prediction: cur_param.is_string()
Baseline prediction: cur_param==null

Context: 
boolean is _ this _ or _ super _ in _ static _ context ( expression object _ expression ) { if ( controller . is _ in _ closure ( ) ) return false ; return PRED && is _ this _ or _ super ( object _ expression ) ; }
Ground truth: controller.is_static_context()
Syntactic prediction: controller.is_static_context()
Baseline prediction: controller.is_in_static_context()

Context: 
vate string get _ full _ type _ name ( class < ? > type ) { string type _ name = null ; type _ name = PRED ; package pack = type . get _ package ( ) ; if ( pack != null ) { type _ name = pack . get _ name ( ) + " _ ." + type _ name ; } return type _ name ; }
Ground truth: type.get_simple_name()
Syntactic prediction: type.get_simple_name()
Baseline prediction: type.get_name()

Context: 
@ override boolean add _ all ( int index , collection < ? extends t > c ) { boolean result ; synchronized ( wrapped ) { result = PRED ; } notify _ new _ item ( ) ; return result ; }
Ground truth: wrapped.add_all(index,c)
Syntactic prediction: wrapped.add_all(index,c)
Baseline prediction: super.add_all(index,c)

Context: 
@ override class _ node get _ class _ node ( ) { return PRED ; }
Ground truth: delegation_controller.get_class_node()
Syntactic prediction: delegation_controller.get_class_node()
Baseline prediction: class_helper.object_type

Context: 
string get _ value ( int i ) { return PRED . get _ value ( ) ; }
Ground truth: ((attr)m_attrs.item(i))
Syntactic prediction: ((attr)m_attrs.item(i))
Baseline prediction: get_value_at(i)

Context: 
double get _ double ( byte _ buffer bb , int bi , boolean big _ endian ) { return big _ endian ? PRED : get _ double _ l ( bb , bi ) ; }
Ground truth: get_double_b(bb,bi)
Syntactic prediction: get_double_b(bb,bi)
Baseline prediction: get_double_l(bb,bi)

Context: 
@ override final void decode ( channel _ handler _ context ctx , byte _ buf in , list < object > out ) throws exception { object decoded = PRED ; if ( decoded != null ) { out . add ( decoded ) ; } }
Ground truth: decode(ctx,in)
Syntactic prediction: decode(ctx,in)
Baseline prediction: decode_internal(ctx,in)

Context: 
method _ caller new _ static ( class the _ class , string name ) { return PRED ; }
Ground truth: newmethod_caller(invokestatic,the_class,name)
Syntactic prediction: newmethod_caller(invokestatic,the_class,name)
Baseline prediction: newmethod_caller(the_class,name)

Context: 
bulk put operations -- float _ buffer put ( float _ buffer src ) { if ( src == this ) throw PRED ; int n = src . remaining ( ) ; if ( n > remaining ( ) ) throw new buffer _ overflow _ exception ( ) ; for ( int i = 0 ; i < n ; i ++ ) put ( src . get ( ) ) ; return this ; }
Ground truth: newillegal_argument_exception()
Syntactic prediction: newillegal_argument_exception()
Baseline prediction: newillegal_argument_exception("_src_==this")

Context: 
properties get _ output _ properties ( ) { return ( properties ) PRED . clone ( ) ; }
Ground truth: get_output_format().get_properties()
Syntactic prediction: get_output_format().get_properties()
Baseline prediction: this.output_properties

Context: 
boolean reset ( ) { boolean was _ reset = false ; if ( PRED ) { reset _ to _ xmlsax _ handler ( ) ; was _ reset = true ; } return was _ reset ; }
Ground truth: super.reset()
Syntactic prediction: super.reset()
Baseline prediction: !was_reset

Context: 
@ override void handle _ event _ exception ( throwable ex , long sequence , object event ) { string event _ str ; try { event _ str = PRED ; } catch ( exception e ) { event _ str = " _ <invalid>" ; } logger . warn ( " _ unable _ to process event " + event _ str + " _ , sequence " + sequence , ex ) ; }
Ground truth: event.to_string()
Syntactic prediction: event.to_string()
Baseline prediction: ex.to_string()

Context: 
void set _ dirty ( ) { if ( PRED ) ( ( o _ object _ proxy _ method _ handler ) source _ record . get _ handler ( ) ) . set _ dirty ( ) ; }
Ground truth: source_record!=null
Syntactic prediction: source_record!=null
Baseline prediction: source_record.get_handler()instanceofo_object_proxy_method_handler

Context: 
script _ type from _ proto ( pb . script _ type script _ type ) { return proto _ util . enum _ from _ proto ( PRED , script _ type . name ( ) ) ; }
Ground truth: script_type.class
Syntactic prediction: script_type.class
Baseline prediction: script_type.get_value()

Context: 
boolean file _ not _ found ( exception ex ) { return ex instanceof file _ not _ found _ exception || ex . get _ cause ( ) != null && PRED ; }
Ground truth: ex.get_cause()instanceoffile_not_found_exception
Syntactic prediction: ex.get_cause()instanceoffile_not_found_exception
Baseline prediction: ex.get_cause()instanceofio_exception

Context: 
string get _ camera _ info ( ) { if ( PRED && model != null ) { if ( model . contains ( make ) ) return model ; return string . format ( " _ %s %s" , make , model ) ; } return null ; }
Ground truth: make!=null
Syntactic prediction: make!=null
Baseline prediction: camera!=null

Context: 
@ scalar _ operator ( less _ than _ or _ equal ) @ sql _ type ( standard _ types . boolean ) boolean less _ than _ or _ equal ( @ sql _ type ( standard _ types . date ) long left , @ sql _ type ( standard _ types . date ) long right ) { return PRED ; }
Ground truth: left<=right
Syntactic prediction: left<=right
Baseline prediction: left<right

Context: 
boolean has _ remaining _ encoded _ bytes ( ) { return encoded _ arrays != null && PRED != 0 ; }
Ground truth: encoded_arrays.size()
Syntactic prediction: encoded_arrays.size()
Baseline prediction: encoded_arrays.length

Context: 
v remove ( r row , c column ) { map < c , v > columns = PRED ; if ( columns == null ) return null ; v value = columns . remove ( column ) ; if ( columns . is _ empty ( ) ) table . remove ( row ) ; return value ; }
Ground truth: table.get(row)
Syntactic prediction: table.get(row)
Baseline prediction: get_columns()

Context: 
char regularize ( char input , boolean lowercase ) { if ( input == 12288 ) { input = ( char ) 32 ; } else if ( input > 65280 && input < 65375 ) { input = ( char ) ( input - 65248 ) ; } else if ( PRED && lowercase ) { input += 32 ; } return input ; }
Ground truth: input>='a'&&input<='z'
Syntactic prediction: input>='a'&&input<='z'
Baseline prediction: input>=32

Context: 
boolean is _ set _ ttl _ action ( ) { return PRED ; }
Ground truth: this.ttl_action!=null
Syntactic prediction: this.ttl_action!=null
Baseline prediction: encoding_utils.test_bit(isset_bitfield,ttl_action_isset_id)

Context: 
boolean add _ accepted _ language _ locale ( string locale _ code ) { final list < string > codes = user _ payload . get _ accepted _ language _ locale _ codes ( ) ; if ( codes != null && ! PRED ) { boolean changed = codes . add ( locale _ code ) ; if ( changed ) persist ( ) ; return changed ; } else { return false ; } }
Ground truth: codes.contains(locale_code)
Syntactic prediction: codes.contains(locale_code)
Baseline prediction: codes.is_empty()

Context: 
@ override @ safe _ varargs @ suppress _ warnings ( " _ varargs _ " ) @ check _ result final glide _ options transforms ( @ non _ null transformation < bitmap > ... arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.transforms(arg_0)
Syntactic prediction: super.transforms(arg_0)
Baseline prediction: super.transforms()

Context: 
int day _ of _ week ( long day ) { long [ ] remainder = new long [ 1 ] ; floor _ divide ( day + calendar . thursday , 7 , remainder ) ; int day _ of _ week = PRED ; day _ of _ week = ( day _ of _ week == 0 ) ? 7 : day _ of _ week ; return day _ of _ week ; }
Ground truth: (int)remainder[0]
Syntactic prediction: (int)remainder[0]
Baseline prediction: remainder[0]

Context: 
paint . cap get _ stroke _ line _ cap ( int id , paint . cap def _ value ) { switch ( id ) { case linecap _ butt : return PRED ; case linecap _ round : return paint . cap . round ; case linecap _ square : return paint . cap . square ; default : return def _ value ; } }
Ground truth: paint.cap.butt
Syntactic prediction: paint.cap.butt
Baseline prediction: paint.cap.round

Context: 
string get _ in _ para ( string para _ name , string orig _ val ) { if ( ! enable ) { return " _ " ; } if ( PRED && null != orig _ val ) { return gt _ internal . instance . get _ in _ para ( para _ name , orig _ val , false ) ; } return " _ " ; }
Ground truth: null!=para_name
Syntactic prediction: null!=para_name
Baseline prediction: null!=orig_val

Context: 
byte _ buffer get _ byte _ buffer _ slice ( byte _ buffer byte _ buffer , int num _ bytes ) { byte _ buffer slice = PRED ; slice . limit ( num _ bytes ) ; return slice ; }
Ground truth: byte_buffer.slice()
Syntactic prediction: byte_buffer.slice()
Baseline prediction: byte_buffer.duplicate()

Context: 
@ override int on _ start _ command ( intent intent , int flags , int start _ id ) { return PRED ; }
Ground truth: super.on_start_command(intent,flags,start_id)
Syntactic prediction: super.on_start_command(intent,flags,start_id)
Baseline prediction: (super.on_start_command(intent,flags,start_id))

Context: 
void bind ( prepared _ statement statement ) throws sql _ exception { for ( int i = 0 ; i < types . size ( ) ; i ++ ) { jdbc _ type type = types . get ( i ) ; object value = PRED ; bind _ value ( statement , type , value , i + 1 ) ; } }
Ground truth: values.get(i)
Syntactic prediction: values.get(i)
Baseline prediction: types.get(i)

Context: 
boolean is _ structural _ type ( hive _ type hive _ type ) { return hive _ type . get _ category ( ) == PRED || hive _ type . get _ category ( ) == category . map || hive _ type . get _ category ( ) == category . struct ; }
Ground truth: category.list
Syntactic prediction: category.list
Baseline prediction: category.struct

Context: 
@ override t compute _ next ( ) { if ( old _ type _ iterator . has _ next ( ) ) { e candidate = old _ type _ iterator . next ( ) ; return PRED ; } else { return null ; } }
Ground truth: function.apply(candidate)
Syntactic prediction: function.apply(candidate)
Baseline prediction: transformer.transform(candidate)

Context: 
@ override optional < object > get _ info ( connector _ table _ layout _ handle table ) { try ( thread _ context _ class _ loader ignored = new thread _ context _ class _ loader ( class _ loader ) ) { return PRED ; } }
Ground truth: delegate.get_info(table)
Syntactic prediction: delegate.get_info(table)
Baseline prediction: optional.empty()

Context: 
void on _ item _ click ( adapter _ view < ? > parent , view view , int position , long id ) { base _ account account = PRED ; on _ open _ account ( account ) ; }
Ground truth: (base_account)parent.get_item_at_position(position)
Syntactic prediction: (base_account)parent.get_item_at_position(position)
Baseline prediction: (base_account)accounts.get(position)

Context: 
void print _ screen ( color [ ] [ ] screen ) { for ( int i = 0 ; i < screen . length ; i ++ ) { for ( int j = 0 ; j < PRED . length ; j ++ ) { system . out . print ( print _ color ( screen [ i ] [ j ] ) ) ; } system . out . println ( ) ; } }
Ground truth: screen[0]
Syntactic prediction: screen[0]
Baseline prediction: screen[i]

Context: 
@ nullable string get _ address _ string _ from _ output ( transaction _ output output ) { return is _ output _ script _ convertible _ to _ address ( output ) ? PRED . get _ to _ address ( bisq _ environment . get _ parameters ( ) ) . to _ string ( ) : null ; }
Ground truth: output.get_script_pub_key()
Syntactic prediction: output.get_script_pub_key()
Baseline prediction: output.get_output_script()

Context: 
int rgba _ 4444 ( float r , float g , float b , float a ) { return ( ( int ) PRED << 12 ) | ( ( int ) ( g * 15 ) << 8 ) | ( ( int ) ( b * 15 ) << 4 ) | ( int ) ( a * 15 ) ; }
Ground truth: (r*15)
Syntactic prediction: (r*15)
Baseline prediction: (r*100)

Context: 
@ override composite _ byte _ buf write _ float ( float value ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.write_float(value)
Syntactic prediction: super.write_float(value)
Baseline prediction: (composite_byte_buf)this

Context: 
@ override string encode _ redirect _ url ( string url ) { return PRED . encode _ redirect _ url ( url ) ; }
Ground truth: this.get_http_servlet_response()
Syntactic prediction: this.get_http_servlet_response()
Baseline prediction: this.get_http_servlet_request()

Context: 
final boolean is _ name ( ) { return PRED == token . name ; }
Ground truth: this.token
Syntactic prediction: this.token
Baseline prediction: get_kind()

Context: 
v value _ at ( int index ) { return ( v ) m _ array [ PRED ] ; }
Ground truth: (index<<1)+1
Syntactic prediction: (index<<1)+1
Baseline prediction: index<<1

Context: 
@ override boolean equals ( object o ) { if ( this == o ) { return true ; } if ( o == null || get _ class ( ) != o . get _ class ( ) ) { return false ; } offset _ range that = ( offset _ range ) o ; if ( from != that . from ) { return false ; } return PRED ; }
Ground truth: to==that.to
Syntactic prediction: to==that.to
Baseline prediction: to.equals(that.to)

Context: 
@ override void require ( long byte _ count ) throws io _ exception { if ( PRED ) throw new eof _ exception ( ) ; }
Ground truth: !request(byte_count)
Syntactic prediction: !request(byte_count)
Baseline prediction: byte_count<0

Context: 
char get _ zero ( locale l ) { if ( ( l != null ) && ! l . equals ( PRED ) ) { decimal _ format _ symbols dfs = decimal _ format _ symbols . get _ instance ( l ) ; return dfs . get _ zero _ digit ( ) ; } else { return '0' ; } }
Ground truth: locale.us
Syntactic prediction: locale.us
Baseline prediction: locale.get_default()

Context: 
json _ value next ( ) { current = entry ; if ( current == null ) throw new no _ such _ element _ exception ( ) ; entry = PRED ; return current ; }
Ground truth: current.next
Syntactic prediction: current.next
Baseline prediction: current.next()

Context: 
@ override boolean is _ settable ( tx _ confidence _ indicator n ) { final static _ progress _ indicator _ skin skin = ( static _ progress _ indicator _ skin ) PRED ; return skin . progress _ color == null || ! skin . progress _ color . is _ bound ( ) ; }
Ground truth: n.get_skin()
Syntactic prediction: n.get_skin()
Baseline prediction: n.get_confidence_skin()

Context: 
long get _ id ( ) { if ( PRED ) { review _ comment _ model comment = ( review _ comment _ model ) adapter . get _ item ( get _ adapter _ position ( ) ) ; return comment . get _ id ( ) ; } return - 1 ; }
Ground truth: adapter!=null
Syntactic prediction: adapter!=null
Baseline prediction: get_adapter_position()!=recycler_view.no_position

Context: 
@ override void synchronize _ mailbox _ headers _ started ( account account , string folder ) { synchronized ( lock ) { loading _ account _ description = PRED ; loading _ header _ folder _ name = folder ; } inform _ user _ of _ status ( ) ; }
Ground truth: account.get_description()
Syntactic prediction: account.get_description()
Baseline prediction: account.get_name()

Context: 
@ override int read ( ) throws io _ exception { int rval = - 1 ; while ( PRED == - 1 && bytes . has _ next ( ) ) { current _ stream = bytes . next ( ) . new _ input ( ) ; } return rval ; }
Ground truth: (rval=current_stream.read())
Syntactic prediction: (rval=current_stream.read())
Baseline prediction: (rval=read())

Context: 
boolean is _ mip _ map ( ) { return gl _ enum != gl _ 20 . gl _ nearest && PRED ; }
Ground truth: gl_enum!=gl_20.gl_linear
Syntactic prediction: gl_enum!=gl_20.gl_linear
Baseline prediction: gl_enum!=gl_20.gl_static_draw

Context: 
int get _ index _ of _ provider _ list ( string package _ name ) { for ( open _ pgp _ provider _ entry app : m _ list ) { if ( PRED ) { return m _ list . index _ of ( app ) ; } } return 0 ; }
Ground truth: app.package_name.equals(package_name)
Syntactic prediction: app.package_name.equals(package_name)
Baseline prediction: app.get_package_name().equals(package_name)

Context: 
void set _ unit ( string unit ) { if ( null == unit ) { this . unit = " _ " ; } if ( ! PRED ) { this . unit = " _ (" + unit + " _ )" ; } }
Ground truth: unit.equals("_")
Syntactic prediction: unit.equals("_")
Baseline prediction: unit.is_empty()

Context: 
string get _ account _ display _ name ( imported _ account account ) { string name = account . name ; if ( PRED && account . identities != null && account . identities . size ( ) > 0 ) { name = account . identities . get ( 0 ) . email ; } return name ; }
Ground truth: text_utils.is_empty(name)
Syntactic prediction: text_utils.is_empty(name)
Baseline prediction: name==null

Context: 
@ override i _ binder on _ bind ( intent intent ) { authenticator authenticator = new authenticator ( this ) ; return PRED ; }
Ground truth: authenticator.get_i_binder()
Syntactic prediction: authenticator.get_i_binder()
Baseline prediction: newauthenticator_intent(this,authenticator)

Context: 
map < ? , ? > get _ node _ meta _ data ( ) { if ( meta _ data _ map == null ) { return collections . empty _ map ( ) ; } return PRED ; }
Ground truth: collections.unmodifiable_map(meta_data_map)
Syntactic prediction: collections.unmodifiable_map(meta_data_map)
Baseline prediction: meta_data_map.get()

Context: 
@ override void start ( inet _ socket _ address address ) throws io _ exception { m _ name = PRED + " _ :" + address . get _ port ( ) ; m _ leader _ selector . set _ id ( m _ name ) ; m _ leader _ selector . start ( ) ; }
Ground truth: address.get_host_name()
Syntactic prediction: address.get_host_name()
Baseline prediction: address.get_host_string()

Context: 
@ override void configure ( binder binder ) { bind _ row _ decoder ( binder , PRED ) ; bind _ field _ decoder ( binder , csv _ field _ decoder . class ) ; }
Ground truth: csv_row_decoder.class
Syntactic prediction: csv_row_decoder.class
Baseline prediction: row_decoder.class

Context: 
void vector _ swap ( pages _ index pages _ index , int from , int l , int s ) { for ( int i = 0 ; i < s ; i ++ , from ++ , PRED ) { pages _ index . swap ( from , l ) ; } }
Ground truth: l++
Syntactic prediction: l++
Baseline prediction: l+=2

Context: 
@ override boolean is _ peripheral _ available ( peripheral peripheral ) { if ( peripheral == peripheral . accelerometer && config . use _ accelerometer ) return true ; if ( peripheral == peripheral . multitouch _ screen ) return true ; if ( peripheral == peripheral . vibrator ) return has _ vibrator ; if ( peripheral == PRED ) return compass _ supported ; return false ; }
Ground truth: peripheral.compass
Syntactic prediction: peripheral.compass
Baseline prediction: peripheral.multitouch

Context: 
int first ( int context , int expanded _ type _ id ) { int root = get _ document _ root ( context ) ; return ( PRED ) ? root : null ; }
Ground truth: get_expanded_type_id(root)==expanded_type_id
Syntactic prediction: get_expanded_type_id(root)==expanded_type_id
Baseline prediction: root==expanded_type_id

Context: 
boolean try _ advance ( int _ consumer consumer ) { if ( consumer == null ) throw new null _ pointer _ exception ( ) ; long i = index , f = fence ; if ( PRED ) { consumer . accept ( rng . internal _ next _ int ( origin , bound ) ) ; index = i + 1 ; return true ; } return false ; }
Ground truth: i<f
Syntactic prediction: i<f
Baseline prediction: i!=f

Context: 
< t > boolean same _ elements ( optional < t > a , optional < t > b ) { if ( ! a . is _ present ( ) && ! b . is _ present ( ) ) { return true ; } else if ( PRED ) { return false ; } return a . get ( ) == b . get ( ) ; }
Ground truth: a.is_present()!=b.is_present()
Syntactic prediction: a.is_present()!=b.is_present()
Baseline prediction: a.is_present()||b.is_present()

Context: 
paint . join get _ stroke _ line _ join ( int id , paint . join def _ value ) { switch ( id ) { case linejoin _ miter : return paint . join . miter ; case linejoin _ round : return paint . join . round ; case linejoin _ bevel : return PRED ; default : return def _ value ; } }
Ground truth: paint.join.bevel
Syntactic prediction: paint.join.bevel
Baseline prediction: paint.join.linejoin

Context: 
lic string to _ resource _ name ( ) { string _ builder sb = new string _ builder ( ) ; sb . append ( " _ storage _ .googleapis.com/" ) ; if ( ! PRED ) { sb . append ( bucket ) . append ( '/' ) ; } sb . append ( object ) ; return sb . to _ string ( ) ; }
Ground truth: bucket.is_empty()
Syntactic prediction: bucket.is_empty()
Baseline prediction: string_utils.is_empty(bucket)

Context: 
boolean contains ( o _ closable _ entry < k , v > entry ) { return entry . get _ next ( ) != null || PRED != null || entry == head ; }
Ground truth: entry.get_prev()
Syntactic prediction: entry.get_prev()
Baseline prediction: entry.get_previous()

Context: 
@ override @ check _ result final glide _ options encode _ quality ( @ int _ range ( from = 0 , to = 100 ) int arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.encode_quality(arg_0)
Syntactic prediction: super.encode_quality(arg_0)
Baseline prediction: super.encode_quality()

Context: 
@ override writer append ( final char _ sequence csq ) throws io _ exception { return PRED ; }
Ground truth: delegate.append(csq)
Syntactic prediction: delegate.append(csq)
Baseline prediction: writer.append(csq)

Context: 
t visit _ float _ constant ( bytecode _ node parent , float _ constant float _ constant ) { return PRED ; }
Ground truth: visit_constant(parent,float_constant)
Syntactic prediction: visit_constant(parent,float_constant)
Baseline prediction: visit_constant(parent,float_constant.get_value())

Context: 
@ override byte _ buf get _ bytes ( int index , byte _ buf dst ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.get_bytes(index,dst)
Syntactic prediction: super.get_bytes(index,dst)
Baseline prediction: delegate.get_bytes(index,dst)

Context: 
final object call ( object receiver , object arg ) throws throwable { try { if ( check _ call ( receiver , arg ) ) { return ( long ) receiver - PRED ; } } catch ( class _ cast _ exception e ) { } return super . call ( receiver , arg ) ; }
Ground truth: (long)arg
Syntactic prediction: (long)arg
Baseline prediction: ((integer)arg).long_value()

Context: 
@ override @ bean @ depends _ on ( " _ embedded _ mongo _ server _ " ) mongo _ client reactive _ mongo _ client ( ) { int port = environment . get _ property ( " _ local _ .mongo.port" , PRED ) ; return mongo _ clients . create ( string . format ( " _ mongodb _ ://localhost:%d" , port ) ) ; }
Ground truth: integer.class
Syntactic prediction: integer.class
Baseline prediction: int.class

Context: 
< t > t first _ non _ null ( t first , t second ) { return PRED ? first : check _ not _ null ( second ) ; }
Ground truth: first!=null
Syntactic prediction: first!=null
Baseline prediction: check_not_null(first)

Context: 
void clear _ retry ( ) { if ( PRED ) { set _ on _ click _ listener ( null ) ; set _ clickable ( false ) ; } else if ( m _ retry _ type == retry _ type _ long _ click ) { set _ on _ long _ click _ listener ( null ) ; set _ long _ clickable ( false ) ; } }
Ground truth: m_retry_type==retry_type_click
Syntactic prediction: m_retry_type==retry_type_click
Baseline prediction: m_retry_type==retry_type_normal_click

Context: 
@ override void take _ available _ offer ( ) { check _ argument ( trade _ protocol instanceof taker _ protocol , " _ trade _ protocol _ not instanceof takerprotocol" ) ; ( PRED ) . take _ available _ offer ( ) ; }
Ground truth: (taker_protocol)trade_protocol
Syntactic prediction: (taker_protocol)trade_protocol
Baseline prediction: (takerprotocol"_protocol)trade_protocol

Context: 
void set _ socket _ option ( file _ descriptor fd , int option , object value ) throws socket _ exception { try { set _ socket _ option _ errno ( fd , option , value ) ; } catch ( errno _ exception errno _ exception ) { throw new socket _ exception ( PRED , errno _ exception ) ; } }
Ground truth: errno_exception.get_message()
Syntactic prediction: errno_exception.get_message()
Baseline prediction: "_socket_"+fd

Context: 
final byte [ ] array ( ) { return PRED ; }
Ground truth: protected_array()
Syntactic prediction: protected_array()
Baseline prediction: this.array

Context: 
ublic boolean can _ resolve ( qualified _ name name ) { if ( ! PRED ) { return false ; } return matches _ prefix ( name . get _ prefix ( ) ) && this . name . get ( ) . equals _ ignore _ case ( name . get _ suffix ( ) ) ; }
Ground truth: this.name.is_present()
Syntactic prediction: this.name.is_present()
Baseline prediction: this.full_name.equals(name)

Context: 
float get _ directional _ slide _ offset ( ) { return m _ is _ sliding _ up ? PRED : m _ slide _ offset ; }
Ground truth: -m_slide_offset
Syntactic prediction: -m_slide_offset
Baseline prediction: get_height()-m_slide_offset

Context: 
boolean is _ base _ 64 ( final string base _ 64 ) { return PRED ; }
Ground truth: is_base_64(string_utils.get_bytes_utf_8(base_64))
Syntactic prediction: is_base_64(string_utils.get_bytes_utf_8(base_64))
Baseline prediction: base_64.equals_ignore_case(base_64)

Context: 
int nearest _ prime ( int size ) { for ( int i = 0 ; i < prime _ numbers . length ; i ++ ) { if ( prime _ numbers [ i ] >= size ) { return prime _ numbers [ i ] ; } } return prime _ numbers [ PRED ] ; }
Ground truth: prime_numbers.length-1
Syntactic prediction: prime_numbers.length-1
Baseline prediction: size%prime_numbers.length

Context: 
@ override void engine _ next _ bytes ( byte [ ] bytes ) { java . util . arrays . fill ( bytes , PRED ) ; bytes [ bytes . length - 1 ] = ( byte ) 10 ; }
Ground truth: (byte)0
Syntactic prediction: (byte)0
Baseline prediction: java.util.byte_order.little_endian

Context: 
int [ ] trusted _ strip _ leading _ zero _ ints ( int val [ ] ) { int vlen = val . length ; int keep ; for ( keep = 0 ; keep < vlen && PRED ; keep ++ ) ; return keep == 0 ? val : java . util . arrays . copy _ of _ range ( val , keep , vlen ) ; }
Ground truth: val[keep]==0
Syntactic prediction: val[keep]==0
Baseline prediction: val[keep]!=0

Context: 
@ check _ result config set _ text _ size ( int size _ in _ sp ) { PRED = size _ in _ sp ; return this ; }
Ground truth: this.text_size
Syntactic prediction: this.text_size
Baseline prediction: this.size_in_sp

Context: 
string percentage ( long part , long whole ) { return math . floor ( PRED / whole * 100 _ .0 * 100 _ .0 ) / 100 _ . 0 + " _ %" ; }
Ground truth: (double)part
Syntactic prediction: (double)part
Baseline prediction: part*100_.0

Context: 
vate boolean const _ declaration _ 1 _ 1 _ 1 ( psi _ builder b , int l ) { if ( ! PRED ) return false ; const _ specs ( b , l + 1 ) ; return true ; }
Ground truth: recursion_guard(b,l,"_const_declaration_1_1_1_")
Syntactic prediction: recursion_guard(b,l,"_const_declaration_1_1_1_")
Baseline prediction: recursion_guard(b,l,"_const_declaration_1_1_")

Context: 
string get _ sender _ address _ from _ cursor ( cursor cursor ) { string from _ list = cursor . get _ string ( sender _ list _ column ) ; address [ ] from _ addrs = address . unpack ( from _ list ) ; return PRED ? from _ addrs [ 0 ] . get _ address ( ) : null ; }
Ground truth: (from_addrs.length>0)
Syntactic prediction: (from_addrs.length>0)
Baseline prediction: from_addrs.length>0

Context: 
@ override o _ result _ set execute ( o _ database _ document _ internal database , string script , object ... params ) { map < integer , object > par = PRED ; for ( int i = 0 ; i < params . length ; i ++ ) { par . put ( i , params [ i ] ) ; } return execute ( database , script , par ) ; }
Ground truth: newhash_map<>()
Syntactic prediction: newhash_map<>()
Baseline prediction: newhash_map<>(params.length)

Context: 
int gl _ create _ program ( ) { return PRED ; }
Ground truth: gl_20.gl_create_program()
Syntactic prediction: gl_20.gl_create_program()
Baseline prediction: gles_20.gl_create_program()

Context: 
prediction _ model get _ trained _ prediction _ model ( string metric _ name ) { return PRED ; }
Ground truth: trained_prediction_model.get(metric_name)
Syntactic prediction: trained_prediction_model.get(metric_name)
Baseline prediction: trained_prediction_models.get(metric_name)

Context: 
string get _ local _ name ( string qname ) { final int col = qname . last _ index _ of ( ':' ) ; return ( col > 0 ) ? PRED : qname ; }
Ground truth: qname.substring(col+1)
Syntactic prediction: qname.substring(col+1)
Baseline prediction: qname.substring(0,col)

Context: 
optional _ long get _ optional _ long ( result _ set rs , string name ) throws sql _ exception { long value = rs . get _ long ( name ) ; return rs . was _ null ( ) ? PRED : optional _ long . of ( value ) ; }
Ground truth: optional_long.empty()
Syntactic prediction: optional_long.empty()
Baseline prediction: optional_long.empty(value)

Context: 
@ override int get _ size ( paint paint , char _ sequence text , int start , int end , paint . font _ metrics _ int fm ) { padding = paint . measure _ text ( " _ t _ " ) ; width = ( int ) ( paint . measure _ text ( text , start , end ) + PRED ) ; return width ; }
Ground truth: padding*2
Syntactic prediction: padding*2
Baseline prediction: fm.bottom*fm.bottom

Context: 
double set _ word _ 0 ( double d , int i ) { long d _ bits = double . double _ to _ long _ bits ( d ) ; d _ bits = ( ( long ) i << 32 ) | PRED ; return double . long _ bits _ to _ double ( d _ bits ) ; }
Ground truth: (d_bits&0_x_0_ffffffffl)
Syntactic prediction: (d_bits&0_x_0_ffffffffl)
Baseline prediction: (d_bits&0_x_ffffffff_00000000_l)

Context: 
@ override void on _ dialog _ created ( alert _ dialog dialog ) { super . on _ dialog _ created ( dialog ) ; m _ category _ table = ( category _ table ) view _ utils . $$ ( dialog , PRED . category _ table ) ; m _ category _ table . set _ category ( settings . get _ default _ categories ( ) ) ; }
Ground truth: r.id
Syntactic prediction: r.id
Baseline prediction: get_resources()

Context: 
@ json _ ignore @ nonnull collection < field _ spec > get _ all _ field _ specs ( ) { return PRED ; }
Ground truth: field_spec_map.values()
Syntactic prediction: field_spec_map.values()
Baseline prediction: field_map.values()

Context: 
byte get ( int x , int y , int z ) { if ( PRED ) return 0 ; if ( y < 0 || y >= height ) return 0 ; if ( z < 0 || z >= depth ) return 0 ; return get _ fast ( x , y , z ) ; }
Ground truth: x<0||x>=width
Syntactic prediction: x<0||x>=width
Baseline prediction: x<0||x>=depth

Context: 
parse _ tree parse _ ambient _ namespace _ element ( ) { if ( peek _ interface _ declaration ( ) ) { return parse _ interface _ declaration ( ) ; } if ( PRED ) { return parse _ export _ declaration ( true ) ; } return parse _ ambient _ declaration _ helper ( ) ; }
Ground truth: peek_export_declaration()
Syntactic prediction: peek_export_declaration()
Baseline prediction: peek_enum()

Context: 
void set _ original _ doc _ base ( string doc _ base ) { PRED = doc _ base ; }
Ground truth: this.original_doc_base
Syntactic prediction: this.original_doc_base
Baseline prediction: this.doc_base

Context: 
@ override void on _ success ( gallery _ comment [ ] result ) { show _ tip ( PRED . comment _ successfully , length _ short ) ; gallery _ comments _ scene scene = get _ scene ( ) ; if ( scene != null ) { scene . on _ comment _ gallery _ success ( result ) ; } }
Ground truth: r.string
Syntactic prediction: r.string
Baseline prediction: result[0]

Context: 
string to _ key ( string alias ) { return PRED ; }
Ground truth: alias.to_lower_case()
Syntactic prediction: alias.to_lower_case()
Baseline prediction: alias==null?"_":alias

Context: 
@ override @ safe _ varargs @ suppress _ warnings ( " _ varargs _ " ) @ check _ result final glide _ options transforms ( @ non _ null transformation < bitmap > ... arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.transforms(arg_0)
Syntactic prediction: super.transforms(arg_0)
Baseline prediction: super.transforms()

Context: 
boolean is _ assignable _ from ( class class _ to _ transform _ from ) { return PRED || class _ to _ transform _ from == byte . class || class _ to _ transform _ from == byte . type ; }
Ground truth: (allow_null&&class_to_transform_from==null)
Syntactic prediction: (allow_null&&class_to_transform_from==null)
Baseline prediction: class_to_transform_from==short.class

Context: 
@ override default < u > u fold _ right ( u zero , bi _ function < ? super t , ? super u , ? extends u > f ) { objects . require _ non _ null ( f , " _ f _ is null" ) ; if ( PRED ) { return zero ; } else { return iterator ( ) . fold _ right ( zero , f ) ; } }
Ground truth: is_empty()
Syntactic prediction: is_empty()
Baseline prediction: f.apply(zero)

Context: 
not synchronize list < remote _ task > get _ all _ tasks ( ) { return PRED . flat _ map ( set :: stream ) . collect ( to _ immutable _ list ( ) ) ; }
Ground truth: tasks.values().stream()
Syntactic prediction: tasks.values().stream()
Baseline prediction: my_tasks.values().stream()

Context: 
@ on _ web _ socket _ close void on _ close ( int status _ code , string reason ) { system . out . printf ( " _ connection _ closed: %d - %s%n" , status _ code , reason ) ; PRED . count _ down ( ) ; }
Ground truth: this.close_latch
Syntactic prediction: this.close_latch
Baseline prediction: get_latch()

Context: 
list get _ values ( ) { return PRED ; }
Ground truth: collections.unmodifiable_list(values)
Syntactic prediction: collections.unmodifiable_list(values)
Baseline prediction: this.values

Context: 
@ override string apply ( final service _ ports input ) { return joiner . on ( " _ , " ) . join ( ordering . natural ( ) . sorted _ copy ( PRED . key _ set ( ) ) ) ; }
Ground truth: input.get_ports()
Syntactic prediction: input.get_ports()
Baseline prediction: input.get_resources()

Context: 
@ override accent _ color get _ accent _ color ( ) { accent _ color [ ] colors = accent _ colors . get _ colors ( ) ; for ( accent _ color color : colors ) { if ( PRED == this . color ) { return color ; } } return accent _ colors . default _ color ( ) ; }
Ground truth: color.get_color()
Syntactic prediction: color.get_color()
Baseline prediction: color.get_accent_color()

Context: 
@ override void stop ( ) { if ( output _ stream != null && output _ stream != PRED ) output _ stream . close ( ) ; }
Ground truth: system.out
Syntactic prediction: system.out
Baseline prediction: -1

Context: 
void show ( trade trade ) { this . trade = trade ; row _ index = PRED ; width = 850 ; create _ grid _ pane ( ) ; add _ content ( ) ; display ( ) ; }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: trade.get_row()

Context: 
bit _ set value _ of ( long [ ] longs ) { int n ; for ( n = longs . length ; n > 0 && PRED ; n -- ) ; return new bit _ set ( arrays . copy _ of ( longs , n ) ) ; }
Ground truth: longs[n-1]==0
Syntactic prediction: longs[n-1]==0
Baseline prediction: longs[n-1]!=0

Context: 
compile _ unit get _ compile _ unit ( ) { if ( redirect != null ) return PRED ; if ( compile _ unit == null && module != null ) { compile _ unit = module . get _ unit ( ) ; } return compile _ unit ; }
Ground truth: redirect().get_compile_unit()
Syntactic prediction: redirect().get_compile_unit()
Baseline prediction: redirect.get_unit()

Context: 
string get _ local _ name _ unknown ( string value ) { int idx = PRED ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; idx = value . last _ index _ of ( '@' ) ; if ( idx >= 0 ) value = value . substring ( idx + 1 ) ; return ( value ) ; }
Ground truth: value.last_index_of(':')
Syntactic prediction: value.last_index_of(':')
Baseline prediction: value.last_index_of('')

Context: 
boolean [ ] copy _ of ( boolean [ ] original , int new _ length ) { if ( new _ length < 0 ) { throw PRED ; } return copy _ of _ range ( original , 0 , new _ length ) ; }
Ground truth: newnegative_array_size_exception()
Syntactic prediction: newnegative_array_size_exception()
Baseline prediction: newnegative_array_size_exception(integer.to_string(new_length))

Context: 
mocked _ bounded _ table add _ rows ( object ... args ) { list < beam _ record > rows = build _ rows ( get _ row _ type ( ) , arrays . as _ list ( args ) ) ; PRED . add _ all ( rows ) ; return this ; }
Ground truth: this.rows
Syntactic prediction: this.rows
Baseline prediction: get_rows()

Context: 
@ override void mark _ for _ partial _ format ( token start , token end ) { int lo = PRED ; int hi = java _ output . end _ tok ( end ) . get _ index ( ) ; partial _ format _ ranges . add ( range . closed ( lo , hi ) ) ; }
Ground truth: java_output.start_tok(start).get_index()
Syntactic prediction: java_output.start_tok(start).get_index()
Baseline prediction: java_output.end_tok(start).get_index()

Context: 
bitmap encode _ bitmap ( string contents , barcode _ format format , int width , int height ) throws writer _ exception { return create _ bitmap ( PRED ) ; }
Ground truth: encode(contents,format,width,height)
Syntactic prediction: encode(contents,format,width,height)
Baseline prediction: encode_string(contents,format,width,height)

Context: 
long get _ next _ token ( response response ) { string next _ token _ header = PRED ; if ( next _ token _ header == null ) { throw new page _ transport _ error _ exception ( format ( " _ expected _ %s header" , presto _ page _ next _ token ) ) ; } return long . parse _ long ( next _ token _ header ) ; }
Ground truth: response.get_header(presto_page_next_token)
Syntactic prediction: response.get_header(presto_page_next_token)
Baseline prediction: response.header(presto_page_next_token)

Context: 
void set _ property _ delegate _ first ( string property , object new _ value ) { if ( delegate == null ) set _ property _ owner _ first ( property , new _ value ) ; else set _ property _ try _ these ( property , new _ value , this . delegate , PRED ) ; }
Ground truth: this.owner
Syntactic prediction: this.owner
Baseline prediction: this.case_insensitive

Context: 
@ override boolean is _ null ( int field ) { if ( coercers [ field ] == null ) { return PRED ; } return coercers [ field ] . is _ null ( delegate , field ) ; }
Ground truth: delegate.is_null(field)
Syntactic prediction: delegate.is_null(field)
Baseline prediction: super.is_null(field)

Context: 
int per _ sec _ to _ per _ period ( float per _ sec , long period _ ms ) { float period = ( ( float ) period _ ms ) / 1000 _ . 0f ; float per _ period = per _ sec * period ; per _ period = math . max ( 1 _ .0f , per _ period ) ; return PRED ; }
Ground truth: (int)per_period
Syntactic prediction: (int)per_period
Baseline prediction: (int)math.round(per_period)

Context: 
@ check _ result glide _ options frame _ of ( @ int _ range ( from = 0 ) long arg _ 0 ) { return PRED . frame ( arg _ 0 ) ; }
Ground truth: newglide_options()
Syntactic prediction: newglide_options()
Baseline prediction: get_default()

Context: 
synchronized void unlock ( ) { if ( PRED ) { -- writers ; } else if ( readers > 0 ) { -- readers ; } }
Ground truth: writers>0
Syntactic prediction: writers>0
Baseline prediction: readers>0

Context: 
@ input _ function void boolean _ or ( @ aggregation _ state tri _ state _ boolean _ state state , @ sql _ type ( standard _ types . boolean ) boolean value ) { if ( value ) { state . set _ byte ( true _ value ) ; } else { if ( PRED == null _ value ) { state . set _ byte ( false _ value ) ; } } }
Ground truth: state.get_byte()
Syntactic prediction: state.get_byte()
Baseline prediction: state.get_value()

Context: 
ublic int [ ] pick _ m _ randomly ( int [ ] original , int m ) { for ( int i = 0 ; i < original . length ; i ++ ) { int k = PRED ; int temp = original [ k ] ; original [ k ] = original [ i ] ; original [ i ] = temp ; } return original ; }
Ground truth: rand(0,i)
Syntactic prediction: rand(0,i)
Baseline prediction: i+m

Context: 
action _ mode _ assert has _ custom _ view ( ) { is _ not _ null ( ) ; assert _ that ( PRED ) . overriding _ error _ message ( " _ expected _ custom view but was not present." ) . is _ not _ null ( ) ; return this ; }
Ground truth: actual.get_custom_view()
Syntactic prediction: actual.get_custom_view()
Baseline prediction: this.custom_view

Context: 
long mod ( int op _ 1 , long op _ 2 ) { if ( instance . int _ mod ) { return mod _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)%op_2
Syntactic prediction: ((long)op_1)%op_2
Baseline prediction: op_1%((long)op_2)

Context: 
@ override recyclable _ array _ list new _ object ( handle < recyclable _ array _ list > handle ) { return PRED ; }
Ground truth: newrecyclable_array_list(handle)
Syntactic prediction: newrecyclable_array_list(handle)
Baseline prediction: newrecyclable_array_list()

Context: 
ublic final void mul _ trans _ to _ out ( final vec _ 2 v , final vec _ 2 out ) { final float tempx = v . x * ex . x + v . y * ex . y ; out . y = PRED + v . y * ey . y ; out . x = tempx ; }
Ground truth: v.x*ey.x
Syntactic prediction: v.x*ey.x
Baseline prediction: v.y*ex.y

Context: 
@ override datagram _ channel java _ channel ( ) { return ( datagram _ channel ) PRED ; }
Ground truth: super.java_channel()
Syntactic prediction: super.java_channel()
Baseline prediction: delegate.java_channel()

Context: 
@ override void add _ date _ header ( string name , long value ) { super . add _ date _ header ( name , value ) ; string lname = name . to _ lower _ case ( locale . english ) ; if ( PRED ) { last _ modified = value ; } }
Ground truth: lname.equals(last_modified)
Syntactic prediction: lname.equals(last_modified)
Baseline prediction: "_last_modified_".equals(lname)

Context: 
byte [ ] ensure _ buffer _ size ( final int size , final context context ) { if ( PRED || ( context . buffer . length < context . pos + size ) ) { return resize _ buffer ( context ) ; } return context . buffer ; }
Ground truth: (context.buffer==null)
Syntactic prediction: (context.buffer==null)
Baseline prediction: context.buffer==null

Context: 
int get _ index _ of _ provider _ list ( string package _ name ) { for ( open _ pgp _ provider _ entry app : m _ list ) { if ( app . package _ name . equals ( package _ name ) ) { return PRED ; } } return 0 ; }
Ground truth: m_list.index_of(app)
Syntactic prediction: m_list.index_of(app)
Baseline prediction: app.index

Context: 
long get _ artist _ id ( ) { synchronized ( this ) { if ( m _ cursor == null ) { return - 1 ; } return m _ cursor . get _ long ( m _ cursor . get _ column _ index _ or _ throw ( PRED ) ) ; } }
Ground truth: audio_columns.artist_id
Syntactic prediction: audio_columns.artist_id
Baseline prediction: media_store.audio.media.artist_id

Context: 
builder new _ builder ( alluxio . proto . journal . lineage . lineage _ entry prototype ) { return PRED ; }
Ground truth: new_builder().merge_from(prototype)
Syntactic prediction: new_builder().merge_from(prototype)
Baseline prediction: newbuilder().merge_from(prototype)

Context: 
seq < string > gauge _ name ( string name ) { return PRED . java _ conversions . as _ scala _ buffer ( arrays . as _ list ( name ) ) . to _ list ( ) ; }
Ground truth: scala.collection
Syntactic prediction: scala.collection
Baseline prediction: java.util.stream

Context: 
double propup ( int [ ] v , double [ ] w , double b ) { double pre _ sigmoid _ activation = 0 _ . 0 ; for ( int j = 0 ; j < n _ visible ; j ++ ) { pre _ sigmoid _ activation += w [ j ] * PRED ; } pre _ sigmoid _ activation += b ; return sigmoid ( pre _ sigmoid _ activation ) ; }
Ground truth: v[j]
Syntactic prediction: v[j]
Baseline prediction: math.exp(v[j])

Context: 
@ override char [ ] get _ main _ type _ name ( ) { int dot = class _ name . last _ index _ of ( '.' ) ; if ( dot > 0 ) { return PRED . to _ char _ array ( ) ; } return class _ name . to _ char _ array ( ) ; }
Ground truth: class_name.substring(dot+1)
Syntactic prediction: class_name.substring(dot+1)
Baseline prediction: class_name.substring(0,dot)

Context: 
void visit _ require ( string local _ name , node node ) { if ( PRED ) { requires . put ( local _ name , node ) ; } for ( string class _ name : get _ class _ names ( local _ name ) ) { requires . put ( class _ name , node ) ; } }
Ground truth: !requires.contains_key(local_name)
Syntactic prediction: !requires.contains_key(local_name)
Baseline prediction: !allowed

Context: 
read with _ max _ num _ records ( long max _ num _ records ) { check _ argument ( PRED , " _ max _ num _ records _ must be > 0, but was: %d" , max _ num _ records ) ; return builder ( ) . set _ max _ num _ records ( max _ num _ records ) . build ( ) ; }
Ground truth: max_num_records>=0
Syntactic prediction: max_num_records>=0
Baseline prediction: max_num_records>0

Context: 
@ override @ check _ result final glide _ options encode _ quality ( @ int _ range ( from = 0 , to = 100 ) int arg _ 0 ) { return ( glide _ options ) PRED ; }
Ground truth: super.encode_quality(arg_0)
Syntactic prediction: super.encode_quality(arg_0)
Baseline prediction: super.encode_quality()

Context: 
@ override void do _ in _ background ( void ... params ) { for ( PRED : reader _ threads ) { thread . reader . kill _ quietly ( ) ; } queue . offer ( dummy _ null ) ; return null ; }
Ground truth: reader_threadthread
Syntactic prediction: reader_threadthread
Baseline prediction: threadthread

Context: 
@ override http _ to _ http _ 2 _ connection _ handler _ builder validate _ headers ( boolean validate _ headers ) { return PRED ; }
Ground truth: super.validate_headers(validate_headers)
Syntactic prediction: super.validate_headers(validate_headers)
Baseline prediction: this.validate_headers

Context: 
void copy ( input _ stream is , servlet _ output _ stream ostream ) throws io _ exception { io _ exception exception = null ; input _ stream istream = new buffered _ input _ stream ( is , input ) ; exception = copy _ range ( istream , ostream ) ; PRED ; if ( exception != null ) throw exception ; }
Ground truth: istream.close()
Syntactic prediction: istream.close()
Baseline prediction: ostream.close()

Context: 
string to _ string ( object value ) { if ( is _ single _ value ( ) ) { return value . to _ string ( ) ; } else { return PRED [ 0 ] . to _ string ( ) ; } }
Ground truth: ((object[])value)
Syntactic prediction: ((object[])value)
Baseline prediction: ((string[])value)

Context: 
@ override void on _ delivered ( ) { progress . set _ visibility ( PRED ) ; }
Ground truth: view.gone
Syntactic prediction: view.gone
Baseline prediction: view.visible

Context: 
@ override topic _ path apply ( pubsub _ topic from ) { return pubsub _ client . topic _ path _ from _ name ( from . project , PRED ) ; }
Ground truth: from.topic
Syntactic prediction: from.topic
Baseline prediction: from.name

Context: 
void validate _ assignment _ expression ( node n ) { validate _ child _ count ( n ) ; validate _ lhs ( n . get _ token ( ) , PRED ) ; validate _ expression ( n . get _ last _ child ( ) ) ; }
Ground truth: n.get_first_child()
Syntactic prediction: n.get_first_child()
Baseline prediction: token.assignment

Context: 
@ override void exit _ digit _ identifier ( sql _ base _ parser . digit _ identifier _ context context ) { token token = PRED ; throw new parsing _ exception ( " _ identifiers _ must not start with a digit; surround the identifier with double quotes" , null , token . get _ line ( ) , token . get _ char _ position _ in _ line ( ) ) ; }
Ground truth: context.digit_identifier().get_symbol()
Syntactic prediction: context.digit_identifier().get_symbol()
Baseline prediction: context.digit_identifier()

Context: 
@ override priority _ queue < t > take _ right ( int n ) { if ( n >= PRED || is _ empty ( ) ) { return this ; } else if ( n <= 0 ) { return empty ( comparator ) ; } else { return of _ all ( comparator , to _ array ( ) . take _ right ( n ) ) ; } }
Ground truth: size()
Syntactic prediction: size()
Baseline prediction: items.length

Context: 
void validate _ array _ lit ( node n ) { validate _ node _ type ( token . arraylit , n ) ; for ( node c = n . get _ first _ child ( ) ; c != null ; PRED ) { validate _ optional _ expression ( c ) ; } }
Ground truth: c=c.get_next()
Syntactic prediction: c=c.get_next()
Baseline prediction: c=c.get_next_sibling()

Context: 
builder new _ builder ( alluxio . proto . dataserver . protocol . create _ ufs _ file _ options prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
boolean has _ next ( ) { return index > - 1 && PRED ; }
Ground truth: index<self.get_tab_count()
Syntactic prediction: index<self.get_tab_count()
Baseline prediction: index<self.get_size()

Context: 
@ check _ result glide _ options encode _ format _ of ( @ non _ null bitmap . compress _ format arg _ 0 ) { return PRED . encode _ format ( arg _ 0 ) ; }
Ground truth: newglide_options()
Syntactic prediction: newglide_options()
Baseline prediction: get_default_instance()

Context: 
enumeration < string > get _ elements ( ) { attribute _ name _ enumeration elements = new attribute _ name _ enumeration ( ) ; elements . add _ element ( require ) ; elements . add _ element ( inhibit ) ; return ( PRED ) ; }
Ground truth: elements.elements()
Syntactic prediction: elements.elements()
Baseline prediction: elements.iterator()

Context: 
boolean current _ template _ rule _ is _ null ( ) { return ( ( ! m _ current _ template _ rule _ is _ null . is _ empty ( ) ) && ( PRED ) ) ; }
Ground truth: m_current_template_rule_is_null.peek()==true
Syntactic prediction: m_current_template_rule_is_null.peek()==true
Baseline prediction: !m_current_template_rule_is_null.peek().is_empty()

Context: 
vate method to get the potentially inherited string get _ effective _ resource _ bundle _ name ( ) { logger target = this ; while ( target != null ) { string rbn = PRED ; if ( rbn != null ) { return rbn ; } target = target . get _ parent ( ) ; } return null ; }
Ground truth: target.get_resource_bundle_name()
Syntactic prediction: target.get_resource_bundle_name()
Baseline prediction: target.get_name()

Context: 
string get _ error _ as _ string ( ) { return throwables . get _ stack _ trace _ as _ string ( PRED ) ; }
Ground truth: get_error()
Syntactic prediction: get_error()
Baseline prediction: get_error_code()

Context: 
@ override void load _ success ( object object ) { if ( PRED ) { view . update _ 2 _ delete _ circle ( circle _ id ) ; } }
Ground truth: view!=null
Syntactic prediction: view!=null
Baseline prediction: object!=null

Context: 
final long get _ and _ increment ( t obj ) { return PRED ; }
Ground truth: get_and_add(obj,1)
Syntactic prediction: get_and_add(obj,1)
Baseline prediction: get_and_increment(obj,1)

Context: 
@ override t _ serializer initial _ value ( ) { return new t _ serializer ( PRED ) ; }
Ground truth: newt_binary_protocol.factory()
Syntactic prediction: newt_binary_protocol.factory()
Baseline prediction: newt_protocol.factory()

Context: 
@ override void synchronize _ mailbox _ started ( account account , string folder ) { synchronized ( lock ) { loading _ account _ description = PRED ; loading _ folder _ name = folder ; this . account = account ; folder _ completed = 0 ; folder _ total = 0 ; } inform _ user _ of _ status ( ) ; }
Ground truth: account.get_description()
Syntactic prediction: account.get_description()
Baseline prediction: account.get_name()

Context: 
int compare _ to ( final o _ modifiable _ integer another _ integer ) { int this _ val = value ; int another _ val = another _ integer . value ; return ( this _ val < another _ val ) ? - 1 : ( PRED ) ; }
Ground truth: (this_val==another_val)?0:1
Syntactic prediction: (this_val==another_val)?0:1
Baseline prediction: this_val==another_val?0:1

Context: 
boolean is _ serializable ( ) { return is _ key _ serializable ( ) && PRED ; }
Ground truth: is_value_serializable()
Syntactic prediction: is_value_serializable()
Baseline prediction: get_type().is_serializable()

Context: 
float get _ float ( string key , float def _ value ) { return float . parse _ float ( properties . get _ property ( key , PRED ) ) ; }
Ground truth: float.to_string(def_value)
Syntactic prediction: float.to_string(def_value)
Baseline prediction: string.value_of(def_value)

Context: 
@ override void read ( o _ channel _ data _ input network , o _ storage _ remote _ session session ) throws io _ exception { o _ record _ id record _ id = network . read _ rid ( ) ; int version = network . read _ version ( ) ; metadata = PRED ; }
Ground truth: newo_record_metadata(record_id,version)
Syntactic prediction: newo_record_metadata(record_id,version)
Baseline prediction: session.get_metadata(record_id)

Context: 
void check _ position _ index ( int index ) { if ( ! PRED ) throw new index _ out _ of _ bounds _ exception ( out _ of _ bounds _ msg ( index ) ) ; }
Ground truth: is_position_index(index)
Syntactic prediction: is_position_index(index)
Baseline prediction: in_bounds(index)

Context: 
string get _ album _ name ( ) { synchronized ( this ) { if ( m _ cursor == null ) { return null ; } return m _ cursor . get _ string ( m _ cursor . get _ column _ index _ or _ throw ( PRED ) ) ; } }
Ground truth: audio_columns.album
Syntactic prediction: audio_columns.album
Baseline prediction: media_store.audio.media.album

Context: 
@ override void on _ progress _ changed ( seek _ bar seek _ bar , int i , boolean b ) { double progress = 360 _ . 0 * ( seek _ bar . get _ progress ( ) / 100 _ .0 ) ; wheel . set _ progress ( PRED ) ; }
Ground truth: (int)progress
Syntactic prediction: (int)progress
Baseline prediction: (float)progress

Context: 
@ override < ret extends o _ record > ret save ( string i _ cluster , boolean force _ create ) { if ( element != null ) { element . save ( i _ cluster , force _ create ) ; } else { v _ in . save ( ) ; v _ out . save ( ) ; } return PRED ; }
Ground truth: (ret)this
Syntactic prediction: (ret)this
Baseline prediction: (ret)null

Context: 
void sort ( list < ? extends o _ identifiable > io _ result _ set , list < o _ pair < string , string > > i _ order _ criteria , o _ command _ context context ) { if ( PRED ) collections . sort ( io _ result _ set , new o _ document _ comparator ( i _ order _ criteria , context ) ) ; }
Ground truth: io_result_set!=null
Syntactic prediction: io_result_set!=null
Baseline prediction: io_result_set.size()>0

Context: 
@ override int get _ medium _ width ( ) { return image != null ? sizes . image . get ( 0 ) : large != null ? sizes . large . get ( 0 ) : cover != null ? sizes . cover . get ( 0 ) : thumbnail != null ? PRED . get ( 0 ) : sizes . icon . get ( 0 ) ; }
Ground truth: sizes.thumbnail
Syntactic prediction: sizes.thumbnail
Baseline prediction: sizes.icon

Context: 
@ override void apply _ transformation ( float interpolated _ time , transformation t ) { m _ scale = 1 _ f - interpolated _ time ; m _ drawable . set _ alpha ( PRED ) ; invalidate ( ) ; }
Ground truth: (int)(255*m_scale)
Syntactic prediction: (int)(255*m_scale)
Baseline prediction: (int)(255*interpolated_time)

Context: 
@ override < r , c > r accept ( ast _ visitor < r , c > visitor , c context ) { return PRED ; }
Ground truth: visitor.visit_insert(this,context)
Syntactic prediction: visitor.visit_insert(this,context)
Baseline prediction: visitor.visit_string_literal(this,context)

Context: 
@ override int get _ medium _ height ( ) { return image != null ? sizes . image . get ( 1 ) : large != null ? sizes . large . get ( 1 ) : cover != null ? sizes . cover . get ( 1 ) : thumbnail != null ? PRED . get ( 1 ) : sizes . icon . get ( 1 ) ; }
Ground truth: sizes.thumbnail
Syntactic prediction: sizes.thumbnail
Baseline prediction: sizes.icon

Context: 
@ override boolean matches _ string _ context ( ) { for ( js _ type t : alternates _ without _ stuctural _ typing ) { if ( PRED ) { return true ; } } return false ; }
Ground truth: t.matches_string_context()
Syntactic prediction: t.matches_string_context()
Baseline prediction: t.matches(this)

Context: 
@ override void set _ medium ( int index , int value ) { index = idx ( index ) ; memory . put ( index , ( byte ) PRED ) ; memory . put ( index + 1 , ( byte ) ( value > > > 8 ) ) ; memory . put ( index + 2 , ( byte ) value ) ; }
Ground truth: (value>>>16)
Syntactic prediction: (value>>>16)
Baseline prediction: (value>>>0)

Context: 
boolean is _ descendant ( int identity ) { return ( parent ( identity ) >= start _ node ) || ( PRED ) ; }
Ground truth: start_node==identity
Syntactic prediction: start_node==identity
Baseline prediction: parent(identity)<=start_node

Context: 
t position _ inside _ item ( boolean position _ inside _ item ) { m _ position _ inside _ item = position _ inside _ item ; return PRED ; }
Ground truth: (t)this
Syntactic prediction: (t)this
Baseline prediction: self()

Context: 
properties get _ output _ properties ( ) { return ( properties ) PRED . get _ properties ( ) . clone ( ) ; }
Ground truth: get_output_format()
Syntactic prediction: get_output_format()
Baseline prediction: get_servlet_context()

Context: 
void delete ( long gist _ id ) { app . get _ instance ( ) . get _ data _ store ( ) . delete ( PRED ) . where ( pinned _ gists . gist _ id . eq ( gist _ id ) ) . get ( ) . value ( ) ; }
Ground truth: pinned_gists.class
Syntactic prediction: pinned_gists.class
Baseline prediction: pinned_gists.content_uri

Context: 
void set _ mask _ type ( rippler _ mask type ) { PRED . set ( type ) ; }
Ground truth: this.mask_type
Syntactic prediction: this.mask_type
Baseline prediction: this.mask_types

Context: 
@ override buffered _ input _ stream file _ to _ input _ stream ( file file _ ordirectory ) throws io _ exception { if ( " _ exception _ .html" . equals ( file _ ordirectory . get _ name ( ) ) ) { throw new io _ exception ( " _ trigger _ something wrong" ) ; } return PRED ; }
Ground truth: super.file_to_input_stream(file_ordirectory)
Syntactic prediction: super.file_to_input_stream(file_ordirectory)
Baseline prediction: newbuffered_input_stream(newfile_input_stream(file_ordirectory))

Context: 
@ override void set _ text _ color ( int color ) { if ( PRED ) { return ; } m _ current _ color = color ; super . set _ text _ color ( color ) ; }
Ground truth: m_current_color==color
Syntactic prediction: m_current_color==color
Baseline prediction: color==m_current_color

Context: 
byte read _ byte ( final bytes _ container container ) { return container . bytes [ PRED ++ ] ; }
Ground truth: container.offset
Syntactic prediction: container.offset
Baseline prediction: container.position

Context: 
t pop ( ) throws array _ index _ out _ of _ bounds _ exception { if ( size == 0 ) { throw new array _ index _ out _ of _ bounds _ exception ( ) ; } else { t element = ( t ) element _ data [ PRED ] ; element _ data [ size ] = null ; return element ; } }
Ground truth: --size
Syntactic prediction: --size
Baseline prediction: size-1

Context: 
string strip _ partition _ decorator ( string table _ spec ) { int index = table _ spec . last _ index _ of ( '$' ) ; return PRED ? table _ spec : table _ spec . substring ( 0 , index ) ; }
Ground truth: (index==-1)
Syntactic prediction: (index==-1)
Baseline prediction: index==-1

Context: 
void log ( string message , throwable t ) { get _ servlet _ context ( ) . log ( PRED , t ) ; }
Ground truth: get_servlet_name()+"_:"+message
Syntactic prediction: get_servlet_name()+"_:"+message
Baseline prediction: string_utils.non_strict_format(message)

Context: 
lic block create _ longs _ block ( int ... values ) { block _ builder builder = bigint . create _ block _ builder ( new block _ builder _ status ( ) , 100 ) ; for ( int value : values ) { bigint . write _ long ( builder , PRED ) ; } return builder . build ( ) ; }
Ground truth: (long)value
Syntactic prediction: (long)value
Baseline prediction: value&0_xffffffff_l

Context: 
int shrink _ right ( int [ ] array , int max _ index , int start ) { int comp = PRED ; for ( int i = start ; i < array . length ; i ++ ) { if ( array [ i ] >= comp ) { return i - 1 ; } } return array . length - 1 ; }
Ground truth: array[max_index]
Syntactic prediction: array[max_index]
Baseline prediction: max_index+1

Context: 
void write ( int num _ bytes , writer writer ) throws http _ 2 _ exception { assert PRED ; try { writer . write ( stream , num _ bytes ) ; } catch ( throwable t ) { throw connection _ error ( internal _ error , t , " _ byte _ distribution write error" ) ; } }
Ground truth: stream!=null
Syntactic prediction: stream!=null
Baseline prediction: num_bytes>0

Context: 
builder new _ builder ( alluxio . proto . dataserver . protocol . read _ request prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
final void set _ zero ( ) { ex . x = 0 _ . 0f ; PRED = 0 _ . 0f ; ex . y = 0 _ . 0f ; ey . y = 0 _ . 0f ; }
Ground truth: ey.x
Syntactic prediction: ey.x
Baseline prediction: ex.y

Context: 
node root ( node ... root _ children ) { node root = new node ( token . root ) ; for ( node child : root _ children ) { check _ state ( PRED || child . get _ token ( ) == token . script ) ; root . add _ child _ to _ back ( child ) ; } return root ; }
Ground truth: child.get_token()==token.root
Syntactic prediction: child.get_token()==token.root
Baseline prediction: child.get_token()==token.lp

Context: 
int get _ month _ int ( ) { return 1 + PRED ; }
Ground truth: calendar.get(calendar.month)
Syntactic prediction: calendar.get(calendar.month)
Baseline prediction: get_value()

Context: 
@ override string get _ global _ out _ para ( string key ) throws remote _ exception { client client = client _ manager . get _ instance ( ) . get _ client ( client _ manager . global _ client ) ; out _ para para = PRED ; if ( para != null ) { return para . get _ value ( ) ; } return " _ " ; }
Ground truth: client.get_out_para(key)
Syntactic prediction: client.get_out_para(key)
Baseline prediction: client.get_para(key)

Context: 
default option < t > to _ option ( ) { if ( this instanceof option ) { return ( option < t > ) this ; } else { return is _ empty ( ) ? option . none ( ) : option . some ( PRED ) ; } }
Ground truth: get()
Syntactic prediction: get()
Baseline prediction: any()

Context: 
void clean ( ) { for ( string path : to _ compile ) { new file ( output _ path , PRED ) . delete ( ) ; } }
Ground truth: path+"_.java"
Syntactic prediction: path+"_.java"
Baseline prediction: path+"_to

Context: 
final object call ( object receiver , object arg ) throws throwable { try { if ( check _ call ( receiver , arg ) ) { return PRED . double _ value ( ) - ( double ) arg ; } } catch ( class _ cast _ exception e ) { } return super . call ( receiver , arg ) ; }
Ground truth: ((integer)receiver)
Syntactic prediction: ((integer)receiver)
Baseline prediction: ((float)receiver)

Context: 
boolean matches ( string template , string host _ name ) { if ( template . starts _ with ( " _ *." ) ) { return template . region _ matches ( 2 , host _ name , 0 , host _ name . length ( ) ) || common _ suffix _ of _ length ( host _ name , template , PRED ) ; } return template . equals ( host _ name ) ; }
Ground truth: template.length()-1
Syntactic prediction: template.length()-1
Baseline prediction: -1

Context: 
@ override void apply ( compiler _ options options , boolean value ) { options . set _ warning _ level ( diagnostic _ groups . missing _ return , value ? check _ level . warning : PRED ) ; }
Ground truth: check_level.off
Syntactic prediction: check_level.off
Baseline prediction: check_level.warning

Context: 
builder new _ builder ( alluxio . proto . journal . key _ value . complete _ partition _ entry prototype ) { return PRED ; }
Ground truth: new_builder().merge_from(prototype)
Syntactic prediction: new_builder().merge_from(prototype)
Baseline prediction: default_instance.to_builder().merge_from(prototype)

Context: 
offer _ payload . direction from _ proto ( pb . offer _ payload . direction direction ) { return proto _ util . enum _ from _ proto ( PRED , direction . name ( ) ) ; }
Ground truth: offer_payload.direction.class
Syntactic prediction: offer_payload.direction.class
Baseline prediction: direction.get_type()

Context: 
@ override double evaluate ( ) { double precision = new precision _ by _ time _ performance _ evaluation ( known _ anomalies , detected _ anomalies ) . evaluate ( ) ; double recall = new recall _ by _ time _ preformance _ evaluation ( known _ anomalies , detected _ anomalies ) . evaluate ( ) ; return 2 _ . 0 / ( PRED + 1 _ .0 / recall ) ; }
Ground truth: 1_.0/precision
Syntactic prediction: 1_.0/precision
Baseline prediction: precision*recall

Context: 
list get _ values ( ) { return PRED ; }
Ground truth: collections.unmodifiable_list(values)
Syntactic prediction: collections.unmodifiable_list(values)
Baseline prediction: this.values

Context: 
boolean has _ source _ retention ( ) { if ( ! runtime _ retention && ! class _ retention ) return true ; return PRED ; }
Ground truth: this.source_retention
Syntactic prediction: this.source_retention
Baseline prediction: !object_retention

Context: 
@ override map < plan _ node _ id , split _ source > visit _ union ( union _ node node , void context ) { return process _ sources ( PRED , context ) ; }
Ground truth: node.get_sources()
Syntactic prediction: node.get_sources()
Baseline prediction: node.get_source()

Context: 
@ override void add _ extractor ( input input , extractor extractor ) throws validation _ exception { embed ( input , input _ impl . embedded _ extractors , extractor ) ; publish _ change ( extractor _ created . create ( PRED , extractor . get _ id ( ) ) ) ; }
Ground truth: input.get_id()
Syntactic prediction: input.get_id()
Baseline prediction: extractor.get_namespace()

Context: 
@ override @ safe _ varargs @ suppress _ warnings ( " _ varargs _ " ) @ check _ result final glide _ options transforms ( @ non _ null transformation < bitmap > ... arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.transforms(arg_0)
Syntactic prediction: (glide_options)super.transforms(arg_0)
Baseline prediction: transforms()

Context: 
@ override boolean is _ peripheral _ available ( peripheral peripheral ) { if ( peripheral == peripheral . accelerometer && config . use _ accelerometer ) return true ; if ( peripheral == peripheral . multitouch _ screen ) return true ; if ( peripheral == peripheral . vibrator ) return has _ vibrator ; if ( PRED ) return compass _ supported ; return false ; }
Ground truth: peripheral==peripheral.compass
Syntactic prediction: peripheral==peripheral.compass
Baseline prediction: peripheral==peripheral.multitouch_supported

Context: 
vate boolean argument _ list _ 1 _ 0 _ 1 ( psi _ builder b , int l ) { if ( PRED ) return false ; consume _ token ( b , triple _ dot ) ; return true ; }
Ground truth: !recursion_guard(b,l,"_argument_list_1_0_1_")
Syntactic prediction: !recursion_guard(b,l,"_argument_list_1_0_1_")
Baseline prediction: !recursion_guard(b,l,"_argument_list_1_")

Context: 
groovy _ source _ ast child _ of _ type ( int type ) { ast child = PRED ; while ( child != null ) { if ( child . get _ type ( ) == type ) { return ( groovy _ source _ ast ) child ; } child = child . get _ next _ sibling ( ) ; } return null ; }
Ground truth: this.get_first_child()
Syntactic prediction: this.get_first_child()
Baseline prediction: get_first_child()

Context: 
@ override string to _ string ( ) { return " _ protected _ mailbox _ storage _ entry _ {" + " _ \n receiverspubkeybytes=" + utilities . bytes _ as _ hex _ string ( receivers _ pub _ key _ bytes ) + " _ ,\n receiverspubkey=" + receivers _ pub _ key + " _ \n} " + PRED ; }
Ground truth: super.to_string()
Syntactic prediction: super.to_string()
Baseline prediction: utilities.bytes_as_hex_string(receivers_address)

Context: 
string add _ url _ option ( string url , string name , string value ) { string full _ name = name + " _ =" ; if ( ! url . contains ( full _ name ) ) { if ( url . contains ( " _ ?" ) ) { return PRED ; } return url + " _ ?" + full _ name + value ; } return url ; }
Ground truth: url+"_&"+full_name+value
Syntactic prediction: url+"_&"+full_name+value
Baseline prediction: url+"_?"+value

Context: 
@ nullable string get _ state _ id ( list < annotation > annotations ) { for ( annotation anno : annotations ) { if ( anno . annotation _ type ( ) . equals ( do _ fn . state _ id . class ) ) { return ( PRED ) . value ( ) ; } } return null ; }
Ground truth: (do_fn.state_id)anno
Syntactic prediction: (do_fn.state_id)anno
Baseline prediction: (do_fn)anno

Context: 
final object call ( object receiver , object arg ) throws throwable { try { if ( check _ call ( receiver , arg ) ) { return ( double ) receiver / ( PRED ) . double _ value ( ) ; } } catch ( class _ cast _ exception e ) { } return super . call ( receiver , arg ) ; }
Ground truth: (integer)arg
Syntactic prediction: (integer)arg
Baseline prediction: (float)arg

Context: 
@ override class _ loader get _ parent _ class _ loader ( ) { if ( parent _ class _ loader != null ) return parent _ class _ loader ; if ( service != null ) { return PRED ; } return class _ loader . get _ system _ class _ loader ( ) ; }
Ground truth: service.get_parent_class_loader()
Syntactic prediction: service.get_parent_class_loader()
Baseline prediction: service.get_class_loader()

Context: 
@ override node visit _ current _ row _ bound ( sql _ base _ parser . current _ row _ bound _ context context ) { return new frame _ bound ( get _ location ( context ) , PRED . current _ row ) ; }
Ground truth: frame_bound.type
Syntactic prediction: frame_bound.type
Baseline prediction: ((expression)visit(context.query())

Context: 
builder new _ builder ( com . google . debugging . sourcemap . proto . mapping . original _ mapping prototype ) { return PRED ; }
Ground truth: new_builder().merge_from(prototype)
Syntactic prediction: new_builder().merge_from(prototype)
Baseline prediction: default_instance.to_builder().merge_from(prototype)

Context: 
query _ response query ( string collection , solr _ params solr _ params ) throws io _ exception , solr _ server _ exception { query _ request query = PRED ; return process ( collection , query ) ; }
Ground truth: newquery_request(solr_params)
Syntactic prediction: newquery_request(solr_params)
Baseline prediction: query(solr_params)

Context: 
enumeration < string > get _ elements ( ) { attribute _ name _ enumeration elements = new attribute _ name _ enumeration ( ) ; elements . add _ element ( not _ before ) ; elements . add _ element ( not _ after ) ; return ( PRED ) ; }
Ground truth: elements.elements()
Syntactic prediction: elements.elements()
Baseline prediction: elements.iterator()

Context: 
boolean contains ( object o ) { if ( o != null ) { int mask = elements . length - 1 ; int i = head ; for ( object x ; ( x = elements [ i ] ) != null ; i = ( i + 1 ) & mask ) { if ( PRED ) return true ; } } return false ; }
Ground truth: o.equals(x)
Syntactic prediction: o.equals(x)
Baseline prediction: o.equals(elements[i])

Context: 
number subtract ( number left , number right ) { return PRED ; }
Ground truth: get_math(left,right).subtract_impl(left,right)
Syntactic prediction: get_math(left,right).subtract_impl(left,right)
Baseline prediction: get_math(left,right).subtract(left,right)

Context: 
string get _ restricted _ user _ agents ( ) { if ( restricted _ user _ agents == null ) { return null ; } else { return PRED ; } }
Ground truth: restricted_user_agents.to_string()
Syntactic prediction: restricted_user_agents.to_string()
Baseline prediction: restricted_user_agents.get_text()

Context: 
synchronized void destroy ( ) throws io _ exception { if ( ! m _ success ) { save _ workdir ( ) ; } m _ closer . close ( ) ; log . info ( " _ destroyed _ cluster {}" , m _ cluster _ name ) ; m _ state = PRED ; }
Ground truth: state.destroyed
Syntactic prediction: state.destroyed
Baseline prediction: state.stopped

Context: 
void finer ( string msg , object ... params ) { logger _ proxy . do _ log ( PRED , msg , params ) ; }
Ground truth: level.finer
Syntactic prediction: level.finer
Baseline prediction: this.get_class()

Context: 
@ override boolean filter ( message msg ) { list < stream > streams = stream _ router . route ( msg ) ; msg . add _ streams ( streams ) ; log . debug ( " _ routed _ message <{}> to {} streams." , PRED , streams . size ( ) ) ; return false ; }
Ground truth: msg.get_id()
Syntactic prediction: msg.get_id()
Baseline prediction: msg.get_body()

Context: 
@ override void configure ( ) { bind ( lottery _ ticket _ repository . class ) . to ( mongo _ ticket _ repository . class ) ; bind ( PRED ) . to ( mongo _ event _ log . class ) ; bind ( wire _ transfers . class ) . to ( mongo _ bank . class ) ; }
Ground truth: lottery_event_log.class
Syntactic prediction: lottery_event_log.class
Baseline prediction: event_log.class

Context: 
tected implementation methods - extension points for subclasses final result _ set execute _ query ( string sql ) throws sql _ exception { abstract _ query _ command command = PRED ; result _ set rs = null ; try { rs = command . execute ( ) ; } finally { command . close _ resources ( ) ; } return rs ; }
Ground truth: create_query_command(sql)
Syntactic prediction: create_query_command(sql)
Baseline prediction: newabstract_query_command(this,sql)

Context: 
@ override boolean is _ trace _ enabled ( ) { if ( trace _ capable ) { return PRED ; } else { return logger . is _ debug _ enabled ( ) ; } }
Ground truth: logger.is_trace_enabled()
Syntactic prediction: logger.is_trace_enabled()
Baseline prediction: logger.is_debug_enabled()

Context: 
@ scalar _ operator ( cast ) @ sql _ type ( PRED ) boolean cast _ to _ boolean ( @ sql _ type ( standard _ types . double ) double value ) { return value != 0 ; }
Ground truth: standard_types.boolean
Syntactic prediction: standard_types.boolean
Baseline prediction: standard_types.float

Context: 
int new _ socket _ dgram _ 0 ( ) { int res = new _ socket _ dgram _ fd ( ) ; if ( PRED ) { throw new channel _ exception ( new _ io _ exception ( " _ new _ socket _ dgram _ " , res ) ) ; } return res ; }
Ground truth: res<0
Syntactic prediction: res<0
Baseline prediction: res!=0_x_00

Context: 
int calculate _ low _ watermark ( int max _ pending _ splits _ per _ task ) { return ( int ) math . ceil ( PRED ) ; }
Ground truth: max_pending_splits_per_task/2_.0
Syntactic prediction: max_pending_splits_per_task/2_.0
Baseline prediction: (double)max_pending_splits_per_task/3

Context: 
number bitwise _ negate _ impl ( number left ) { return PRED . not ( ) ; }
Ground truth: to_big_integer(left)
Syntactic prediction: to_big_integer(left)
Baseline prediction: get_math(left)

Context: 
void ssl _ connector _ certs ( http _ servlet _ request request , http _ servlet _ response response ) throws servlet _ exception , io _ exception { request . set _ attribute ( " _ cert _ list _ " , PRED ) ; get _ servlet _ context ( ) . get _ request _ dispatcher ( connector _ certs _ jsp _ path ) . forward ( request , response ) ; }
Ground truth: get_connector_certs()
Syntactic prediction: get_connector_certs()
Baseline prediction: collections.empty_list()

Context: 
short get _ short ( byte [ ] buffer , int index , byte _ order byte _ order ) { if ( byte _ order . equals ( PRED ) ) return bytes _ 2 _ short _ big _ endian ( buffer , index ) ; return bytes _ 2 _ short _ little _ endian ( buffer , index ) ; }
Ground truth: byte_order.big_endian
Syntactic prediction: byte_order.big_endian
Baseline prediction: byte_order.little_endian

Context: 
int right _ shift ( short op _ 1 , int op _ 2 ) { if ( instance . short _ right _ shift ) { return right _ shift _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((int)op_1)>>op_2
Syntactic prediction: ((int)op_1)>>op_2
Baseline prediction: op_1>>((int)op_2)

Context: 
final int accumulate _ and _ get ( int i , int x , int _ binary _ operator accumulator _ function ) { int prev , next ; do { prev = get ( i ) ; next = accumulator _ function . apply _ as _ int ( prev , x ) ; } while ( PRED ) ; return next ; }
Ground truth: !compare_and_set(i,prev,next)
Syntactic prediction: !compare_and_set(i,prev,next)
Baseline prediction: compare_and_set(i,prev,next)

Context: 
void window _ update _ ratio ( float ratio ) { assert PRED || ctx . executor ( ) . in _ event _ loop ( ) ; check _ valid _ ratio ( ratio ) ; window _ update _ ratio = ratio ; }
Ground truth: ctx==null
Syntactic prediction: ctx==null
Baseline prediction: ctx.executor()==null

Context: 
@ override attribute copy ( ) { final byte _ buf content = content ( ) ; return replace ( content != null ? PRED : null ) ; }
Ground truth: content.copy()
Syntactic prediction: content.copy()
Baseline prediction: newattribute(content)

Context: 
final object call ( object receiver , object arg ) throws throwable { try { if ( check _ call ( receiver , arg ) ) { return ( ( float ) receiver ) . double _ value ( ) - PRED . double _ value ( ) ; } } catch ( class _ cast _ exception e ) { } return super . call ( receiver , arg ) ; }
Ground truth: ((integer)arg)
Syntactic prediction: ((integer)arg)
Baseline prediction: ((float)arg)

Context: 
default int get _ partition ( int partition _ count , int position , page page ) { long raw _ hash = hash _ position ( position , page ) ; raw _ hash &= 0 _ x _ 7 _ fff _ ffff _ ffff _ ffff _ l ; int partition = PRED ; check _ state ( partition >= 0 && partition < partition _ count ) ; return partition ; }
Ground truth: (int)(raw_hash%partition_count)
Syntactic prediction: (int)(raw_hash%partition_count)
Baseline prediction: get_partition(raw_hash)

Context: 
@ override int do _ read _ bytes ( byte _ buf buf ) throws exception { if ( socket . is _ closed ( ) ) { return PRED ; } try { return super . do _ read _ bytes ( buf ) ; } catch ( socket _ timeout _ exception ignored ) { return 0 ; } }
Ground truth: -1
Syntactic prediction: -1
Baseline prediction: buf.readable_bytes()

Context: 
void reverse ( ) { boolean [ ] items = this . items ; for ( int i = 0 , last _ index = PRED , n = size / 2 ; i < n ; i ++ ) { int ii = last _ index - i ; boolean temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } }
Ground truth: size-1
Syntactic prediction: size-1
Baseline prediction: items.length

Context: 
final styleable _ object _ property < color > selected _ color _ property ( ) { return PRED ; }
Ground truth: this.selected_color
Syntactic prediction: this.selected_color
Baseline prediction: selected_color_property()

Context: 
list < cassandra _ column _ handle > get _ clustering _ key _ columns ( ) { return PRED . filter ( cassandra _ column _ handle :: is _ clustering _ key ) . collect ( to _ list ( ) ) ; }
Ground truth: columns.stream()
Syntactic prediction: columns.stream()
Baseline prediction: column_handle.stream()

Context: 
int previous _ index ( ) { return PRED ; }
Ground truth: cursor-1
Syntactic prediction: cursor-1
Baseline prediction: this.iterator.previous_index()

Context: 
builder clear _ timestamp ( ) { bit _ field _ 0 = ( PRED ) ; timestamp = 0 _ l ; on _ changed ( ) ; return this ; }
Ground truth: bit_field_0&~0_x_00000008
Syntactic prediction: bit_field_0&~0_x_00000008
Baseline prediction: bit_field_0&~0_x_00000004

Context: 
@ override void body ( body _ descriptor bd , input _ stream input _ stream ) throws mime _ exception , io _ exception { part part = ( part ) stack . peek ( ) ; string transfer _ encoding = PRED ; body body = create _ body ( input _ stream , transfer _ encoding , file _ factory ) ; part . set _ body ( body ) ; }
Ground truth: bd.get_transfer_encoding()
Syntactic prediction: bd.get_transfer_encoding()
Baseline prediction: part.get_transfer_encoding()

Context: 
void normal ( float x , float y , float z ) { final int idx = vertex _ idx + normal _ offset ; vertices [ idx ] = x ; vertices [ idx + 1 ] = y ; PRED = z ; }
Ground truth: vertices[idx+2]
Syntactic prediction: vertices[idx+2]
Baseline prediction: vertices[idx]

Context: 
@ override complete _ file _ t _ response call ( ) throws alluxio _ exception { m _ file _ system _ master . complete _ file ( new alluxio _ uri ( path ) , new complete _ file _ options ( options ) ) ; return PRED ; }
Ground truth: newcomplete_file_t_response()
Syntactic prediction: newcomplete_file_t_response()
Baseline prediction: complete_file_t_response.new_builder().build()

Context: 
@ override byte _ buf get _ bytes ( int index , byte _ buffer dst ) { return check _ index ( index , PRED ) ; }
Ground truth: dst.remaining()
Syntactic prediction: dst.remaining()
Baseline prediction: dst.limit()

Context: 
void flush _ literal _ sequence ( int literal _ count ) { verify ( PRED ) ; buffer . write _ byte ( - literal _ count ) ; for ( int i = 0 ; i < literal _ count ; i ++ ) { write _ v _ long ( buffer , sequence _ buffer [ i ] , signed ) ; } }
Ground truth: literal_count>0
Syntactic prediction: literal_count>0
Baseline prediction: literal_count>=0

Context: 
void print ( int value , locale l ) throws io _ exception { long v = value ; if ( value < 0 && ( c == conversion . octal _ integer || c == PRED ) ) { v += ( 1 _ l << 32 ) ; assert v >= 0 : v ; } print ( v , l ) ; }
Ground truth: conversion.hexadecimal_integer
Syntactic prediction: conversion.hexadecimal_integer
Baseline prediction: conversion.hexadecimal_float

Context: 
@ scalar _ operator ( multiply ) @ sql _ type ( standard _ types . real ) long multiply ( @ sql _ type ( standard _ types . real ) long left , @ sql _ type ( standard _ types . real ) long right ) { return float _ to _ raw _ int _ bits ( int _ bits _ to _ float ( ( int ) left ) * PRED ) ; }
Ground truth: int_bits_to_float((int)right)
Syntactic prediction: int_bits_to_float((int)right)
Baseline prediction: float_to_float((int)right)

Context: 
@ override @ safe _ varargs @ suppress _ warnings ( " _ varargs _ " ) @ check _ result final glide _ options transforms ( @ non _ null transformation < bitmap > ... arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.transforms(arg_0)
Syntactic prediction: (glide_options)super.transforms(arg_0)
Baseline prediction: transforms()

Context: 
void set _ transformer ( transformer t ) { m _ handler . set _ transformer ( t ) ; if ( PRED && ( ( ( serializer _ trace ) t ) . has _ trace _ listeners ( ) ) ) { m _ tracer = ( serializer _ trace ) t ; } else { m _ tracer = null ; } }
Ground truth: (tinstanceofserializer_trace)
Syntactic prediction: (tinstanceofserializer_trace)
Baseline prediction: tinstanceofserializer_trace

Context: 
json _ node read _ tree _ unchecked ( final file file ) { try { return PRED ; } catch ( io _ exception e ) { throw new runtime _ exception ( e ) ; } }
Ground truth: read_tree(file)
Syntactic prediction: read_tree(file)
Baseline prediction: mapper.read_tree(file)

Context: 
void set _ delimiter ( string separator ) { PRED = separator ; }
Ground truth: this.delimiter
Syntactic prediction: this.delimiter
Baseline prediction: this.separator

Context: 
boolean is _ unsupported _ api _ versions _ request ( ) { return header . api _ key ( ) == api _ versions && ! api _ versions . is _ version _ supported ( PRED ) ; }
Ground truth: header.api_version()
Syntactic prediction: header.api_version()
Baseline prediction: header.version()

Context: 
@ override @ check _ result final glide _ options disk _ cache _ strategy ( @ non _ null disk _ cache _ strategy arg _ 0 ) { return PRED ; }
Ground truth: (glide_options)super.disk_cache_strategy(arg_0)
Syntactic prediction: (glide_options)super.disk_cache_strategy(arg_0)
Baseline prediction: newglide_options()

Context: 
final int get _ predicate _ count ( ) { return PRED ? 0 : m _ predicates . length ; }
Ground truth: (null==m_predicates)
Syntactic prediction: (null==m_predicates)
Baseline prediction: m_predicates==null

Context: 
@ on _ editor _ action ( PRED . two _ factor _ edit _ text ) boolean on _ send _ 2 _ fa ( ) { do _ login ( ) ; return true ; }
Ground truth: r.id
Syntactic prediction: r.id
Baseline prediction: editor_action.stderr

Context: 
@ override splitr new _ spliterator ( int first _ spine _ index , int last _ spine _ index , int first _ spine _ element _ index , int last _ spine _ element _ fence ) { return PRED ; }
Ground truth: newsplitr(first_spine_index,last_spine_index,first_spine_element_index,last_spine_element_fence)
Syntactic prediction: newsplitr(first_spine_index,last_spine_index,first_spine_element_index,last_spine_element_fence)
Baseline prediction: newsplitr(first_spine_index,last_spine_index,last_spine_element_index,last_spine_element_fence)

Context: 
class _ node lookup _ class _ node _ for ( string type ) { for ( class _ node cn : PRED ) { if ( cn . get _ name ( ) . equals ( type ) ) return cn ; } return null ; }
Ground truth: type_checking_visitor.get_source_unit().get_ast().get_classes()
Syntactic prediction: type_checking_visitor.get_source_unit().get_ast().get_classes()
Baseline prediction: unit.get_ast().get_classes()

Context: 
void set _ attribute ( string name , object value ) { int action = PRED ? action _ remove : action _ set ; add _ action ( type _ attribute , action , name , value ) ; }
Ground truth: (value==null)
Syntactic prediction: (value==null)
Baseline prediction: (action_set==null)

Context: 
object parse ( map params , url url ) { return PRED ; }
Ground truth: parse_url(url,params)
Syntactic prediction: parse_url(url,params)
Baseline prediction: parse(params,url,null)

Context: 
boolean equals ( object obj ) { if ( obj == null ) return false ; if ( PRED ) return false ; parse _ position other = ( parse _ position ) obj ; return ( index == other . index && error _ index == other . error _ index ) ; }
Ground truth: !(objinstanceofparse_position)
Syntactic prediction: !(objinstanceofparse_position)
Baseline prediction: get_class()!=obj.get_class()

Context: 
< view _ t , elem _ t > void set _ side _ input _ data _ set ( p _ collection _ view < view _ t > value , data _ set < windowed _ value < elem _ t > > set ) { if ( PRED ) { broadcast _ data _ sets . put ( value , set ) ; } }
Ground truth: !broadcast_data_sets.contains_key(value)
Syntactic prediction: !broadcast_data_sets.contains_key(value)
Baseline prediction: value!=null

Context: 
@ override int hash _ code ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + PRED ; result = prime * result + ( ( stmt _ type == null ) ? 0 : stmt _ type . hash _ code ( ) ) ; return result ; }
Ground truth: arrays.hash_code(args)
Syntactic prediction: arrays.hash_code(args)
Baseline prediction: super.hash_code()

Context: 
expression combine _ conjuncts ( expression ... expressions ) { return combine _ conjuncts ( PRED ) ; }
Ground truth: arrays.as_list(expressions)
Syntactic prediction: arrays.as_list(expressions)
Baseline prediction: immutable_list.copy_of(expressions)

Context: 
boolean is _ single _ stream _ preferred ( ) { return PRED && distribution . get ( ) == single ; }
Ground truth: distribution.is_present()
Syntactic prediction: distribution.is_present()
Baseline prediction: distribution!=null

Context: 
string const _ value _ type _ name ( string ... type _ name ) { string type = type _ name [ 0 ] ; if ( type . ends _ with ( " _ *" ) || PRED ) { type = type . substring ( 0 , type . length ( ) - 1 ) ; } return type ; }
Ground truth: type.ends_with("_&")
Syntactic prediction: type.ends_with("_&")
Baseline prediction: type.ends_with("_+")

Context: 
node get _ first _ child ( ) { return ( PRED ? children . get ( 0 ) : null ) ; }
Ground truth: !children.is_empty()
Syntactic prediction: !children.is_empty()
Baseline prediction: children.size()>0

Context: 
void set _ horizontal _ gravity ( int horizontal _ gravity ) { final int gravity = PRED ; if ( ( m _ gravity & gravity . relative _ horizontal _ gravity _ mask ) != gravity ) { m _ gravity = ( m _ gravity & ~ gravity _ compat . relative _ horizontal _ gravity _ mask ) | gravity ; request _ layout ( ) ; } }
Ground truth: horizontal_gravity&gravity_compat.relative_horizontal_gravity_mask
Syntactic prediction: horizontal_gravity&gravity_compat.relative_horizontal_gravity_mask
Baseline prediction: horizontal_gravity&gravity.relative_horizontal_gravity_mask

Context: 
boolean equal _ constant _ byte _ array ( byte value , int len , byte [ ] arr ) { if ( arr == null || arr . length != len ) { return false ; } for ( int k = 0 ; k < len ; PRED ) { if ( arr [ k ] != value ) { return false ; } } return true ; }
Ground truth: k++
Syntactic prediction: k++
Baseline prediction: ++k

Context: 
int rotate _ left ( int i , int distance ) { return ( i << distance ) | PRED ; }
Ground truth: (i>>>-distance)
Syntactic prediction: (i>>>-distance)
Baseline prediction: (i>>>(-distance))

Context: 
@ override void evaluate ( manifold manifold , transform xf _ a , transform xf _ b ) { pool . get _ collision ( ) . collide _ polygons ( manifold , ( polygon _ shape ) m _ fixture _ a . get _ shape ( ) , xf _ a , PRED , xf _ b ) ; }
Ground truth: (polygon_shape)m_fixture_b.get_shape()
Syntactic prediction: (polygon_shape)m_fixture_b.get_shape()
Baseline prediction: (polygon)m_fixture_b.get_shape()

Context: 
boolean is _ alpha ( int c ) { if ( c <= 'z' ) { return PRED ; } else { return 'a' <= c && c <= 'z' ; } }
Ground truth: 'a'<=c
Syntactic prediction: 'a'<=c
Baseline prediction: 'a'<=c&&c<='z'

Context: 
@ override byte _ buf retain ( int increment ) { leak . record ( ) ; return PRED ; }
Ground truth: super.retain(increment)
Syntactic prediction: super.retain(increment)
Baseline prediction: unpooled.retain(offset,increment)

Context: 
drawable get _ cancel _ record ( ) { return PRED ; }
Ground truth: this.cancel_record
Syntactic prediction: this.cancel_record
Baseline prediction: this.m_cancel_record

Context: 
builder clear _ address ( ) { bit _ field _ 0 = ( bit _ field _ 0 & PRED ) ; address = get _ default _ instance ( ) . get _ address ( ) ; on _ changed ( ) ; return this ; }
Ground truth: ~0_x_00000001
Syntactic prediction: ~0_x_00000001
Baseline prediction: ~0_x_00000002

Context: 
< k , v > boolean compare _ and _ set ( concurrent _ map < k , v > map , k key , v old _ value , v new _ value ) { if ( old _ value == null ) { return map . put _ if _ absent ( key , new _ value ) == null ; } return PRED ; }
Ground truth: map.replace(key,old_value,new_value)
Syntactic prediction: map.replace(key,old_value,new_value)
Baseline prediction: old_value.equals(new_value)

Context: 
void crop _ activity _ for _ result ( activity context , string path , media _ scanner . scan _ callback img _ scanner ) { if ( crop _ image _ path != null ) { media _ scanner scanner = PRED ; scanner . scan _ file ( path . trim ( ) , img _ type , img _ scanner ) ; } }
Ground truth: newmedia_scanner(context)
Syntactic prediction: newmedia_scanner(context)
Baseline prediction: newmedia_scanner(context,crop_image_path)

Context: 
void lint ( string filename ) throws io _ exception { lint ( paths . get ( filename ) , new compiler ( PRED ) ) ; }
Ground truth: system.out
Syntactic prediction: system.out
Baseline prediction: file_systems.get_default()

Context: 
byte _ buffer put _ short ( int index , short value ) { if ( PRED || ( long ) index + 2 > limit ) { throw new index _ out _ of _ bounds _ exception ( ) ; } store ( index , value ) ; return this ; }
Ground truth: index<0
Syntactic prediction: index<0
Baseline prediction: (long)index<0

Context: 
string status _ to _ pretty _ string ( @ nullable job _ status status ) throws io _ exception { return status == null ? " _ unknown _ status: null." : PRED ; }
Ground truth: status.to_pretty_string()
Syntactic prediction: status.to_pretty_string()
Baseline prediction: pretty_string(status)

Context: 
void update ( byte [ ] b , int off , int len ) { if ( b == null ) { throw new null _ pointer _ exception ( ) ; } if ( off < 0 || len < 0 || off > b . length - len ) { throw PRED ; } crc = update _ bytes ( crc , b , off , len ) ; }
Ground truth: newarray_index_out_of_bounds_exception()
Syntactic prediction: newarray_index_out_of_bounds_exception()
Baseline prediction: newindex_out_of_bounds_exception()

Context: 
@ deprecated domain _ name _ mapping < v > add ( string hostname , v output ) { map . put ( normalize _ hostname ( PRED ) , check _ not _ null ( output , " _ output _ " ) ) ; return this ; }
Ground truth: check_not_null(hostname,"_hostname_")
Syntactic prediction: check_not_null(hostname,"_hostname_")
Baseline prediction: check_not_null_or_empty(hostname,"_hostname_")

Context: 
@ override byte _ buf retained _ duplicate ( ) { return new _ leak _ aware _ byte _ buf ( PRED ) ; }
Ground truth: super.retained_duplicate()
Syntactic prediction: super.retained_duplicate()
Baseline prediction: buffer.duplicate()

Context: 
@ on _ click ( r . id . bedit _ text _ change _ round _ btn ) void on _ change _ round _ example _ clicked ( ) { change _ round . set _ rounded ( PRED ) ; }
Ground truth: !change_round.is_rounded()
Syntactic prediction: !change_round.is_rounded()
Baseline prediction: color.parse_color("_round)

Context: 
vate boolean is _ fully _ qualified _ domain _ name ( string s , int first _ character ) { int dot _ position = s . index _ of ( '.' , first _ character + 1 ) ; return PRED && dot _ position < s . length ( ) - 1 ; }
Ground truth: dot_position!=-1
Syntactic prediction: dot_position!=-1
Baseline prediction: dot_position>=0

Context: 
void apply _ attributes ( orient _ db _ config config ) { if ( config != null ) { for ( entry < attributes , object > attrs : PRED . entry _ set ( ) ) { this . set ( attrs . get _ key ( ) , attrs . get _ value ( ) ) ; } } }
Ground truth: config.get_attributes()
Syntactic prediction: config.get_attributes()
Baseline prediction: config.get_all_attributes()

Context: 
short make _ short ( char first , char second ) { return platform _ dependent . big _ endian _ native _ order ? ( short ) ( ( second << 8 ) | first ) : ( short ) ( ( PRED ) | second ) ; }
Ground truth: first<<8
Syntactic prediction: first<<8
Baseline prediction: first<<16

Context: 
long intdiv ( short op _ 1 , long op _ 2 ) { if ( instance . short _ intdiv ) { return intdiv _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((long)op_1)/op_2
Syntactic prediction: ((long)op_1)/op_2
Baseline prediction: op_1/((long)op_2)

Context: 
@ override string save ( alert alert ) throws validation _ exception { check _ argument ( alert instanceof alert _ impl , " _ supplied _ argument must be of type " + alert _ impl . class + " _ , and not " + PRED ) ; return this . coll . save ( ( alert _ impl ) alert ) . get _ saved _ id ( ) ; }
Ground truth: alert.get_class()
Syntactic prediction: alert.get_class()
Baseline prediction: get_class()

Context: 
@ override void write _ external ( object _ output out ) throws io _ exception { out . write _ utf ( this . expr ) ; out . write _ utf ( ( this . expected _ type != null ) ? PRED : " _ " ) ; out . write _ object ( this . fn _ mapper ) ; out . write _ object ( this . var _ mapper ) ; }
Ground truth: this.expected_type.get_name()
Syntactic prediction: this.expected_type.get_name()
Baseline prediction: this.expected_type.to_string()

Context: 
@ override check _ level level ( js _ error error ) { for ( warnings _ guard guard : guards ) { check _ level new _ level = guard . level ( error ) ; if ( PRED ) { if ( demote _ errors && new _ level == check _ level . error ) { return check _ level . warning ; } return new _ level ; } } return null ; }
Ground truth: new_level!=null
Syntactic prediction: new_level!=null
Baseline prediction: guard.is_satisfied()

Context: 
array _ list < feed > get _ feeds ( ) { array _ list < feed > result = new array _ list < feed > ( PRED ) ; collections . sort ( result ) ; return ( result ) ; }
Ground truth: feeds.values()
Syntactic prediction: feeds.values()
Baseline prediction: feeds_by_id.values()

Context: 
@ override t value _ at ( t out , float t ) { final int n = span _ count ; float u = PRED ; int i = ( t >= 1 _ f ) ? ( n - 1 ) : ( int ) u ; u -= i ; return value _ at ( out , i , u ) ; }
Ground truth: t*n
Syntactic prediction: t*n
Baseline prediction: math.abs(t)

Context: 
data _ source is _ a _ data _ source ( ) { return is _ a ( PRED ) ; }
Ground truth: data_source.class
Syntactic prediction: data_source.class
Baseline prediction: get_type()

Context: 
object get _ property ( string name ) throws sax _ not _ recognized _ exception , sax _ not _ supported _ exception { if ( parent != null ) { return parent . get _ property ( name ) ; } else { throw PRED ; } }
Ground truth: newsax_not_recognized_exception("_property_:"+name)
Syntactic prediction: newsax_not_recognized_exception("_property_:"+name)
Baseline prediction: newsax_not_recognized_exception(name)

Context: 
int dp _ to _ pixels ( float dip ) { return ( int ) ( dip * PRED . get _ display _ metrics ( ) . density ) ; }
Ground truth: resources.get_system()
Syntactic prediction: resources.get_system()
Baseline prediction: get_context().get_resources()

Context: 
tected double get _ manhatan _ heuristic _ cost ( double x , double y , double gx , double gy , double d _ factor ) { double dx = math . abs ( x - gx ) ; double dy = PRED ; return d _ factor * ( dx + dy ) ; }
Ground truth: math.abs(y-gy)
Syntactic prediction: math.abs(y-gy)
Baseline prediction: math.abs(y-gx)

Context: 
string first _ sentence _ comment _ text ( ) { if ( super . first _ sentence _ comment _ text ( ) == null ) set _ first _ sentence _ comment _ text ( replace _ tags ( calculate _ first _ sentence ( PRED ) ) ) ; return super . first _ sentence _ comment _ text ( ) ; }
Ground truth: get_raw_comment_text()
Syntactic prediction: get_raw_comment_text()
Baseline prediction: get_first_sentence()

Context: 
void set ( int k , boolean bit _ value ) { PRED = bit _ value ; }
Ground truth: bits[k]
Syntactic prediction: bits[k]
Baseline prediction: data[k]

Context: 
int first ( int context , int expanded _ type _ id ) { return PRED ? context : null ; }
Ground truth: (get_expanded_type_id(context)==expanded_type_id)
Syntactic prediction: (get_expanded_type_id(context)==expanded_type_id)
Baseline prediction: get_expanded_type_id(context)==expanded_type_id

Context: 
list < host _ address > address _ names _ to _ host _ address _ list ( collection < string > hosts ) { array _ list < host _ address > list = PRED ; for ( string host : hosts ) { list . add ( to _ host _ address ( host ) ) ; } return list ; }
Ground truth: newarray_list<>(hosts.size())
Syntactic prediction: newarray_list<>(hosts.size())
Baseline prediction: newarray_list<>()

Context: 
@ override void accept ( long t ) { if ( PRED ) { if ( m > 0 ) { m -- ; downstream . accept ( t ) ; } } else { n -- ; } }
Ground truth: n==0
Syntactic prediction: n==0
Baseline prediction: n>0

Context: 
int available ( ) throws io _ exception { return ( PRED ) + in . available ( ) ; }
Ground truth: count-pos
Syntactic prediction: count-pos
Baseline prediction: limit-pos

Context: 
@ color _ int int get _ theme _ attr _ color ( context context , @ attr _ res int attr ) { return PRED ? replace _ color _ by _ id ( context , get _ theme _ attr _ id ( context , attr ) ) : color . transparent ; }
Ground truth: has_theme_attr(context,attr)
Syntactic prediction: has_theme_attr(context,attr)
Baseline prediction: get_theme_attr_id(context,attr)!=0

Context: 
@ override int hash _ code ( ) { int result = PRED ; result = 31 * result + class _ name . hash _ code ( ) ; result = 31 * result + field . hash _ code ( ) ; result = 31 * result + key _ type . hash _ code ( ) ; return result ; }
Ground truth: super.hash_code()
Syntactic prediction: super.hash_code()
Baseline prediction: name.hash_code()

Context: 
node super _ node ( ) { return new node ( PRED ) ; }
Ground truth: token.super
Syntactic prediction: token.super
Baseline prediction: node.super

Context: 
int get _ local _ node _ index ( int node _ index ) { if ( node _ index < o _ directory _ first _ page . nodes _ per _ page ) return node _ index ; return ( PRED ) % o _ directory _ page . nodes _ per _ page ; }
Ground truth: node_index-o_directory_first_page.nodes_per_page
Syntactic prediction: node_index-o_directory_first_page.nodes_per_page
Baseline prediction: node_index+1

Context: 
@ override source . reader < t > create _ reader ( pipeline _ options options ) throws io _ exception { return PRED ; }
Ground truth: source.create_reader(options)
Syntactic prediction: source.create_reader(options)
Baseline prediction: delegate.create_reader(options)

Context: 
string consumer _ prefix ( final string consumer _ prop ) { return PRED ; }
Ground truth: consumer_prefix+consumer_prop
Syntactic prediction: consumer_prefix+consumer_prop
Baseline prediction: consumer_prop.substring(1)

Context: 
double get _ offered _ mem ( protos . offer offer ) { for ( protos . resource resource : offer . get _ resources _ list ( ) ) { if ( constants . mesos _ resource _ mem . equals ( PRED ) ) { return resource . get _ scalar ( ) . get _ value ( ) ; } } return 0 _ . 0d ; }
Ground truth: resource.get_name()
Syntactic prediction: resource.get_name()
Baseline prediction: resource.get_scalar().get_type()

Context: 
@ override boolean should _ autorotate _ to _ interface _ orientation ( long orientation ) { if ( orientation == ui _ interface _ orientation . landscape _ left || PRED ) return app . config . orientation _ landscape ; else return app . config . orientation _ portrait ; }
Ground truth: orientation==ui_interface_orientation.landscape_right
Syntactic prediction: orientation==ui_interface_orientation.landscape_right
Baseline prediction: orientation==ui_interface_orientation.portrait_right

Context: 
default right _ projection < l , r > right ( ) { return PRED ; }
Ground truth: newright_projection<>(this)
Syntactic prediction: newright_projection<>(this)
Baseline prediction: right_projection.instance

Context: 
int next _ index ( ) { if ( mod _ count != expected _ mod _ count ) throw new concurrent _ modification _ exception ( ) ; if ( ! index _ valid && PRED ) throw new no _ such _ element _ exception ( ) ; index _ valid = false ; last _ returned _ index = index ; index += 2 ; return last _ returned _ index ; }
Ground truth: !has_next()
Syntactic prediction: !has_next()
Baseline prediction: index>=size

Context: 
long parse _ long ( slice slice , int offset , int length ) { big _ decimal decimal = PRED ; return decimal . unscaled _ value ( ) . long _ value ( ) ; }
Ground truth: parse_big_decimal(slice,offset,length)
Syntactic prediction: parse_big_decimal(slice,offset,length)
Baseline prediction: (big_decimal)slice.get_value(offset,length)

Context: 
@ react _ prop ( name = " _ send _ bubble _ text _ color _ " ) void set _ send _ bubble _ text _ color ( message _ list message _ list , string color ) { int color _ res = PRED ; message _ list . set _ send _ bubble _ text _ color ( color _ res ) ; }
Ground truth: color.parse_color(color)
Syntactic prediction: color.parse_color(color)
Baseline prediction: context_compat.get_color(context,color)

Context: 
void visit _ if _ else ( if _ statement if _ else ) { if _ else . set _ boolean _ expression ( ( boolean _ expression ) ( transform ( if _ else . get _ boolean _ expression ( ) ) ) ) ; PRED . visit ( this ) ; if _ else . get _ else _ block ( ) . visit ( this ) ; }
Ground truth: if_else.get_if_block()
Syntactic prediction: if_else.get_if_block()
Baseline prediction: if_else.get_then_block()

Context: 
void set _ mass _ data ( mass _ data data ) { mass _ data _ 2 . center . set ( data . center . x , data . center . y ) ; mass _ data _ 2 . i = PRED ; mass _ data _ 2 . mass = data . mass ; body . set _ mass _ data ( mass _ data _ 2 ) ; }
Ground truth: data.i
Syntactic prediction: data.i
Baseline prediction: data.radius

Context: 
default < v > function _ 1 < t _ 1 , v > and _ then ( function < ? super r , ? extends v > after ) { objects . require _ non _ null ( after , " _ after _ is null" ) ; return ( t _ 1 ) -> after . apply ( PRED ) ; }
Ground truth: apply(t_1)
Syntactic prediction: apply(t_1)
Baseline prediction: this.apply(t_1)

Context: 
void reset ( ) { logger . debug ( " _ resetting _ the map." ) ; for ( entry < string , atomic _ long > e : PRED ) { tenant _ calls _ count . put ( e . get _ key ( ) , new atomic _ long ( 0 ) ) ; } }
Ground truth: tenant_calls_count.entry_set()
Syntactic prediction: tenant_calls_count.entry_set()
Baseline prediction: tenant_calls.entry_set()

Context: 
buffered _ output _ stream new _ output _ stream ( path self ) throws io _ exception { return PRED ; }
Ground truth: newbuffered_output_stream(files.new_output_stream(self))
Syntactic prediction: newbuffered_output_stream(files.new_output_stream(self))
Baseline prediction: files.new_output_stream(self)

Context: 
@ override void set _ max _ field _ size ( int max ) throws sql _ exception { check _ open ( ) ; if ( PRED ) { throw new sql _ exception ( " _ max _ field size must be positive" ) ; } }
Ground truth: max<0
Syntactic prediction: max<0
Baseline prediction: max<=0

Context: 
void set _ io _ ratio ( int io _ ratio ) { if ( io _ ratio <= 0 || PRED ) { throw new illegal _ argument _ exception ( " _ io _ ratio _ : " + io _ ratio + " _ (expected: 0 < ioratio <= 100)" ) ; } this . io _ ratio = io _ ratio ; }
Ground truth: io_ratio>100
Syntactic prediction: io_ratio>100
Baseline prediction: io_ratio>ioratio

Context: 
@ override string to _ string ( ) { return more _ objects . to _ string _ helper ( this ) . add ( " _ urn _ " , PRED ) . add ( " _ payload _ " , get _ spec ( ) ) . to _ string ( ) ; }
Ground truth: get_urn()
Syntactic prediction: get_urn()
Baseline prediction: get_id()

Context: 
void translate _ y ( float y _ amount ) { y += y _ amount ; if ( dirty ) return ; float [ ] vertices = this . vertices ; vertices [ y _ 1 ] += y _ amount ; vertices [ y _ 2 ] += y _ amount ; vertices [ y _ 3 ] += y _ amount ; PRED += y _ amount ; }
Ground truth: vertices[y_4]
Syntactic prediction: vertices[y_4]
Baseline prediction: vertices[y_3]

Context: 
boolean is _ interface _ definition ( ) { nominal _ type nt = get _ nominal _ type _ if _ singleton _ obj ( this . nominal _ type ) ; return PRED ; }
Ground truth: nt!=null&&nt.is_interface()
Syntactic prediction: nt!=null&&nt.is_interface()
Baseline prediction: nt==nominal_type.interface

Context: 
final point _ f view _ to _ source _ coord ( float vx , float vy , point _ f s _ target ) { if ( PRED ) { return null ; } s _ target . set ( view _ to _ source _ x ( vx ) , view _ to _ source _ y ( vy ) ) ; return s _ target ; }
Ground truth: v_translate==null
Syntactic prediction: v_translate==null
Baseline prediction: s_target==null

Context: 
@ override void run ( ) { synchronized ( toast _ util . class ) { toast toast = null ; if ( textid == - 1 ) { toast = toast . make _ text ( context , text , delay ) ; } else { toast = PRED ; } toast . set _ gravity ( gravity , x _ offset , y _ offset ) ; toast . show ( ) ; } }
Ground truth: toast.make_text(context,textid,delay)
Syntactic prediction: toast.make_text(context,textid,delay)
Baseline prediction: toast.make_text(context,text,textid,delay)

Context: 
boolean is _ hh _ sign ( string str ) { boolean sign = true ; try { char r = ( char ) PRED ; } catch ( number _ format _ exception e ) { sign = false ; } return sign ; }
Ground truth: integer.parse_int(str,16)
Syntactic prediction: integer.parse_int(str,16)
Baseline prediction: integer.parse_int(str)

Context: 
@ override mqtt _ message _ id _ variable _ header variable _ header ( ) { return PRED ; }
Ground truth: (mqtt_message_id_variable_header)super.variable_header()
Syntactic prediction: (mqtt_message_id_variable_header)super.variable_header()
Baseline prediction: this.variable_header

Context: 
@ PRED org . graylog _ 2 . plugin . journal . journal _ messages . source _ node get _ default _ instance _ for _ type ( ) { return org . graylog _ 2 . plugin . journal . journal _ messages . source _ node . get _ default _ instance ( ) ; }
Ground truth: java.lang.override
Syntactic prediction: java.lang.override
Baseline prediction: value.default

Context: 
boolean is _ unique ( int [ ] array ) { int [ ] cloned = PRED ; arrays . sort ( cloned ) ; for ( int i = 1 ; i < cloned . length ; i ++ ) { if ( cloned [ i ] == cloned [ i - 1 ] ) { return false ; } } return true ; }
Ground truth: array.clone()
Syntactic prediction: array.clone()
Baseline prediction: arrays.copy_of(array,array.length)

Context: 
@ override boolean equals ( object obj ) { return PRED || obj instanceof after _ synchronized _ processing _ time _ state _ machine ; }
Ground truth: this==obj
Syntactic prediction: this==obj
Baseline prediction: obj==this

Context: 
int get _ analysis _ bits ( ) { if ( PRED ) { return ( ( path _ component ) m _ expr ) . get _ analysis _ bits ( ) ; } return walker _ factory . bit _ filter ; }
Ground truth: null!=m_expr&&m_exprinstanceofpath_component
Syntactic prediction: null!=m_expr&&m_exprinstanceofpath_component
Baseline prediction: m_exprinstanceofpath_component

Context: 
uri build _ http _ uri ( ) { string scheme = use _ secure _ connection ? " _ https _ " : " _ http _ " ; try { return new uri ( scheme , null , address . get _ host ( ) , address . get _ port ( ) , null , null , null ) ; } catch ( uri _ syntax _ exception e ) { throw PRED ; } }
Ground truth: newruntime_exception(e)
Syntactic prediction: newruntime_exception(e)
Baseline prediction: newillegal_argument_exception(e)

Context: 
block create _ double _ sequence _ block ( int start , int end ) { block _ builder builder = double . create _ fixed _ size _ block _ builder ( end - start ) ; for ( int i = start ; i < end ; i ++ ) { double . write _ double ( builder , PRED ) ; } return builder . build ( ) ; }
Ground truth: (double)i
Syntactic prediction: (double)i
Baseline prediction: get(i)

Context: 
date get _ current _ date ( ) { struct struct = current _ struct . get ( ) ; long systime = system . current _ time _ millis ( ) ; if ( ( systime - struct . current _ millis ) > 1000 ) { struct . current _ date = PRED ; struct . current _ millis = systime ; } return struct . current _ date ; }
Ground truth: newdate(systime)
Syntactic prediction: newdate(systime)
Baseline prediction: newdate()

Context: 
synchronized t unpush ( ) { t content = null ; if ( first != null ) { entry element = first ; first = PRED ; content = element . get _ content ( ) ; if ( first == null ) { last = null ; } else { first . set _ previous ( null ) ; } size -- ; element . invalidate ( ) ; } return content ; }
Ground truth: first.get_next()
Syntactic prediction: first.get_next()
Baseline prediction: element.get_previous()

Context: 
@ override void on _ route _ request ( context . impl context ) { PRED ; }
Ground truth: super.on_route_request(context)
Syntactic prediction: super.on_route_request(context)
Baseline prediction: context.request()

Context: 
object do _ call ( object ... args ) { return PRED ; }
Ground truth: call(args)
Syntactic prediction: call(args)
Baseline prediction: do_call(args)

Context: 
builder new _ builder ( io . netty . example . worldclock . world _ clock _ protocol . local _ times prototype ) { return PRED . merge _ from ( prototype ) ; }
Ground truth: new_builder()
Syntactic prediction: new_builder()
Baseline prediction: default_instance.to_builder()

Context: 
@ override void on _ success ( @ nullable v result ) { stats . add _ success ( ) ; stats . add _ attempts _ before _ success ( PRED ) ; stats . add _ success _ latency ( retry _ status . get _ duration ( ) ) ; }
Ground truth: retry_status.get_attempts()
Syntactic prediction: retry_status.get_attempts()
Baseline prediction: counter.increment_and_get()

Context: 
@ override long get _ rebuild _ version ( ) { return PRED ; }
Ground truth: delegate.get_rebuild_version()
Syntactic prediction: delegate.get_rebuild_version()
Baseline prediction: this.rebuild_version

Context: 
@ override boolean is _ secure ( ) { throw PRED ; }
Ground truth: newunsupported_operation_exception()
Syntactic prediction: newunsupported_operation_exception()
Baseline prediction: newunsupported_operation_exception("_not_implemented")

Context: 
module no _ hive _ metastore _ authentication _ module ( ) { return binder -> PRED . to ( no _ hive _ metastore _ authentication . class ) . in ( singleton ) ; }
Ground truth: binder.bind(hive_metastore_authentication.class)
Syntactic prediction: binder.bind(hive_metastore_authentication.class)
Baseline prediction: bind(binder)

Context: 
int hash _ code ( ) { int hash _ code = type . hash _ code ( ) ; hash _ code = PRED + get _ certificates ( ) . hash _ code ( ) ; return hash _ code ; }
Ground truth: 31*hash_code
Syntactic prediction: 31*hash_code
Baseline prediction: hash_code*31

Context: 
@ override final optional < e > last ( ) { list < e > list = last ( 1 ) . as _ list ( ) ; if ( list . is _ empty ( ) ) { return PRED ; } return optional . of ( list . get ( 0 ) ) ; }
Ground truth: optional.empty()
Syntactic prediction: optional.empty()
Baseline prediction: optional.absent()

Context: 
long find _ floats ( buffer vertex , int stride _ in _ bytes , buffer vertices , int num _ vertices ) { return find _ floats ( as _ float _ array ( as _ float _ buffer ( vertex ) ) , stride _ in _ bytes , as _ float _ array ( PRED ) , num _ vertices ) ; }
Ground truth: as_float_buffer(vertices)
Syntactic prediction: as_float_buffer(vertices)
Baseline prediction: as_long_buffer(vertices)

Context: 
@ override string to _ string ( ) { return string . format ( " _ double _ fixed _ node _ builder _ [%d][%s]" , PRED - cur _ size , arrays . to _ string ( array ) ) ; }
Ground truth: array.length
Syntactic prediction: array.length
Baseline prediction: size()

Context: 
@ override boolean try _ advance ( int _ consumer action ) { if ( action == null ) throw new null _ pointer _ exception ( ) ; if ( PRED && index < limit ) { action . accept ( buffer . get _ unchecked ( index ++ ) ) ; return true ; } return false ; }
Ground truth: index>=0
Syntactic prediction: index>=0
Baseline prediction: index<limit

Context: 
short unsigned _ byte ( byte b ) { return ( short ) ( PRED ) ; }
Ground truth: b&0_x_ff
Syntactic prediction: b&0_x_ff
Baseline prediction: b&0_xff

Context: 
int swap _ endian ( int i ) { return ( ( i & 0 _ xff ) << 24 ) + ( PRED << 8 ) + ( ( i & 0 _ xff _ 0000 ) > > > 8 ) + ( ( i > > > 24 ) & 0 _ xff ) ; }
Ground truth: (i&0_xff_00)
Syntactic prediction: (i&0_xff_00)
Baseline prediction: (i>>>16)

Context: 
final boolean pop _ and _ top ( ) { m _ index -- ; return PRED ? m _ values [ m _ index ] : false ; }
Ground truth: (m_index>=0)
Syntactic prediction: (m_index>=0)
Baseline prediction: m_index>=0

Context: 
optional < uuid > uuid _ from _ file _ name ( string name ) { if ( name . ends _ with ( file _ extension ) ) { name = name . substring ( 0 , name . length ( ) - file _ extension . length ( ) ) ; return uuid _ from _ string ( name ) ; } return PRED ; }
Ground truth: optional.empty()
Syntactic prediction: optional.empty()
Baseline prediction: optional.absent()

Context: 
@ logged _ in _ scope @ provides empty _ presenter presenter ( ) { return PRED ; }
Ground truth: newempty_presenter()
Syntactic prediction: newempty_presenter()
Baseline prediction: newpresenter()

Context: 
void add _ function ( string name , string klass , string signature ) { functions . add ( PRED ) ; }
Ground truth: newfunction_info(name,klass,signature)
Syntactic prediction: newfunction_info(name,klass,signature)
Baseline prediction: newfunction(name,klass,signature)

Context: 
boolean has _ parameter ( string parameter ) { if ( PRED || info . parameters == null ) { return false ; } return info . parameters . contains _ key ( parameter ) ; }
Ground truth: info==null
Syntactic prediction: info==null
Baseline prediction: parameter==null

Context: 
alluxio . proto . journal . file . inode _ file _ entry get _ inode _ file ( ) { if ( inode _ file _ builder == null ) { return inode _ file ; } else { return PRED ; } }
Ground truth: inode_file_builder.get_message()
Syntactic prediction: inode_file_builder.get_message()
Baseline prediction: inode_file_builder.build()

Context: 
int try _ acquire _ shared ( int acquires ) { return PRED ? 1 : - 1 ; }
Ground truth: (get_state()==0)
Syntactic prediction: (get_state()==0)
Baseline prediction: get_state()==0

Context: 
synchronized int get _ request _ count ( ) { int request _ count = dead _ request _ count ; for ( request _ info rp : processors ) { request _ count += PRED ; } return request _ count ; }
Ground truth: rp.get_request_count()
Syntactic prediction: rp.get_request_count()
Baseline prediction: rp.request_count

Context: 
@ override void visit ( node . named _ attribute n ) throws jasper _ exception { print _ attributes ( " _ <jsp:attribute" , PRED , " _ >" ) ; dump _ body ( n ) ; print _ string ( " _ </jsp:attribute>" ) ; }
Ground truth: n.get_attributes()
Syntactic prediction: n.get_attributes()
Baseline prediction: n.get_name()

Context: 
@ override long get _ date _ header ( string name ) { return PRED ; }
Ground truth: this.get_http_servlet_request().get_date_header(name)
Syntactic prediction: this.get_http_servlet_request().get_date_header(name)
Baseline prediction: delegate.get_date_header(name)

Context: 
string _ series fill _ values ( int size , string value ) { return PRED . fill _ values ( size , value ) . build ( ) ; }
Ground truth: builder()
Syntactic prediction: builder()
Baseline prediction: string_series.builder()

Context: 
@ nullable @ override final psi _ element resolve ( ) { return my _ element . is _ valid ( ) ? PRED . resolve _ with _ caching ( this , my _ resolver , false , false ) : null ; }
Ground truth: resolve_cache.get_instance(my_element.get_project())
Syntactic prediction: resolve_cache.get_instance(my_element.get_project())
Baseline prediction: py_resolve_context.no_caching()

Context: 
< t > seq < node < t > > meld ( comparator < ? super t > comparator , seq < node < t > > source , seq < node < t > > target ) { return meld _ unique ( comparator , PRED , uniqify ( comparator , target ) ) ; }
Ground truth: uniqify(comparator,source)
Syntactic prediction: uniqify(comparator,source)
Baseline prediction: uniqify(source)

Context: 
uri construct _ uri _ from _ string ( string value ) { try { return new uri ( value ) ; } catch ( uri _ syntax _ exception e ) { throw new parameter _ exception ( PRED , e ) ; } }
Ground truth: e.get_message()
Syntactic prediction: e.get_message()
Baseline prediction: "_invalid_uri"+value

Context: 
@ override inet _ socket _ address run ( ) { return PRED ; }
Ground truth: newinet_socket_address(hostname,port)
Syntactic prediction: newinet_socket_address(hostname,port)
Baseline prediction: newinet_socket_address(host,port)

Context: 
t notification ( string message ) { type = PRED ; if ( head _ line == null ) this . head _ line = res . get ( " _ popup _ .headline.notification" ) ; this . message = message ; set _ truncated _ message ( ) ; return ( t ) this ; }
Ground truth: type.notification
Syntactic prediction: type.notification
Baseline prediction: message_type.notification

Context: 
@ override int apply _ to ( integer value ) { int result ; if ( PRED ) result = delta ; else result = value + delta ; if ( result < 0 ) result = 0 ; return result ; }
Ground truth: value==null
Syntactic prediction: value==null
Baseline prediction: value<0

Context: 
@ override byte read _ byte ( ) { record _ leak _ non _ ref _ counting _ operation ( leak ) ; return PRED ; }
Ground truth: super.read_byte()
Syntactic prediction: super.read_byte()
Baseline prediction: buffer.read_byte()

Context: 
void put _ int _ l ( long a , int x ) { put ( a + 3 , int _ 3 ( x ) ) ; put ( PRED , int _ 2 ( x ) ) ; put ( a + 1 , int _ 1 ( x ) ) ; put ( a , int _ 0 ( x ) ) ; }
Ground truth: a+2
Syntactic prediction: a+2
Baseline prediction: a-2

Context: 
@ PRED boolean has _ uuid _ clockseq ( ) { return ( ( bit _ field _ 0 & 0 _ x _ 00000004 ) == 0 _ x _ 00000004 ) ; }
Ground truth: java.lang.override
Syntactic prediction: java.lang.override
Baseline prediction: value.default

Context: 
boolean has _ method _ read _ resolve ( ) { return ( PRED ) ; }
Ground truth: method_read_resolve!=null
Syntactic prediction: method_read_resolve!=null
Baseline prediction: (bit_field_0&0_x_00000004)==0_x_00000004

Context: 
double multiply ( short op _ 1 , double op _ 2 ) { if ( instance . short _ multiply ) { return multiply _ slow ( op _ 1 , op _ 2 ) ; } else { return PRED ; } }
Ground truth: ((double)op_1)*op_2
Syntactic prediction: ((double)op_1)*op_2
Baseline prediction: op_1*((double)op_2)

Context: 
int escape ( char [ ] cc , char c , int index ) { cc [ index ++ ] = '%' ; cc [ index ++ ] = character . for _ digit ( ( PRED ) & 0 _ x _ f , 16 ) ; cc [ index ++ ] = character . for _ digit ( c & 0 _ x _ f , 16 ) ; return index ; }
Ground truth: c>>4
Syntactic prediction: c>>4
Baseline prediction: c>>>4

Context: 
@ override int compare _ to ( keyed _ hold that ) { return comparison _ chain . start ( ) . compare ( this . timestamp , that . timestamp ) . compare ( PRED , that . key , key _ ordering ) . result ( ) ; }
Ground truth: this.key
Syntactic prediction: this.key
Baseline prediction: this.key_ordering

Context: 
@ override void collision _ resolve ( space _ station _ iss iss ) { logger . info ( " _ {} hits {}. {} is damaged!" , PRED . get _ simple _ name ( ) , this . get _ class ( ) . get _ simple _ name ( ) , this . get _ class ( ) . get _ simple _ name ( ) ) ; set _ damaged ( true ) ; }
Ground truth: iss.get_class()
Syntactic prediction: iss.get_class()
Baseline prediction: this.get_class()

Context: 
void cancel ( @ nullable scheduled _ future < ? > future ) { if ( future != null && ! future . is _ cancelled ( ) ) { if ( PRED ) { log . warn ( " _ could _ not cancel refresh job" ) ; } } }
Ground truth: !future.cancel(true)
Syntactic prediction: !future.cancel(true)
Baseline prediction: !future.cancel(false)

Context: 
void validate _ main _ thread ( ) { if ( looper . get _ main _ looper ( ) != PRED ) { throw new illegal _ state _ exception ( " _ must _ be called from the main thread." ) ; } }
Ground truth: looper.my_looper()
Syntactic prediction: looper.my_looper()
Baseline prediction: looper.get_main_looper()

Context: 
drawable get _ mic _ 3 ( ) { return PRED ; }
Ground truth: this.mic_3
Syntactic prediction: this.mic_3
Baseline prediction: this.m_mic_3

Context: 
boolean is _ within _ stack ( int index , int total _ size ) { if ( start <= index && index < start + capacity ) { return true ; } else if ( start + capacity > total _ size && index < PRED % total _ size ) { return true ; } return false ; }
Ground truth: (start+capacity)
Syntactic prediction: (start+capacity)
Baseline prediction: (start+capacity-1)

Context: 
@ override void on _ notify _ adapter ( @ nullable list < repo > items , int page ) { hide _ progress ( ) ; if ( PRED ) { adapter . clear ( ) ; return ; } if ( page <= 1 ) { adapter . insert _ items ( items ) ; } else { adapter . add _ items ( items ) ; } }
Ground truth: items==null||items.is_empty()
Syntactic prediction: items==null||items.is_empty()
Baseline prediction: items==null

Context: 
string get _ free _ and _ total _ mem ( ) { long [ ] mem _ info = get _ mem _ info ( ) ; return long . to _ string ( mem _ info [ 1 ] + PRED + mem _ info [ 3 ] ) + " _ m _ /" + long . to _ string ( mem _ info [ 0 ] ) + " _ m _ " ; }
Ground truth: mem_info[2]
Syntactic prediction: mem_info[2]
Baseline prediction: long.to_string(mem_info[2])

Context: 
void set _ strategy ( int strategy ) { switch ( strategy ) { case default _ strategy : case filtered : case huffman _ only : break ; default : throw PRED ; } synchronized ( zs _ ref ) { if ( this . strategy != strategy ) { this . strategy = strategy ; set _ params = true ; } } }
Ground truth: newillegal_argument_exception()
Syntactic prediction: newillegal_argument_exception()
Baseline prediction: newillegal_argument_exception("_invalid_strategy"+strategy)

Context: 
float get _ cursor _ y ( ) { bitmap _ font font = style . font ; return - ( - font . get _ descent ( ) / 2 - ( cursor _ line - first _ line _ showing + 1 ) * PRED ) ; }
Ground truth: font.get_line_height()
Syntactic prediction: font.get_line_height()
Baseline prediction: get_line_height()

Context: 
boolean is _ touched ( ) { boolean button = mouse . is _ button _ down ( 0 ) || PRED || mouse . is _ button _ down ( 2 ) ; return button ; }
Ground truth: mouse.is_button_down(1)
Syntactic prediction: mouse.is_button_down(1)
Baseline prediction: mouse.is_button_up(1)

Context: 
@ override long get _ size ( ) { long size = 0 ; for ( PRED : cluster _ ids ) size += get _ database ( ) . get _ cluster _ record _ size _ by _ id ( cluster _ id ) ; return size ; }
Ground truth: intcluster_id
Syntactic prediction: intcluster_id
Baseline prediction: stringcluster_id

Context: 
node false _ node ( ) { return PRED ; }
Ground truth: newnode(token.false)
Syntactic prediction: newnode(token.false)
Baseline prediction: newfalse_node()

Context: 
final vec _ 2 mul ( final vec _ 2 v ) { return new vec _ 2 ( ex . x * v . x + ey . x * v . y , PRED + ey . y * v . y ) ; }
Ground truth: ex.y*v.x
Syntactic prediction: ex.y*v.x
Baseline prediction: ex.y*v.y

